import {
  ContainerHeaderContextProvider,
  DATA_ATTR_FUNNEL_INTERACTION_ID,
  DATA_ATTR_FUNNEL_STEP,
  DATA_ATTR_FUNNEL_SUBSTEP,
  DATA_ATTR_RESOURCE_TYPE,
  StickyHeaderContext,
  getAnalyticsLabelAttribute,
  getFunnelNameSelector,
  getSubStepAllSelector,
  getSubStepNameSelector,
  getSubStepSelector,
  getTextFromSelector,
  useMobile,
  useStickyHeader
} from "./chunk-S55FUYQK.js";
import {
  PACKAGE_VERSION,
  THEME,
  __awaiter,
  __rest,
  clsx_m_default,
  findUpUntil,
  getBaseProps,
  nodeContains,
  useMergeRefs,
  useUniqueId,
  useVisualRefresh
} from "./chunk-XHKPICKT.js";
import {
  require_react
} from "./chunk-QJTFJ6OV.js";
import {
  __commonJS,
  __toESM
} from "./chunk-V4OQ3NZ2.js";

// node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "node_modules/balanced-match/index.js"(exports, module) {
    "use strict";
    module.exports = balanced2;
    function balanced2(a, b, str) {
      if (a instanceof RegExp) a = maybeMatch(a, str);
      if (b instanceof RegExp) b = maybeMatch(b, str);
      var r = range(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced2.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        if (a === b) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// node_modules/@cloudscape-design/components/internal/analytics/components/analytics-funnel.js
var import_react4 = __toESM(require_react());

// node_modules/@cloudscape-design/components/internal/hooks/use-debounce-callback/index.js
var import_react = __toESM(require_react());

// node_modules/@cloudscape-design/components/internal/debounce.js
var DEBOUNCE_DEFAULT_DELAY = 200;
function debounce(func, delay = DEBOUNCE_DEFAULT_DELAY) {
  let timeout;
  return function(...args) {
    if (timeout) {
      clearTimeout(timeout);
    }
    timeout = setTimeout(() => {
      timeout = null;
      func(...args);
    }, delay);
  };
}

// node_modules/@cloudscape-design/components/internal/hooks/use-debounce-callback/index.js
function useDebounceCallback(callback, delay) {
  const callbackRef = (0, import_react.useRef)();
  callbackRef.current = callback;
  return (0, import_react.useCallback)(debounce((...args) => {
    if (callbackRef.current) {
      callbackRef.current(...args);
    }
  }, delay), []);
}

// node_modules/@cloudscape-design/components/internal/utils/dom.js
var import_balanced_match = __toESM(require_balanced_match());
function isContainingBlock(element) {
  var _a;
  const computedStyle = getComputedStyle(element);
  return !!computedStyle.transform && computedStyle.transform !== "none" || !!computedStyle.perspective && computedStyle.perspective !== "none" || ((_a = computedStyle.contain) === null || _a === void 0 ? void 0 : _a.split(" ").some((s) => ["layout", "paint", "strict", "content"].includes(s)));
}
function getContainingBlock(startElement) {
  if (!startElement.parentElement) {
    return null;
  }
  return findUpUntil(startElement.parentElement, isContainingBlock);
}
function findUpUntilMultiple({ startElement, tests }) {
  const keys = Object.keys(tests);
  const elements = {};
  let current = startElement;
  while (current && Object.keys(elements).length < keys.length) {
    current = current.parentElement;
    while (current && !isHTMLElement(current)) {
      current = current.parentElement;
    }
    for (const key of keys) {
      if (!elements[key] && current && tests[key](current)) {
        elements[key] = current;
      }
    }
  }
  return elements;
}
var cssVariableExpression = /--.+?\s*,\s*(.+)/;
function parseCssVariable(value) {
  var _a, _b, _c;
  if (typeof window === "undefined") {
    return value;
  }
  if ((_c = (_b = (_a = window.CSS) === null || _a === void 0 ? void 0 : _a.supports) === null || _b === void 0 ? void 0 : _b.call(_a, "color", "var(--dummy, #000)")) !== null && _c !== void 0 ? _c : false) {
    return value;
  }
  const varIndex = value.lastIndexOf("var(");
  if (varIndex === -1) {
    return value;
  }
  const expr = (0, import_balanced_match.default)("(", ")", value.substr(varIndex));
  if (!expr) {
    return value;
  }
  const match = expr.body.match(cssVariableExpression);
  return match ? match[1] : value;
}
function isNode(target) {
  return target instanceof Node || target !== null && typeof target === "object" && "nodeType" in target && typeof target.nodeType === "number" && "nodeName" in target && typeof target.nodeName === "string" && "parentNode" in target && typeof target.parentNode === "object";
}
function isHTMLElement(target) {
  return target instanceof HTMLElement || isNode(target) && target.nodeType === Node.ELEMENT_NODE && "style" in target && typeof target.style === "object" && typeof target.ownerDocument === "object" && !isSVGElement(target);
}
function isSVGElement(target) {
  return target instanceof SVGElement || isNode(target) && target.nodeType === Node.ELEMENT_NODE && "ownerSVGElement" in target && typeof target.ownerSVGElement === "object";
}

// node_modules/@cloudscape-design/components/internal/utils/node-belongs.js
function nodeBelongs(container, target) {
  var _a;
  if (!isNode(target)) {
    return false;
  }
  const portal = findUpUntil(target, (node) => node === container || isHTMLElement(node) && !!node.dataset.awsuiReferrerId);
  if (portal && portal === container) {
    return true;
  }
  const referrer = isHTMLElement(portal) ? document.getElementById((_a = portal.dataset.awsuiReferrerId) !== null && _a !== void 0 ? _a : "") : null;
  return referrer ? nodeContains(container, referrer) : nodeContains(container, target);
}

// node_modules/@cloudscape-design/components/internal/analytics/context/analytics-context.js
var import_react2 = __toESM(require_react());
var FunnelContext = (0, import_react2.createContext)({
  funnelInteractionId: void 0,
  funnelNameSelector: getFunnelNameSelector(),
  setFunnelInteractionId: () => {
  },
  funnelType: "single-page",
  optionalStepNumbers: [],
  totalFunnelSteps: 0,
  funnelSubmit: () => {
  },
  funnelCancel: () => {
  },
  submissionAttempt: 0,
  funnelNextOrSubmitAttempt: () => {
  },
  funnelState: { current: "default" },
  errorCount: { current: 0 },
  loadingButtonCount: { current: 0 },
  latestFocusCleanupFunction: { current: void 0 },
  isInFunnel: false,
  wizardCount: { current: 0 }
});
var FunnelStepContext = (0, import_react2.createContext)({
  stepNameSelector: "",
  stepNumber: 0,
  subStepCount: { current: 0 },
  isInStep: false,
  funnelInteractionId: void 0,
  onStepChange: () => {
  },
  subStepConfiguration: { current: /* @__PURE__ */ new Map() }
});
var FunnelSubStepContext = (0, import_react2.createContext)({
  subStepId: "",
  subStepSelector: "",
  subStepNameSelector: "",
  subStepRef: { current: null },
  isNestedSubStep: false,
  mousePressed: { current: false },
  isFocusedSubStep: { current: false },
  focusCleanupFunction: { current: void 0 }
});
var FunnelNameSelectorContext = (0, import_react2.createContext)(void 0);

// node_modules/@cloudscape-design/components/internal/analytics/hooks/use-funnel.js
var import_react3 = __toESM(require_react());

// node_modules/@cloudscape-design/components/internal/analytics/index.js
var FunnelMetrics = {
  funnelStart() {
    return "";
  },
  funnelError() {
  },
  funnelComplete() {
  },
  funnelSuccessful() {
  },
  funnelCancelled() {
  },
  funnelChange() {
  },
  funnelStepStart() {
  },
  funnelStepComplete() {
  },
  funnelStepNavigation() {
  },
  funnelStepError() {
  },
  funnelStepChange() {
  },
  funnelSubStepStart() {
  },
  funnelSubStepComplete() {
  },
  funnelSubStepError() {
  },
  helpPanelInteracted() {
  },
  externalLinkInteracted() {
  }
};
var PerformanceMetrics = {
  tableInteraction() {
  },
  taskCompletionData() {
  },
  modalPerformanceData() {
  }
};
var ComponentMetrics = {
  componentMounted() {
    return "";
  },
  componentUpdated() {
  }
};

// node_modules/@cloudscape-design/components/internal/analytics/hooks/use-funnel.js
var useFunnelSubStep = () => {
  const context = (0, import_react3.useContext)(FunnelSubStepContext);
  const { funnelInteractionId, funnelIdentifier, funnelState, latestFocusCleanupFunction } = useFunnel();
  const { stepNumber, stepIdentifier, stepNameSelector, subStepConfiguration } = useFunnelStep();
  const { subStepIdentifier, subStepId, subStepSelector, subStepNameSelector, subStepRef, isNestedSubStep, mousePressed, isFocusedSubStep, focusCleanupFunction } = context;
  if (isNestedSubStep) {
    return context;
  }
  const onFocus = (event) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b, _c, _d;
    const element = event.target;
    yield new Promise((r) => setTimeout(r, 1));
    if (document.activeElement !== element) {
      return;
    }
    if (isFocusedSubStep.current) {
      return;
    }
    isFocusedSubStep.current = true;
    if (funnelInteractionId && subStepId) {
      (_a = latestFocusCleanupFunction.current) === null || _a === void 0 ? void 0 : _a.call(latestFocusCleanupFunction);
      const subStepName = getTextFromSelector(subStepNameSelector);
      const stepName = getTextFromSelector(stepNameSelector);
      const subStepNumber = (_d = (_c = (_b = subStepConfiguration.current) === null || _b === void 0 ? void 0 : _b.get(stepNumber)) === null || _c === void 0 ? void 0 : _c.find((step) => step.name === subStepName)) === null || _d === void 0 ? void 0 : _d.number;
      FunnelMetrics.funnelSubStepStart({
        funnelIdentifier,
        funnelInteractionId,
        subStepIdentifier,
        subStepSelector,
        subStepNameSelector,
        subStepName,
        subStepNumber,
        stepIdentifier,
        stepNumber,
        stepName,
        stepNameSelector,
        subStepAllSelector: getSubStepAllSelector()
      });
      let cleanupFunctionHasBeenRun = false;
      focusCleanupFunction.current = () => {
        var _a2, _b2, _c2;
        if (cleanupFunctionHasBeenRun) {
          return;
        }
        cleanupFunctionHasBeenRun = true;
        const subStepNumber2 = (_c2 = (_b2 = (_a2 = subStepConfiguration.current) === null || _a2 === void 0 ? void 0 : _a2.get(stepNumber)) === null || _b2 === void 0 ? void 0 : _b2.find((s) => s.name === subStepName)) === null || _c2 === void 0 ? void 0 : _c2.number;
        if (funnelState.current !== "cancelled") {
          FunnelMetrics.funnelSubStepComplete({
            funnelIdentifier,
            funnelInteractionId,
            subStepIdentifier,
            subStepSelector,
            subStepNameSelector,
            subStepName,
            subStepNumber: subStepNumber2,
            stepIdentifier,
            stepNumber,
            stepName,
            stepNameSelector,
            subStepAllSelector: getSubStepAllSelector()
          });
        }
      };
      latestFocusCleanupFunction.current = focusCleanupFunction.current;
    }
  });
  const onBlur = (event) => {
    var _a;
    if (mousePressed.current) {
      return;
    }
    if (!subStepRef.current || !event.relatedTarget || !nodeBelongs(subStepRef.current, event.relatedTarget)) {
      isFocusedSubStep.current = false;
      if (funnelInteractionId && subStepId && funnelState.current !== "cancelled") {
        (_a = focusCleanupFunction.current) === null || _a === void 0 ? void 0 : _a.call(focusCleanupFunction);
      }
    }
  };
  const funnelSubStepProps = funnelInteractionId ? {
    [DATA_ATTR_FUNNEL_SUBSTEP]: subStepId,
    onFocus,
    onBlur
  } : {};
  return Object.assign({ funnelSubStepProps }, context);
};
var useFunnelStep = () => {
  const context = (0, import_react3.useContext)(FunnelStepContext);
  return context;
};
var useFunnelStepRef = () => {
  const funnelStep = useFunnelStep();
  const funnelStepRef = (0, import_react3.useRef)(funnelStep);
  funnelStepRef.current = funnelStep;
  return funnelStepRef;
};
var useFunnel = () => {
  const context = (0, import_react3.useContext)(FunnelContext);
  const funnelProps = context.funnelInteractionId ? {
    [DATA_ATTR_FUNNEL_INTERACTION_ID]: context.funnelInteractionId
  } : {};
  return Object.assign({ funnelProps }, context);
};
var useFunnelNameSelector = () => {
  const context = (0, import_react3.useContext)(FunnelNameSelectorContext);
  return context;
};

// node_modules/@cloudscape-design/components/internal/analytics/components/analytics-funnel.js
var FUNNEL_VERSION = "1.4";
var AnalyticsFunnel = (props) => {
  const { isInFunnel } = useFunnel();
  if (isInFunnel && props.funnelType === "single-page") {
    return import_react4.default.createElement(import_react4.default.Fragment, null, props.children);
  }
  return import_react4.default.createElement(InnerAnalyticsFunnel, Object.assign({}, props));
};
var CREATION_EDIT_FLOW_DONE_EVENT_NAME = "awsui-creation-edit-flow-done";
var dispatchCreateEditFlowDoneEvent = () => {
  var _a;
  try {
    (_a = window.top) === null || _a === void 0 ? void 0 : _a.document.dispatchEvent(new Event(CREATION_EDIT_FLOW_DONE_EVENT_NAME));
  } catch (_b) {
  }
};
var onFunnelCancelled = ({ funnelInteractionId, funnelIdentifier }) => {
  FunnelMetrics.funnelCancelled({ funnelInteractionId, funnelIdentifier });
};
var onFunnelComplete = (taskCompletionDataProps) => {
  FunnelMetrics.funnelComplete({
    funnelInteractionId: taskCompletionDataProps.taskInteractionId,
    funnelIdentifier: taskCompletionDataProps.taskIdentifier
  });
  PerformanceMetrics.taskCompletionData(taskCompletionDataProps);
  dispatchCreateEditFlowDoneEvent();
};
function evaluateSelectors(selectors, defaultSelector) {
  for (const selector of selectors) {
    const element = document.querySelector(selector);
    if (element) {
      return selector;
    }
  }
  return defaultSelector;
}
var InnerAnalyticsFunnel = (_a) => {
  var { mounted = true, children, stepConfiguration } = _a, props = __rest(_a, ["mounted", "children", "stepConfiguration"]);
  const [funnelInteractionId, setFunnelInteractionId] = (0, import_react4.useState)("");
  const [submissionAttempt, setSubmissionAttempt] = (0, import_react4.useState)(0);
  const isVisualRefresh = useVisualRefresh();
  const funnelState = (0, import_react4.useRef)("default");
  const funnelNameSelector = (0, import_react4.useRef)(getFunnelNameSelector());
  const errorCount = (0, import_react4.useRef)(0);
  const loadingButtonCount = (0, import_react4.useRef)(0);
  const wizardCount = (0, import_react4.useRef)(0);
  const latestFocusCleanupFunction = (0, import_react4.useRef)(void 0);
  const formSubmitStartTime = (0, import_react4.useRef)(0);
  (0, import_react4.useEffect)(() => {
    if (!mounted) {
      return;
    }
    let funnelInteractionId2;
    const handle = setTimeout(() => {
      var _a2, _b;
      funnelNameSelector.current = evaluateSelectors(((_a2 = props.funnelNameSelectors) === null || _a2 === void 0 ? void 0 : _a2.call(props)) || [], getFunnelNameSelector());
      if (props.funnelType === "single-page" && wizardCount.current > 0) {
        return;
      }
      funnelState.current = "default";
      const funnelName = (_b = getTextFromSelector(funnelNameSelector.current)) !== null && _b !== void 0 ? _b : "";
      const singleStepFlowStepConfiguration = [
        {
          number: 1,
          isOptional: false,
          name: funnelName,
          stepIdentifier: props.funnelIdentifier
        }
      ];
      let componentTheme = THEME;
      if (THEME === "polaris") {
        componentTheme = isVisualRefresh ? "vr" : "classic";
      }
      funnelInteractionId2 = FunnelMetrics.funnelStart({
        funnelName,
        funnelIdentifier: props.funnelIdentifier,
        flowType: props.funnelFlowType,
        funnelNameSelector: funnelNameSelector.current,
        optionalStepNumbers: props.optionalStepNumbers,
        funnelType: props.funnelType,
        totalFunnelSteps: props.totalFunnelSteps,
        componentVersion: PACKAGE_VERSION,
        componentTheme,
        funnelVersion: FUNNEL_VERSION,
        stepConfiguration: stepConfiguration !== null && stepConfiguration !== void 0 ? stepConfiguration : singleStepFlowStepConfiguration,
        resourceType: props.funnelResourceType || getTextFromSelector(`[${DATA_ATTR_RESOURCE_TYPE}]`)
      });
      setFunnelInteractionId(funnelInteractionId2);
    }, 1);
    return () => {
      clearTimeout(handle);
      if (props.funnelType === "single-page" && wizardCount.current > 0) {
        return;
      }
      if (funnelState.current === "validating") {
        const taskCompletionDataProps = {
          taskIdentifier: props.funnelIdentifier,
          taskType: props.funnelType,
          timeToRespondAfterFormSubmit: performance.now() - formSubmitStartTime.current,
          taskInteractionId: funnelInteractionId2,
          taskFlowType: props.funnelFlowType
        };
        onFunnelComplete(taskCompletionDataProps);
        funnelState.current = "complete";
      }
      if (funnelState.current === "complete") {
        FunnelMetrics.funnelSuccessful({ funnelInteractionId: funnelInteractionId2, funnelIdentifier: props.funnelIdentifier });
      } else {
        funnelState.current = "cancelled";
        onFunnelCancelled({ funnelInteractionId: funnelInteractionId2, funnelIdentifier: props.funnelIdentifier });
      }
    };
  }, [mounted]);
  const funnelSubmit = () => {
    funnelState.current = "validating";
    formSubmitStartTime.current = performance.now();
    const VALIDATION_WAIT_DELAY = 50;
    const LOADING_WAIT_DELAY = 100;
    const checkForCompleteness = () => {
      if (funnelState.current === "complete") {
        return;
      }
      if (loadingButtonCount.current > 0) {
        setTimeout(checkForCompleteness, LOADING_WAIT_DELAY);
        return;
      }
      if (errorCount.current === 0) {
        const taskCompletionDataProps = {
          taskIdentifier: props.funnelIdentifier,
          taskType: props.funnelType,
          timeToRespondAfterFormSubmit: performance.now() - formSubmitStartTime.current,
          taskInteractionId: funnelInteractionId,
          taskFlowType: props.funnelFlowType
        };
        onFunnelComplete(taskCompletionDataProps);
        funnelState.current = "complete";
      } else {
        funnelState.current = "default";
      }
    };
    setTimeout(checkForCompleteness, VALIDATION_WAIT_DELAY);
  };
  const funnelNextOrSubmitAttempt = () => setSubmissionAttempt((i) => i + 1);
  const funnelCancel = () => {
  };
  const funnelContextValue = {
    funnelInteractionId,
    funnelIdentifier: props.funnelIdentifier,
    funnelFlowType: props.funnelFlowType,
    funnelErrorContext: props.funnelErrorContext,
    setFunnelInteractionId,
    funnelType: props.funnelType,
    optionalStepNumbers: props.optionalStepNumbers,
    totalFunnelSteps: props.totalFunnelSteps,
    funnelNameSelector: funnelNameSelector.current,
    funnelSubmit,
    funnelCancel,
    submissionAttempt,
    funnelNextOrSubmitAttempt,
    funnelState,
    errorCount,
    loadingButtonCount,
    latestFocusCleanupFunction,
    isInFunnel: true,
    wizardCount
  };
  return import_react4.default.createElement(FunnelContext.Provider, { value: funnelContextValue }, children);
};
var AnalyticsFunnelStep = (props) => {
  return import_react4.default.createElement(InnerAnalyticsFunnelStep, Object.assign({}, props, { key: props.stepNumber }));
};
function getSubStepConfiguration() {
  const subSteps = Array.from(document.querySelectorAll(getSubStepAllSelector()));
  const subStepConfiguration = subSteps.map((substep, index) => {
    var _a, _b, _c, _d, _e;
    const subStepIdentifier = (_b = (_a = substep === null || substep === void 0 ? void 0 : substep.__awsuiMetadata__) === null || _a === void 0 ? void 0 : _a.analytics) === null || _b === void 0 ? void 0 : _b.instanceIdentifier;
    const name = (_e = (_d = (_c = substep.querySelector(getSubStepNameSelector())) === null || _c === void 0 ? void 0 : _c.innerText) === null || _d === void 0 ? void 0 : _d.trim()) !== null && _e !== void 0 ? _e : "";
    return {
      name,
      number: index + 1,
      subStepIdentifier
    };
  });
  return subStepConfiguration;
}
function useStepChangeListener(stepNumber, handler) {
  const subStepConfiguration = (0, import_react4.useRef)(/* @__PURE__ */ new Map());
  const SUBSTEP_CHANGE_DEBOUNCE = 50;
  const listenForSubStepChanges = (0, import_react4.useRef)(false);
  (0, import_react4.useEffect)(() => {
    const handle = setTimeout(() => listenForSubStepChanges.current = true, SUBSTEP_CHANGE_DEBOUNCE);
    return () => {
      clearTimeout(handle);
      listenForSubStepChanges.current = false;
    };
  }, []);
  (0, import_react4.useEffect)(() => {
    const handle = setTimeout(() => subStepConfiguration.current.set(stepNumber, getSubStepConfiguration()), SUBSTEP_CHANGE_DEBOUNCE);
    return () => {
      clearTimeout(handle);
    };
  }, [stepNumber]);
  const stepChangeCallback = useDebounceCallback(() => {
    if (!listenForSubStepChanges.current) {
      return;
    }
    subStepConfiguration.current.set(stepNumber, getSubStepConfiguration());
    handler(subStepConfiguration.current.get(stepNumber));
  }, SUBSTEP_CHANGE_DEBOUNCE);
  return { onStepChange: stepChangeCallback, subStepConfiguration };
}
var InnerAnalyticsFunnelStep = (_a) => {
  var { mounted = true, children, stepNumber, stepIdentifier, stepErrorContext } = _a, rest = __rest(_a, ["mounted", "children", "stepNumber", "stepIdentifier", "stepErrorContext"]);
  const { funnelInteractionId, funnelIdentifier, funnelNameSelector, funnelState, funnelType } = useFunnel();
  const parentStep = useFunnelStep();
  const parentStepExists = parentStep.isInStep;
  const parentStepFunnelInteractionId = parentStep.funnelInteractionId;
  const funnelStepProps = { [DATA_ATTR_FUNNEL_STEP]: stepNumber };
  const subStepCount = (0, import_react4.useRef)(0);
  const stepNameSelector = rest.stepNameSelector || funnelNameSelector;
  const { onStepChange, subStepConfiguration } = useStepChangeListener(stepNumber, (subStepConfiguration2) => {
    if (!funnelInteractionId) {
      return;
    }
    FunnelMetrics.funnelStepChange({
      stepIdentifier,
      funnelIdentifier,
      funnelInteractionId,
      stepNumber,
      stepNameSelector,
      subStepAllSelector: getSubStepAllSelector(),
      totalSubSteps: subStepCount.current,
      subStepConfiguration: subStepConfiguration2
    });
  });
  (0, import_react4.useEffect)(() => {
    if (!funnelInteractionId) {
      return;
    }
    if (mounted) {
      return;
    }
    const stepName = getTextFromSelector(stepNameSelector);
    const handler = setTimeout(() => {
      if (funnelState.current !== "cancelled") {
        FunnelMetrics.funnelStepComplete({
          funnelIdentifier,
          funnelInteractionId,
          stepIdentifier,
          stepNumber,
          stepName,
          stepNameSelector,
          subStepAllSelector: getSubStepAllSelector(),
          totalSubSteps: subStepCount.current
        });
      }
    }, 0);
    return () => {
      clearTimeout(handler);
    };
  }, [
    stepIdentifier,
    funnelIdentifier,
    funnelInteractionId,
    stepNumber,
    stepNameSelector,
    funnelState,
    parentStepExists,
    funnelType,
    parentStepFunnelInteractionId,
    mounted
  ]);
  (0, import_react4.useEffect)(() => {
    if (!funnelInteractionId) {
      return;
    }
    if (parentStepExists && parentStepFunnelInteractionId) {
      return;
    }
    const stepName = getTextFromSelector(stepNameSelector);
    if (funnelState.current === "default") {
      FunnelMetrics.funnelStepStart({
        stepIdentifier,
        funnelIdentifier,
        funnelInteractionId,
        stepNumber,
        stepName,
        stepNameSelector,
        subStepAllSelector: getSubStepAllSelector(),
        totalSubSteps: subStepCount.current,
        subStepConfiguration: getSubStepConfiguration()
      });
    }
    return () => {
      if (funnelState.current !== "cancelled") {
        FunnelMetrics.funnelStepComplete({
          funnelIdentifier,
          funnelInteractionId,
          stepIdentifier,
          stepNumber,
          stepName,
          stepNameSelector,
          subStepAllSelector: getSubStepAllSelector(),
          // eslint-disable-next-line react-hooks/exhaustive-deps
          totalSubSteps: subStepCount.current
        });
      }
    };
  }, [
    stepIdentifier,
    funnelIdentifier,
    funnelInteractionId,
    stepNumber,
    stepNameSelector,
    funnelState,
    parentStepExists,
    funnelType,
    parentStepFunnelInteractionId
  ]);
  const contextValue = {
    stepIdentifier,
    stepNumber,
    stepNameSelector,
    funnelStepProps,
    subStepCount,
    isInStep: true,
    funnelInteractionId,
    onStepChange,
    subStepConfiguration,
    stepErrorContext
  };
  const effectiveContextValue = parentStepExists && parentStepFunnelInteractionId ? parentStep : contextValue;
  return import_react4.default.createElement(FunnelStepContext.Provider, { value: effectiveContextValue }, typeof children === "function" ? children(effectiveContextValue) : children);
};
var AnalyticsFunnelSubStep = ({ children, subStepIdentifier, subStepErrorContext }) => {
  const subStepId = useUniqueId("substep");
  const subStepSelector = getSubStepSelector(subStepId);
  const subStepNameSelector = getSubStepNameSelector(subStepId);
  const subStepRef = (0, import_react4.useRef)(null);
  const { subStepCount, onStepChange } = useFunnelStep();
  const mousePressed = (0, import_react4.useRef)(false);
  const isFocusedSubStep = (0, import_react4.useRef)(false);
  const focusCleanupFunction = (0, import_react4.useRef)(void 0);
  const { funnelState, funnelInteractionId } = useFunnel();
  const { stepNumber, stepNameSelector } = useFunnelStep();
  const newContext = {
    subStepIdentifier,
    subStepErrorContext,
    subStepSelector,
    subStepNameSelector,
    subStepId,
    subStepRef,
    mousePressed,
    isFocusedSubStep,
    focusCleanupFunction,
    isNestedSubStep: false
  };
  const inheritedContext = Object.assign(Object.assign({}, (0, import_react4.useContext)(FunnelSubStepContext)), { isNestedSubStep: true });
  const isNested = Boolean(inheritedContext.subStepId);
  (0, import_react4.useEffect)(() => {
    if (!isNested) {
      subStepCount.current++;
      onStepChange();
      return () => {
        subStepCount.current--;
        onStepChange();
      };
    }
  }, [isNested, subStepCount, onStepChange]);
  const context = isNested ? inheritedContext : newContext;
  (0, import_react4.useEffect)(() => {
    if (isNested || !subStepRef.current) {
      return;
    }
    const onMouseDown = () => mousePressed.current = true;
    const onMouseUp = () => __awaiter(void 0, void 0, void 0, function* () {
      var _a;
      mousePressed.current = false;
      if (!isFocusedSubStep.current) {
        return;
      }
      yield new Promise((r) => setTimeout(r, 1));
      if (!subStepRef.current || !document.activeElement || !nodeBelongs(subStepRef.current, document.activeElement)) {
        isFocusedSubStep.current = false;
        (_a = focusCleanupFunction.current) === null || _a === void 0 ? void 0 : _a.call(focusCleanupFunction);
      }
    });
    const controller = new AbortController();
    window.addEventListener("mousedown", onMouseDown, { signal: controller.signal });
    window.addEventListener("mouseup", onMouseUp, { signal: controller.signal });
    return () => {
      controller.abort();
    };
  }, [
    funnelInteractionId,
    funnelState,
    stepNameSelector,
    stepNumber,
    subStepNameSelector,
    subStepSelector,
    focusCleanupFunction,
    isNested,
    subStepRef
  ]);
  return import_react4.default.createElement(FunnelSubStepContext.Provider, { value: context }, typeof children === "function" ? children(context) : children);
};

// node_modules/@cloudscape-design/components/container/internal.js
var import_react6 = __toESM(require_react());

// node_modules/@cloudscape-design/components/internal/context/modal-context.js
var import_react5 = __toESM(require_react());
var ModalContext = (0, import_react5.createContext)({
  isInModal: false,
  componentLoadingCount: { current: 0 },
  emitTimeToContentReadyInModal: () => {
  }
});
var useModalContext = () => {
  const modalContext = (0, import_react5.useContext)(ModalContext);
  return modalContext;
};

// node_modules/@cloudscape-design/components/container/analytics-metadata/styles.css.js
import "/Users/shikaradee/raghu/GenAi/MachineLearning/reactapp/plat/frontend/node_modules/@cloudscape-design/components/container/analytics-metadata/styles.scoped.css";
var styles_css_default = {
  "header": "awsui_header_164jl_1ns0c_5"
};

// node_modules/@cloudscape-design/components/container/styles.css.js
import "/Users/shikaradee/raghu/GenAi/MachineLearning/reactapp/plat/frontend/node_modules/@cloudscape-design/components/container/styles.scoped.css";
var styles_css_default2 = {
  "root": "awsui_root_14iqq_1vhb3_189",
  "fit-height": "awsui_fit-height_14iqq_1vhb3_222",
  "with-side-media": "awsui_with-side-media_14iqq_1vhb3_227",
  "variant-default": "awsui_variant-default_14iqq_1vhb3_230",
  "variant-stacked": "awsui_variant-stacked_14iqq_1vhb3_230",
  "refresh": "awsui_refresh_14iqq_1vhb3_238",
  "sticky-enabled": "awsui_sticky-enabled_14iqq_1vhb3_288",
  "with-stuck-sticky-header-at-bottom": "awsui_with-stuck-sticky-header-at-bottom_14iqq_1vhb3_294",
  "with-top-media": "awsui_with-top-media_14iqq_1vhb3_304",
  "content-wrapper": "awsui_content-wrapper_14iqq_1vhb3_309",
  "content-wrapper-fit-height": "awsui_content-wrapper-fit-height_14iqq_1vhb3_314",
  "media": "awsui_media_14iqq_1vhb3_321",
  "media-top": "awsui_media-top_14iqq_1vhb3_339",
  "media-side": "awsui_media-side_14iqq_1vhb3_344",
  "header": "awsui_header_14iqq_1vhb3_350",
  "header-full-page": "awsui_header-full-page_14iqq_1vhb3_355",
  "header-variant-embedded": "awsui_header-variant-embedded_14iqq_1vhb3_358",
  "header-sticky-enabled": "awsui_header-sticky-enabled_14iqq_1vhb3_358",
  "header-with-media": "awsui_header-with-media_14iqq_1vhb3_361",
  "header-sticky-disabled": "awsui_header-sticky-disabled_14iqq_1vhb3_367",
  "header-stuck": "awsui_header-stuck_14iqq_1vhb3_377",
  "header-variant-cards": "awsui_header-variant-cards_14iqq_1vhb3_387",
  "header-dynamic-height": "awsui_header-dynamic-height_14iqq_1vhb3_390",
  "with-paddings": "awsui_with-paddings_14iqq_1vhb3_396",
  "with-hidden-content": "awsui_with-hidden-content_14iqq_1vhb3_405",
  "header-variant-full-page": "awsui_header-variant-full-page_14iqq_1vhb3_463",
  "header-cover": "awsui_header-cover_14iqq_1vhb3_466",
  "content": "awsui_content_14iqq_1vhb3_309",
  "content-fit-height": "awsui_content-fit-height_14iqq_1vhb3_494",
  "content-inner": "awsui_content-inner_14iqq_1vhb3_500",
  "with-header": "awsui_with-header_14iqq_1vhb3_507",
  "footer": "awsui_footer_14iqq_1vhb3_511",
  "with-divider": "awsui_with-divider_14iqq_1vhb3_515"
};

// node_modules/@cloudscape-design/components/container/test-classes/styles.css.js
import "/Users/shikaradee/raghu/GenAi/MachineLearning/reactapp/plat/frontend/node_modules/@cloudscape-design/components/container/test-classes/styles.scoped.css";
var styles_css_default3 = {
  "content-inner": "awsui_content-inner_1mwlm_oyjaq_5"
};

// node_modules/@cloudscape-design/components/container/internal.js
function InternalContainerAsSubstep(props) {
  const { subStepRef, funnelSubStepProps } = useFunnelSubStep();
  const modalContext = useModalContext();
  return import_react6.default.createElement(InternalContainer, Object.assign({}, props, { __subStepRef: (modalContext === null || modalContext === void 0 ? void 0 : modalContext.isInModal) ? { current: null } : subStepRef, __funnelSubStepProps: (modalContext === null || modalContext === void 0 ? void 0 : modalContext.isInModal) ? {} : funnelSubStepProps }));
}
function InternalContainer(_a) {
  var _b;
  var { header, footer, children, variant = "default", disableHeaderPaddings = false, disableContentPaddings = false, disableFooterPaddings = false, fitHeight, media, __stickyOffset, __mobileStickyOffset, __stickyHeader = false, __internalRootRef = null, __disableFooterDivider = false, __hiddenContent = false, __headerRef, __fullPage = false, __disableStickyMobile = true, __funnelSubStepProps, __subStepRef } = _a, restProps = __rest(_a, ["header", "footer", "children", "variant", "disableHeaderPaddings", "disableContentPaddings", "disableFooterPaddings", "fitHeight", "media", "__stickyOffset", "__mobileStickyOffset", "__stickyHeader", "__internalRootRef", "__disableFooterDivider", "__hiddenContent", "__headerRef", "__fullPage", "__disableStickyMobile", "__funnelSubStepProps", "__subStepRef"]);
  const isMobile = useMobile();
  const isRefresh = useVisualRefresh();
  const baseProps = getBaseProps(restProps);
  const rootRef = (0, import_react6.useRef)(null);
  const headerRef = (0, import_react6.useRef)(null);
  const { isSticky, isStuck, isStuckAtBottom, stickyStyles } = useStickyHeader(rootRef, headerRef, __stickyHeader, __stickyOffset, __mobileStickyOffset, __disableStickyMobile, __fullPage && isRefresh && !isMobile);
  const contentId = useUniqueId();
  const hasDynamicHeight = isRefresh && variant === "full-page";
  const mergedRef = useMergeRefs(rootRef, __internalRootRef);
  const headerMergedRef = useMergeRefs(headerRef, __headerRef);
  const shouldHaveStickyStyles = isSticky && !isMobile;
  const hasMedia = !!(media === null || media === void 0 ? void 0 : media.content);
  const mediaPosition = (_b = media === null || media === void 0 ? void 0 : media.position) !== null && _b !== void 0 ? _b : "top";
  return import_react6.default.createElement(
    "div",
    Object.assign({}, baseProps, __funnelSubStepProps, { className: clsx_m_default(baseProps.className, styles_css_default2.root, styles_css_default2[`variant-${variant}`], fitHeight && styles_css_default2["fit-height"], hasMedia && (mediaPosition === "side" ? styles_css_default2["with-side-media"] : styles_css_default2["with-top-media"]), shouldHaveStickyStyles && [styles_css_default2["sticky-enabled"]], shouldHaveStickyStyles && isStuck && isStuckAtBottom && [styles_css_default2["with-stuck-sticky-header-at-bottom"]], isRefresh && styles_css_default2.refresh), ref: mergedRef }, getAnalyticsLabelAttribute(`.${styles_css_default.header} h1, .${styles_css_default.header} h2, .${styles_css_default.header} h3`)),
    hasMedia && import_react6.default.createElement("div", { className: clsx_m_default(styles_css_default2[`media-${mediaPosition === "side" ? "side" : "top"}`], styles_css_default2.media), style: mediaPosition === "top" ? { height: (media === null || media === void 0 ? void 0 : media.height) || "" } : { width: (media === null || media === void 0 ? void 0 : media.width) || "" } }, media.content),
    import_react6.default.createElement(
      "div",
      { id: contentId, ref: __subStepRef, className: clsx_m_default(styles_css_default2["content-wrapper"], fitHeight && styles_css_default2["content-wrapper-fit-height"]) },
      header && import_react6.default.createElement(
        ContainerHeaderContextProvider,
        null,
        import_react6.default.createElement(
          StickyHeaderContext.Provider,
          { value: { isStuck, isStuckAtBottom } },
          import_react6.default.createElement(
            "div",
            Object.assign({ className: clsx_m_default(isRefresh && styles_css_default2.refresh, styles_css_default2.header, styles_css_default.header, styles_css_default2[`header-variant-${variant}`], {
              [styles_css_default2["header-sticky-disabled"]]: __stickyHeader && !isSticky,
              [styles_css_default2["header-sticky-enabled"]]: isSticky,
              [styles_css_default2["header-dynamic-height"]]: hasDynamicHeight,
              [styles_css_default2["header-stuck"]]: isStuck,
              [styles_css_default2["with-paddings"]]: !disableHeaderPaddings,
              [styles_css_default2["with-hidden-content"]]: !children || __hiddenContent,
              [styles_css_default2["header-with-media"]]: hasMedia,
              [styles_css_default2["header-full-page"]]: __fullPage && isRefresh
            }) }, stickyStyles, { ref: headerMergedRef }),
            isStuck && !isMobile && isRefresh && __fullPage && import_react6.default.createElement("div", { className: styles_css_default2["header-cover"] }),
            header
          )
        )
      ),
      import_react6.default.createElement(
        "div",
        { className: clsx_m_default(styles_css_default2.content, fitHeight && styles_css_default2["content-fit-height"]) },
        import_react6.default.createElement("div", { className: clsx_m_default(styles_css_default2["content-inner"], styles_css_default3["content-inner"], {
          [styles_css_default2["with-paddings"]]: !disableContentPaddings,
          [styles_css_default2["with-header"]]: !!header
        }) }, children)
      ),
      footer && import_react6.default.createElement("div", { className: clsx_m_default(styles_css_default2.footer, {
        [styles_css_default2["with-divider"]]: !__disableFooterDivider,
        [styles_css_default2["with-paddings"]]: !disableFooterPaddings
      }) }, footer)
    )
  );
}

export {
  debounce,
  useDebounceCallback,
  isContainingBlock,
  getContainingBlock,
  findUpUntilMultiple,
  parseCssVariable,
  isHTMLElement,
  isSVGElement,
  nodeBelongs,
  FunnelNameSelectorContext,
  FunnelMetrics,
  PerformanceMetrics,
  ComponentMetrics,
  useFunnelSubStep,
  useFunnelStep,
  useFunnelStepRef,
  useFunnel,
  useFunnelNameSelector,
  AnalyticsFunnel,
  AnalyticsFunnelStep,
  AnalyticsFunnelSubStep,
  ModalContext,
  useModalContext,
  InternalContainerAsSubstep,
  InternalContainer
};
//# sourceMappingURL=chunk-LAHF66CW.js.map

import {
  CollectionLabelContext,
  InfoLinkLabelContext,
  TableComponentsContextProvider,
  styles_css_default as styles_css_default2
} from "./chunk-GNMCFPGN.js";
import {
  flattenChildren,
  internal_default as internal_default4
} from "./chunk-C6UAGF3J.js";
import {
  AnalyticsFunnelSubStep,
  InternalContainer,
  useDebounceCallback
} from "./chunk-HH4FMBVO.js";
import {
  StickyHeaderContext,
  getMatchingBreakpoint,
  global_vars_default,
  matchBreakpointMapping,
  useMobile
} from "./chunk-5NGOYNTL.js";
import {
  InternalSpinner,
  KeyCode,
  PopoverBody,
  PopoverContainer,
  SingleTabStopNavigationContext,
  SingleTabStopNavigationProvider,
  arrow_default,
  fireCancelableEvent,
  fireNonCancelableEvent,
  focus_lock_default,
  getAllFocusables,
  internal_default,
  internal_default2,
  internal_default3,
  styles_css_default2 as styles_css_default,
  useDOMAttribute,
  useEffectOnUpdate,
  useForwardFocus,
  useHiddenDescription,
  useInternalI18n,
  usePerformanceMarks,
  useSingleTabStopNavigation
} from "./chunk-E33JD64J.js";
import {
  ComponentMetrics,
  FunnelMetrics,
  PerformanceMetrics,
  getContainingBlock,
  isHTMLElement,
  isSVGElement,
  nodeBelongs,
  useFunnel,
  useFunnelStep,
  useFunnelSubStep
} from "./chunk-APGZYK4P.js";
import {
  DATA_ATTR_FIELD_ERROR,
  DATA_ATTR_FIELD_LABEL,
  copyAnalyticsMetadataAttribute,
  getAnalyticsLabelAttribute,
  getAnalyticsMetadataAttribute,
  getFieldSlotSeletor,
  getOverflowParents,
  getSubStepAllSelector,
  getTextFromSelector,
  scrollElementIntoView
} from "./chunk-7M2SJ7OD.js";
import {
  ALWAYS_VISUAL_REFRESH,
  Portal,
  ResizeObserver,
  __awaiter,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __rest,
  applyDisplayName,
  clsx_m_default,
  createSingletonHandler,
  findUpUntil,
  getAnalyticsMetadataProps,
  getBaseProps,
  getIsRtl,
  getLogicalBoundingClientRect,
  getLogicalPageX,
  getScrollInlineStart,
  isDevelopment2 as isDevelopment,
  useBaseComponent,
  useCurrentMode,
  useDensityMode,
  useMergeRefs,
  useRandomId,
  useResizeObserver,
  useStableCallback,
  useUniqueId,
  useVisualRefresh,
  warnOnce
} from "./chunk-3XWJ5A22.js";
import {
  require_react_dom
} from "./chunk-6W5FFVKH.js";
import {
  require_react
} from "./chunk-NKBGLYTV.js";
import {
  __toESM
} from "./chunk-PLDDJCW6.js";

// node_modules/@cloudscape-design/components/table/index.js
var import_react50 = __toESM(require_react());

// node_modules/@cloudscape-design/components/internal/context/collection-preferences-metadata-context.js
var import_react = __toESM(require_react());
var CollectionPreferencesMetadata = (0, import_react.createContext)({});

// node_modules/@cloudscape-design/components/table/header-cell/utils.js
var stateToIcon = {
  sortable: "caret-down",
  ascending: "caret-up-filled",
  descending: "caret-down-filled"
};
var getSortingStatus = (sortable, sorted, descending, disabled) => {
  if (sorted) {
    if (descending) {
      return "descending";
    }
    return "ascending";
  }
  if (sortable && !disabled) {
    return "sortable";
  }
  return void 0;
};
var getSortingIconName = (sortingState) => stateToIcon[sortingState];
var isSorted = (column, sortingColumn) => column === sortingColumn || column.sortingField !== void 0 && column.sortingField === sortingColumn.sortingField || column.sortingComparator !== void 0 && column.sortingComparator === sortingColumn.sortingComparator;
var getSortingColumnId = (columnDefinitions = [], sortingColumn) => {
  if (!sortingColumn) {
    return null;
  }
  for (let i = 0; i < columnDefinitions.length; i++) {
    if (isSorted(columnDefinitions[i], sortingColumn)) {
      return columnDefinitions[i].id || null;
    }
  }
  return null;
};

// node_modules/@cloudscape-design/components/table/internal.js
var import_react49 = __toESM(require_react());

// node_modules/@cloudscape-design/component-toolkit/container-queries/use-container-query.js
var import_react2 = __toESM(require_react());
function useContainerQuery(mapFn, deps = []) {
  const elementRef = (0, import_react2.useRef)(null);
  const [state, setState] = (0, import_react2.useState)(null);
  const getElement = (0, import_react2.useCallback)(() => elementRef.current, deps);
  useResizeObserver(getElement, (entry) => setState((prevState) => mapFn(entry, prevState)));
  return [state, elementRef];
}

// node_modules/@cloudscape-design/component-toolkit/use-controllable-state/use-controllable-state.js
var import_react3 = __toESM(require_react());

// node_modules/@cloudscape-design/components/internal/components/visual-context/index.js
var import_react4 = __toESM(require_react());
var contextMatch = /awsui-context-([\w-]+)/;
function useVisualContext(elementRef) {
  const [value, setValue] = (0, import_react4.useState)("");
  (0, import_react4.useLayoutEffect)(() => {
    var _a;
    if (elementRef.current) {
      const contextParent = findUpUntil(elementRef.current, (node) => !!node.className.match(contextMatch));
      setValue((_a = contextParent === null || contextParent === void 0 ? void 0 : contextParent.className.match(contextMatch)[1]) !== null && _a !== void 0 ? _a : "");
    }
  }, [elementRef]);
  return value;
}
function getVisualContextClassname(contextName) {
  return `awsui-context-${contextName}`;
}
function VisualContext({ contextName, className, children }) {
  return import_react4.default.createElement("div", { className: clsx_m_default(getVisualContextClassname(contextName), className) }, children);
}

// node_modules/@cloudscape-design/components/internal/context/link-default-variant-context.js
var import_react5 = __toESM(require_react());
var defaultValue = {
  defaultVariant: "secondary"
};
var LinkDefaultVariantContext = (0, import_react5.createContext)(defaultValue);

// node_modules/@cloudscape-design/components/internal/hooks/use-mouse-down-target.js
var import_react6 = __toESM(require_react());
var useEventListenersSingleton = createSingletonHandler((setTarget) => {
  function handleMouseDown(event) {
    setTarget(event.target);
  }
  function handleKeyDown() {
    setTarget(null);
  }
  const controller = new AbortController();
  window.addEventListener("mousedown", handleMouseDown, { signal: controller.signal });
  window.addEventListener("keydown", handleKeyDown, { signal: controller.signal });
  return () => {
    controller.abort();
  };
});
function useMouseDownTarget() {
  const mouseDownTargetRef = (0, import_react6.useRef)(null);
  useEventListenersSingleton((target) => {
    mouseDownTargetRef.current = target;
  });
  return () => mouseDownTargetRef.current;
}

// node_modules/@cloudscape-design/components/internal/hooks/use-previous/index.js
var import_react7 = __toESM(require_react());
var usePrevious = (value) => {
  const ref = (0, import_react7.useRef)();
  (0, import_react7.useEffect)(() => {
    ref.current = value;
  });
  return ref.current;
};

// node_modules/@cloudscape-design/components/internal/hooks/use-scroll-sync/index.js
var import_react8 = __toESM(require_react());
function useScrollSync(refs) {
  const activeElement = (0, import_react8.useRef)(null);
  return (event) => {
    const targetElement = event.currentTarget;
    if (targetElement && (activeElement.current === null || activeElement.current === targetElement)) {
      requestAnimationFrame(() => {
        activeElement.current = targetElement;
        refs.forEach((ref) => {
          const element = ref.current;
          if (element && element !== targetElement) {
            element.scrollLeft = targetElement.scrollLeft;
          }
        });
        requestAnimationFrame(() => {
          activeElement.current = null;
        });
      });
    }
  };
}

// node_modules/@cloudscape-design/components/internal/hooks/use-table-interaction-metrics/index.js
var import_react9 = __toESM(require_react());
var USER_ACTION_TIME_LIMIT = 1e3;
function useTableInteractionMetrics({ elementRef, items, itemCount, instanceIdentifier, getComponentIdentifier, getComponentConfiguration, loading = false, interactionMetadata }) {
  const taskInteractionId = useRandomId();
  const tableInteractionAttributes = useDOMAttribute(elementRef, "data-analytics-task-interaction-id", taskInteractionId);
  const { isInFunnel } = useFunnel();
  const lastUserAction = (0, import_react9.useRef)(null);
  const capturedUserAction = (0, import_react9.useRef)(null);
  const loadingStartTime = (0, import_react9.useRef)(null);
  const metadata = (0, import_react9.useRef)({ itemCount, getComponentIdentifier, getComponentConfiguration, interactionMetadata });
  metadata.current = { itemCount, getComponentIdentifier, getComponentConfiguration, interactionMetadata };
  (0, import_react9.useEffect)(() => {
    if (isInFunnel) {
      return;
    }
    ComponentMetrics.componentMounted({
      taskInteractionId,
      componentName: "table",
      componentConfiguration: metadata.current.getComponentConfiguration()
    });
  }, [taskInteractionId, isInFunnel]);
  (0, import_react9.useEffect)(() => {
    if (loading) {
      loadingStartTime.current = performance.now();
      if (lastUserAction.current && lastUserAction.current.time > performance.now() - USER_ACTION_TIME_LIMIT) {
        capturedUserAction.current = lastUserAction.current.name;
      } else {
        capturedUserAction.current = null;
      }
    }
  }, [loading]);
  useEffectOnUpdate(() => {
    var _a;
    if (!loading && loadingStartTime.current !== null) {
      const loadingDuration = performance.now() - loadingStartTime.current;
      loadingStartTime.current = null;
      PerformanceMetrics.tableInteraction({
        userAction: (_a = capturedUserAction.current) !== null && _a !== void 0 ? _a : "",
        interactionTime: Math.round(loadingDuration),
        interactionMetadata: metadata.current.interactionMetadata(),
        componentIdentifier: metadata.current.getComponentIdentifier(),
        instanceIdentifier,
        noOfResourcesInTable: metadata.current.itemCount
      });
    }
  }, [instanceIdentifier, loading, taskInteractionId, isInFunnel]);
  const debouncedUpdated = useDebounceCallback(() => {
    var _a, _b;
    ComponentMetrics.componentUpdated({
      taskInteractionId,
      componentName: "table",
      actionType: (_b = (_a = lastUserAction.current) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : "",
      componentConfiguration: metadata.current.getComponentConfiguration()
    });
  });
  useEffectOnUpdate(() => {
    if (isInFunnel || loading) {
      return;
    }
    debouncedUpdated();
  }, [taskInteractionId, isInFunnel, loading, items, debouncedUpdated]);
  return {
    tableInteractionAttributes,
    setLastUserAction: (name) => void (lastUserAction.current = { name, time: performance.now() })
  };
}

// node_modules/@cloudscape-design/components/table/body-cell/index.js
var import_react22 = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/body-cell/disabled-inline-editor.js
var import_react17 = __toESM(require_react());

// node_modules/@cloudscape-design/components/internal/hooks/use-portal-mode-classes/index.js
function usePortalModeClasses(ref) {
  const colorMode = useCurrentMode(ref);
  const densityMode = useDensityMode(ref);
  const context = useVisualContext(ref);
  const visualRefreshWithClass = useVisualRefresh() && !ALWAYS_VISUAL_REFRESH;
  return clsx_m_default({
    "awsui-polaris-dark-mode awsui-dark-mode": colorMode === "dark",
    "awsui-polaris-compact-mode awsui-compact-mode": densityMode === "compact",
    "awsui-visual-refresh": visualRefreshWithClass,
    [`awsui-context-${context}`]: context
  });
}

// node_modules/@cloudscape-design/components/table/body-cell/click-away.js
var import_react10 = __toESM(require_react());
function useClickAway(onClick) {
  const awayRef = (0, import_react10.useRef)(null);
  const onClickStable = useStableCallback(onClick);
  (0, import_react10.useEffect)(() => {
    function handleClick(event) {
      if (!nodeBelongs(awayRef.current, event.target)) {
        onClickStable();
      }
    }
    document.addEventListener("click", handleClick, { capture: true });
    return () => document.removeEventListener("click", handleClick, { capture: true });
  }, [onClickStable]);
  return awayRef;
}

// node_modules/@cloudscape-design/components/table/body-cell/td-element.js
var import_react16 = __toESM(require_react());

// node_modules/@cloudscape-design/components/internal/components/expand-toggle-button/index.js
var import_react11 = __toESM(require_react());

// node_modules/@cloudscape-design/components/internal/components/expand-toggle-button/styles.css.js
import "/Users/shikaradee/raghu/GenAi/MachineLearning/reactapp/plat/frontend/node_modules/@cloudscape-design/components/internal/components/expand-toggle-button/styles.scoped.css";
var styles_css_default3 = {
  "expand-toggle-icon": "awsui_expand-toggle-icon_1xe88_13yei_153",
  "expand-toggle-icon-expanded": "awsui_expand-toggle-icon-expanded_1xe88_13yei_174",
  "expand-toggle": "awsui_expand-toggle_1xe88_13yei_153"
};

// node_modules/@cloudscape-design/components/internal/components/expand-toggle-button/index.js
function ExpandToggleButton({ isExpanded, onExpandableItemToggle, expandButtonLabel, collapseButtonLabel, customIcon }) {
  const buttonRef = (0, import_react11.useRef)(null);
  const { tabIndex } = useSingleTabStopNavigation(buttonRef);
  return import_react11.default.createElement("button", { type: "button", ref: buttonRef, tabIndex, "aria-label": isExpanded ? collapseButtonLabel : expandButtonLabel, "aria-expanded": isExpanded, className: styles_css_default3["expand-toggle"], onClick: onExpandableItemToggle }, customIcon !== null && customIcon !== void 0 ? customIcon : import_react11.default.createElement(internal_default, { size: "small", name: "caret-down-filled", className: clsx_m_default(styles_css_default3["expand-toggle-icon"], isExpanded && styles_css_default3["expand-toggle-icon-expanded"]) }));
}

// node_modules/@cloudscape-design/components/table/sticky-columns/use-sticky-columns.js
var import_react13 = __toESM(require_react());

// node_modules/@cloudscape-design/components/area-chart/async-store/index.js
var import_react12 = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());
var AsyncStore = class {
  constructor(state) {
    this._listeners = [];
    this._state = state;
  }
  get() {
    return this._state;
  }
  set(cb) {
    const prevState = this._state;
    const newState = cb(prevState);
    this._state = newState;
    (0, import_react_dom.unstable_batchedUpdates)(() => {
      for (const [selector, listener] of this._listeners) {
        if (selector(prevState) !== selector(newState)) {
          listener(newState, prevState);
        }
      }
    });
  }
  subscribe(selector, listener) {
    this._listeners.push([selector, listener]);
    return () => this.unsubscribe(listener);
  }
  unsubscribe(listener) {
    for (let index = 0; index < this._listeners.length; index++) {
      const [, storedListener] = this._listeners[index];
      if (storedListener === listener) {
        this._listeners.splice(index, 1);
        break;
      }
    }
  }
};
function useReaction(store, selector, effect) {
  (0, import_react12.useLayoutEffect)(
    () => {
      const unsubscribe = store.subscribe(selector, (newState, prevState) => effect(selector(newState), selector(prevState)));
      return unsubscribe;
    },
    // ignoring selector and effect as they are expected to stay constant
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [store]
  );
}
function useSelector(store, selector) {
  const [state, setState] = (0, import_react12.useState)(selector(store.get()));
  useReaction(store, selector, (newState) => {
    setState(newState);
  });
  const prevStore = usePrevious(store);
  if (prevStore !== null && prevStore !== store) {
    return selector(store.get());
  }
  return state;
}

// node_modules/@cloudscape-design/components/table/sticky-columns/utils.js
function isCellStatesEqual(s1, s2) {
  if (s1 && s2) {
    return s1.padInlineStart === s2.padInlineStart && s1.lastInsetInlineStart === s2.lastInsetInlineStart && s1.lastInsetInlineEnd === s2.lastInsetInlineEnd && s1.offset.insetInlineStart === s2.offset.insetInlineStart && s1.offset.insetInlineEnd === s2.offset.insetInlineEnd;
  }
  return s1 === s2;
}
function isWrapperStatesEqual(s1, s2) {
  return s1.scrollPaddingInlineStart === s2.scrollPaddingInlineStart && s1.scrollPaddingInlineEnd === s2.scrollPaddingInlineEnd;
}
function updateCellOffsets(cells, props) {
  var _a, _b, _c, _d;
  const totalColumns = props.visibleColumns.length;
  const firstColumnsWidths = [];
  for (let i = 0; i < Math.min(totalColumns, props.stickyColumnsFirst); i++) {
    const element = cells.get(props.visibleColumns[i]);
    const cellWidth = element ? getLogicalBoundingClientRect(element).inlineSize : 0;
    firstColumnsWidths[i] = ((_a = firstColumnsWidths[i - 1]) !== null && _a !== void 0 ? _a : 0) + cellWidth;
  }
  const lastColumnsWidths = [];
  for (let i = 0; i < Math.min(totalColumns, props.stickyColumnsLast); i++) {
    const element = cells.get(props.visibleColumns[totalColumns - 1 - i]);
    const cellWidth = element ? getLogicalBoundingClientRect(element).inlineSize : 0;
    lastColumnsWidths[i] = ((_b = lastColumnsWidths[i - 1]) !== null && _b !== void 0 ? _b : 0) + cellWidth;
  }
  const stickyWidthInlineStart = (_c = firstColumnsWidths[props.stickyColumnsFirst - 1]) !== null && _c !== void 0 ? _c : 0;
  const stickyWidthInlineEnd = (_d = lastColumnsWidths[props.stickyColumnsLast - 1]) !== null && _d !== void 0 ? _d : 0;
  const offsets = props.visibleColumns.reduce((map, columnId, columnIndex) => {
    var _a2, _b2;
    return map.set(columnId, {
      first: (_a2 = firstColumnsWidths[columnIndex - 1]) !== null && _a2 !== void 0 ? _a2 : 0,
      last: (_b2 = lastColumnsWidths[totalColumns - 1 - columnIndex - 1]) !== null && _b2 !== void 0 ? _b2 : 0
    });
  }, /* @__PURE__ */ new Map());
  return { offsets, stickyWidthInlineStart, stickyWidthInlineEnd };
}

// node_modules/@cloudscape-design/components/table/sticky-columns/use-sticky-columns.js
var MINIMUM_SCROLLABLE_SPACE = 148;
function useStickyColumns({ visibleColumns, stickyColumnsFirst, stickyColumnsLast }) {
  const store = (0, import_react13.useMemo)(() => new StickyColumnsStore(), []);
  const wrapperRef = (0, import_react13.useRef)(null);
  const tableRef = (0, import_react13.useRef)(null);
  const cellsRef = (0, import_react13.useRef)(/* @__PURE__ */ new Map());
  const hasStickyColumns = stickyColumnsFirst + stickyColumnsLast > 0;
  const updateStickyStyles = useStableCallback(() => {
    if (wrapperRef.current && tableRef.current) {
      store.updateCellStyles({
        wrapper: wrapperRef.current,
        table: tableRef.current,
        cells: cellsRef.current,
        visibleColumns,
        stickyColumnsFirst,
        stickyColumnsLast
      });
    }
  });
  useResizeObserver(wrapperRef, updateStickyStyles);
  useResizeObserver(tableRef, updateStickyStyles);
  (0, import_react13.useEffect)(() => {
    if (wrapperRef.current && tableRef.current) {
      store.updateCellStyles({
        wrapper: wrapperRef.current,
        table: tableRef.current,
        cells: cellsRef.current,
        visibleColumns,
        stickyColumnsFirst,
        stickyColumnsLast
      });
    }
  }, [store, stickyColumnsFirst, stickyColumnsLast, visibleColumns]);
  (0, import_react13.useEffect)(() => {
    if (!hasStickyColumns) {
      return;
    }
    const selector = (state) => state.wrapperState;
    const updateWrapperStyles = (state, prev) => {
      if (isWrapperStatesEqual(state, prev)) {
        return;
      }
      if (wrapperRef.current) {
        wrapperRef.current.style.scrollPaddingInlineStart = state.scrollPaddingInlineStart + "px";
        wrapperRef.current.style.scrollPaddingInlineEnd = state.scrollPaddingInlineEnd + "px";
      }
    };
    const unsubscribe = store.subscribe(selector, (newState, prevState) => updateWrapperStyles(selector(newState), selector(prevState)));
    return unsubscribe;
  }, [store, hasStickyColumns]);
  const setWrapper = (0, import_react13.useCallback)((node) => {
    if (wrapperRef.current) {
      wrapperRef.current.removeEventListener("scroll", updateStickyStyles);
    }
    if (node && hasStickyColumns) {
      node.addEventListener("scroll", updateStickyStyles);
    }
    wrapperRef.current = node;
  }, [hasStickyColumns, updateStickyStyles]);
  const setTable = (0, import_react13.useCallback)((node) => {
    tableRef.current = node;
  }, []);
  const setCell = (0, import_react13.useCallback)((columnId, node) => {
    if (node) {
      cellsRef.current.set(columnId, node);
    } else {
      cellsRef.current.delete(columnId);
    }
  }, []);
  return {
    store,
    style: {
      // Provide wrapper styles as props so that a re-render won't cause invalidation.
      wrapper: hasStickyColumns ? Object.assign({}, store.get().wrapperState) : void 0
    },
    refs: { wrapper: setWrapper, table: setTable, cell: setCell }
  };
}
function useStickyCellStyles({ stickyColumns, columnId, getClassName }) {
  var _a;
  const setCell = stickyColumns.refs.cell;
  const unsubscribeRef = (0, import_react13.useRef)(null);
  const refCallback = (0, import_react13.useCallback)(
    (cellElement) => {
      if (unsubscribeRef.current) {
        unsubscribeRef.current();
      }
      setCell(columnId, cellElement);
      const selector = (state) => {
        var _a2;
        return (_a2 = state.cellState.get(columnId)) !== null && _a2 !== void 0 ? _a2 : null;
      };
      const updateCellStyles = (state, prev) => {
        if (isCellStatesEqual(state, prev)) {
          return;
        }
        const className = getClassName(state);
        if (cellElement) {
          Object.keys(className).forEach((key) => {
            if (className[key]) {
              cellElement.classList.add(key);
            } else {
              cellElement.classList.remove(key);
            }
          });
          cellElement.style.insetInlineStart = (state === null || state === void 0 ? void 0 : state.offset.insetInlineStart) !== void 0 ? `${state.offset.insetInlineStart}px` : "";
          cellElement.style.insetInlineEnd = (state === null || state === void 0 ? void 0 : state.offset.insetInlineEnd) !== void 0 ? `${state.offset.insetInlineEnd}px` : "";
        }
      };
      if (cellElement) {
        unsubscribeRef.current = stickyColumns.store.subscribe(selector, (newState, prevState) => {
          updateCellStyles(selector(newState), selector(prevState));
        });
      }
    },
    // getClassName is expected to be pure
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [columnId, setCell, stickyColumns.store]
  );
  const cellStyles = stickyColumns.store.get().cellState.get(columnId);
  return {
    ref: refCallback,
    className: cellStyles ? clsx_m_default(getClassName(cellStyles)) : void 0,
    style: (_a = cellStyles === null || cellStyles === void 0 ? void 0 : cellStyles.offset) !== null && _a !== void 0 ? _a : void 0
  };
}
var StickyColumnsStore = class extends AsyncStore {
  constructor() {
    super({ cellState: /* @__PURE__ */ new Map(), wrapperState: { scrollPaddingInlineStart: 0, scrollPaddingInlineEnd: 0 } });
    this.cellOffsets = {
      offsets: /* @__PURE__ */ new Map(),
      stickyWidthInlineStart: 0,
      stickyWidthInlineEnd: 0
    };
    this.isStuckToTheInlineStart = false;
    this.isStuckToTheInlineEnd = false;
    this.padInlineStart = false;
    this.generateCellStyles = (props) => {
      const isEnabled = this.isEnabled(props);
      const lastLeftStickyColumnIndex = props.stickyColumnsFirst - 1;
      const lastRightStickyColumnIndex = props.visibleColumns.length - props.stickyColumnsLast;
      return props.visibleColumns.reduce((acc, columnId, index) => {
        var _a, _b, _c, _d;
        let stickySide = "non-sticky";
        if (index < props.stickyColumnsFirst) {
          stickySide = "inline-start";
        } else if (index >= props.visibleColumns.length - props.stickyColumnsLast) {
          stickySide = "inline-end";
        }
        if (!isEnabled || stickySide === "non-sticky") {
          return acc;
        }
        const isFirstColumn = index === 0;
        const stickyColumnOffsetLeft = (_b = (_a = this.cellOffsets.offsets.get(columnId)) === null || _a === void 0 ? void 0 : _a.first) !== null && _b !== void 0 ? _b : 0;
        const stickyColumnOffsetRight = (_d = (_c = this.cellOffsets.offsets.get(columnId)) === null || _c === void 0 ? void 0 : _c.last) !== null && _d !== void 0 ? _d : 0;
        acc.set(columnId, {
          padInlineStart: isFirstColumn && this.padInlineStart,
          lastInsetInlineStart: this.isStuckToTheInlineStart && lastLeftStickyColumnIndex === index,
          lastInsetInlineEnd: this.isStuckToTheInlineEnd && lastRightStickyColumnIndex === index,
          offset: {
            insetInlineStart: stickySide === "inline-start" ? stickyColumnOffsetLeft : void 0,
            insetInlineEnd: stickySide === "inline-end" ? stickyColumnOffsetRight : void 0
          }
        });
        return acc;
      }, /* @__PURE__ */ new Map());
    };
    this.updateCellOffsets = (props) => {
      this.cellOffsets = updateCellOffsets(props.cells, props);
    };
    this.isEnabled = (props) => {
      const noStickyColumns = props.stickyColumnsFirst + props.stickyColumnsLast === 0;
      if (noStickyColumns) {
        return false;
      }
      const wrapperWidth = getLogicalBoundingClientRect(props.wrapper).inlineSize;
      const tableWidth = getLogicalBoundingClientRect(props.table).inlineSize;
      const isWrapperScrollable = tableWidth > wrapperWidth;
      if (!isWrapperScrollable) {
        return false;
      }
      const totalStickySpace = this.cellOffsets.stickyWidthInlineStart + this.cellOffsets.stickyWidthInlineEnd;
      const tablePaddingLeft = parseFloat(getComputedStyle(props.table).paddingLeft) || 0;
      const tablePaddingRight = parseFloat(getComputedStyle(props.table).paddingRight) || 0;
      const hasEnoughScrollableSpace = totalStickySpace + MINIMUM_SCROLLABLE_SPACE + tablePaddingLeft + tablePaddingRight < wrapperWidth;
      if (!hasEnoughScrollableSpace) {
        return false;
      }
      return true;
    };
  }
  updateCellStyles(props) {
    const hasStickyColumns = props.stickyColumnsFirst + props.stickyColumnsLast > 0;
    const hadStickyColumns = this.cellOffsets.offsets.size > 0;
    if (hasStickyColumns || hadStickyColumns) {
      this.updateScroll(props);
      this.updateCellOffsets(props);
      this.set(() => ({
        cellState: this.generateCellStyles(props),
        wrapperState: {
          scrollPaddingInlineStart: this.cellOffsets.stickyWidthInlineStart,
          scrollPaddingInlineEnd: this.cellOffsets.stickyWidthInlineEnd
        }
      }));
    }
  }
  updateScroll(props) {
    const wrapperScrollInlineStart = getScrollInlineStart(props.wrapper);
    const wrapperScrollWidth = props.wrapper.scrollWidth;
    const wrapperClientWidth = props.wrapper.clientWidth;
    const tablePaddingInlineStart = parseFloat(getComputedStyle(props.table).paddingInlineStart) || 0;
    const tablePaddingInlineEnd = parseFloat(getComputedStyle(props.table).paddingInlineEnd) || 0;
    this.isStuckToTheInlineStart = wrapperScrollInlineStart > tablePaddingInlineStart;
    this.isStuckToTheInlineEnd = Math.ceil(wrapperScrollInlineStart) < wrapperScrollWidth - wrapperClientWidth - tablePaddingInlineEnd;
    this.padInlineStart = tablePaddingInlineStart !== 0 && this.isStuckToTheInlineStart;
  }
};

// node_modules/@cloudscape-design/components/table/table-role/table-role-helper.js
var stateToAriaSort = {
  sortable: "none",
  ascending: "ascending",
  descending: "descending"
};
var getAriaSort = (sortingState) => stateToAriaSort[sortingState];
function getTableRoleProps(options) {
  const nativeProps = {};
  nativeProps.role = options.tableRole === "grid-default" ? "grid" : options.tableRole;
  nativeProps["aria-label"] = options.ariaLabel;
  nativeProps["aria-labelledby"] = options.ariaLabelledby;
  nativeProps["aria-rowcount"] = typeof options.totalItemsCount === "number" ? options.totalItemsCount + 1 : -1;
  if (options.tableRole === "grid" || options.tableRole === "treegrid") {
    nativeProps["aria-colcount"] = options.totalColumnsCount;
  }
  if (options.tableRole === "grid" || options.tableRole === "treegrid") {
    nativeProps.tabIndex = -1;
  }
  return nativeProps;
}
function getTableWrapperRoleProps(options) {
  const nativeProps = {};
  if (options.isScrollable) {
    nativeProps.role = "region";
    nativeProps.tabIndex = 0;
    nativeProps["aria-label"] = options.ariaLabel;
    nativeProps["aria-labelledby"] = options.ariaLabelledby;
  }
  return nativeProps;
}
function getTableHeaderRowRoleProps(options) {
  const nativeProps = {};
  if (options.tableRole === "grid" || options.tableRole === "grid-default" || options.tableRole === "treegrid") {
    nativeProps["aria-rowindex"] = 1;
  }
  return nativeProps;
}
function getTableRowRoleProps(options) {
  const nativeProps = {};
  if (options.tableRole === "grid" || options.tableRole === "treegrid") {
    nativeProps["aria-rowindex"] = (options.firstIndex || 1) + options.rowIndex + 1;
  } else if (options.firstIndex !== void 0) {
    nativeProps["aria-rowindex"] = options.firstIndex + options.rowIndex + 1;
  }
  if (options.tableRole === "treegrid" && options.level && options.level !== 0) {
    nativeProps["aria-level"] = options.level;
  }
  if (options.tableRole === "treegrid" && options.setSize) {
    nativeProps["aria-setsize"] = options.setSize;
  }
  if (options.tableRole === "treegrid" && options.posInSet) {
    nativeProps["aria-posinset"] = options.posInSet;
  }
  return nativeProps;
}
function getTableColHeaderRoleProps(options) {
  const nativeProps = {};
  nativeProps.scope = "col";
  if (options.tableRole === "grid" || options.tableRole === "treegrid") {
    nativeProps["aria-colindex"] = options.colIndex + 1;
  }
  if (options.sortingStatus) {
    nativeProps["aria-sort"] = getAriaSort(options.sortingStatus);
  }
  return nativeProps;
}
function getTableCellRoleProps(options) {
  const nativeProps = {};
  if (options.tableRole === "grid" || options.tableRole === "treegrid") {
    nativeProps["aria-colindex"] = options.colIndex + 1;
  }
  if (options.isRowHeader) {
    nativeProps.scope = "row";
  }
  return nativeProps;
}

// node_modules/@cloudscape-design/components/table/table-role/grid-navigation.js
var import_react14 = __toESM(require_react());
var import_react15 = __toESM(require_react());

// node_modules/@cloudscape-design/components/internal/utils/handle-key.js
function isEventLike(event) {
  return isHTMLElement(event.currentTarget) || isSVGElement(event.currentTarget);
}
function handleKey(event, { onActivate, onBlockEnd, onBlockStart, onDefault, onEnd, onEscape, onHome, onInlineEnd, onInlineStart, onPageDown, onPageUp }) {
  switch (event.keyCode) {
    case KeyCode.down:
      onBlockEnd === null || onBlockEnd === void 0 ? void 0 : onBlockEnd();
      break;
    case KeyCode.end:
      onEnd === null || onEnd === void 0 ? void 0 : onEnd();
      break;
    case KeyCode.enter:
    case KeyCode.space:
      onActivate === null || onActivate === void 0 ? void 0 : onActivate();
      break;
    case KeyCode.escape:
      onEscape === null || onEscape === void 0 ? void 0 : onEscape();
      break;
    case KeyCode.home:
      onHome === null || onHome === void 0 ? void 0 : onHome();
      break;
    case KeyCode.left:
      getIsRtl(event.currentTarget) ? onInlineEnd === null || onInlineEnd === void 0 ? void 0 : onInlineEnd() : onInlineStart === null || onInlineStart === void 0 ? void 0 : onInlineStart();
      break;
    case KeyCode.pageDown:
      onPageDown === null || onPageDown === void 0 ? void 0 : onPageDown();
      break;
    case KeyCode.pageUp:
      onPageUp === null || onPageUp === void 0 ? void 0 : onPageUp();
      break;
    case KeyCode.right:
      getIsRtl(event.currentTarget) ? onInlineStart === null || onInlineStart === void 0 ? void 0 : onInlineStart() : onInlineEnd === null || onInlineEnd === void 0 ? void 0 : onInlineEnd();
      break;
    case KeyCode.up:
      onBlockStart === null || onBlockStart === void 0 ? void 0 : onBlockStart();
      break;
    default:
      onDefault === null || onDefault === void 0 ? void 0 : onDefault();
      break;
  }
}

// node_modules/@cloudscape-design/components/table/table-role/utils.js
function getClosestCell(element) {
  return element.closest("td,th");
}
function isElementDisabled(element) {
  if (element instanceof HTMLInputElement || element instanceof HTMLButtonElement) {
    return element.disabled;
  }
  return false;
}
function defaultIsSuppressed(target) {
  let current = target;
  while (current) {
    if (isTableCell(current)) {
      return false;
    }
    if (current.getAttribute("role") === "dialog" || current.getAttribute("data-awsui-table-suppress-navigation") === "true") {
      return true;
    }
    current = current.parentElement;
  }
  return false;
}
function findTableRowByAriaRowIndex(table, targetAriaRowIndex, delta) {
  var _a;
  let targetRow = null;
  const rowElements = Array.from(table.querySelectorAll("tr[aria-rowindex]"));
  if (delta < 0) {
    rowElements.reverse();
  }
  for (const element of rowElements) {
    const rowIndex = parseInt((_a = element.getAttribute("aria-rowindex")) !== null && _a !== void 0 ? _a : "");
    targetRow = element;
    if (rowIndex === targetAriaRowIndex) {
      break;
    }
    if (delta >= 0 && rowIndex > targetAriaRowIndex) {
      break;
    }
    if (delta < 0 && rowIndex < targetAriaRowIndex) {
      break;
    }
  }
  return targetRow;
}
function findTableRowCellByAriaColIndex(tableRow, targetAriaColIndex, delta) {
  var _a;
  let targetCell = null;
  const cellElements = Array.from(tableRow.querySelectorAll("td[aria-colindex],th[aria-colindex]"));
  if (delta < 0) {
    cellElements.reverse();
  }
  for (const element of cellElements) {
    const columnIndex = parseInt((_a = element.getAttribute("aria-colindex")) !== null && _a !== void 0 ? _a : "");
    targetCell = element;
    if (columnIndex === targetAriaColIndex) {
      break;
    }
    if (delta >= 0 && columnIndex > targetAriaColIndex) {
      break;
    }
    if (delta < 0 && columnIndex < targetAriaColIndex) {
      break;
    }
  }
  return targetCell;
}
function isTableCell(element) {
  return element.tagName === "TD" || element.tagName === "TH";
}
function focusNextElement(element) {
  if (element) {
    if (isTableCell(element) && element.tabIndex !== 0) {
      element.tabIndex = -1;
    }
    element.focus();
  }
}

// node_modules/@cloudscape-design/components/table/table-role/grid-navigation.js
function GridNavigationProvider({ keyboardNavigation, pageSize, getTable, children }) {
  const navigationAPI = (0, import_react14.useRef)(null);
  const gridNavigation = (0, import_react15.useMemo)(() => new GridNavigationProcessor(navigationAPI), []);
  const getTableStable = useStableCallback(getTable);
  (0, import_react15.useEffect)(() => {
    if (keyboardNavigation) {
      const table = getTableStable();
      if (table) {
        gridNavigation.init(table);
      }
    }
    return () => gridNavigation.cleanup();
  }, [keyboardNavigation, gridNavigation, getTableStable]);
  (0, import_react15.useEffect)(() => {
    gridNavigation.update({ pageSize });
  }, [gridNavigation, pageSize]);
  (0, import_react15.useEffect)(() => {
    if (keyboardNavigation) {
      gridNavigation.refresh();
    }
  });
  return import_react14.default.createElement(SingleTabStopNavigationProvider, { ref: navigationAPI, navigationActive: keyboardNavigation, getNextFocusTarget: gridNavigation.getNextFocusTarget, isElementSuppressed: gridNavigation.isElementSuppressed, onRegisterFocusable: gridNavigation.onRegisterFocusable, onUnregisterActive: gridNavigation.onUnregisterActive }, children);
}
var GridNavigationProcessor = class {
  constructor(navigationAPI) {
    this._pageSize = 0;
    this._table = null;
    this.focusedCell = null;
    this.focusInside = false;
    this.keepUserIndex = false;
    this.onRegisterFocusable = (focusableElement) => {
      var _a;
      if (!this.focusInside) {
        return;
      }
      const focusedElement = (_a = this.focusedCell) === null || _a === void 0 ? void 0 : _a.element;
      if (focusedElement && isTableCell(focusedElement) && focusedElement.contains(focusableElement)) {
        focusableElement.focus({ preventScroll: true });
      }
    };
    this.onUnregisterActive = () => {
      if (this.focusedCell && !nodeBelongs(this.table, this.focusedCell.element)) {
        this.moveFocusBy(this.focusedCell, { x: 0, y: 0 });
      }
    };
    this.getNextFocusTarget = () => {
      var _a;
      const cell = this.focusedCell;
      const firstTableCell = this.table.querySelector("td,th");
      let focusTarget = (_a = firstTableCell && this.getFocusablesFrom(firstTableCell)[0]) !== null && _a !== void 0 ? _a : firstTableCell;
      if (cell) {
        focusTarget = this.getNextFocusable(cell, { x: 0, y: 0 });
      }
      return focusTarget;
    };
    this.isElementSuppressed = (element) => {
      if (!this.focusedCell) {
        return false;
      }
      return !element || defaultIsSuppressed(element);
    };
    this.onFocusin = (event) => {
      var _a;
      this.focusInside = true;
      if (!(event.target instanceof HTMLElement)) {
        return;
      }
      this.updateFocusedCell(event.target);
      if (!this.focusedCell) {
        return;
      }
      (_a = this._navigationAPI.current) === null || _a === void 0 ? void 0 : _a.updateFocusTarget();
      const focusedElement = this.focusedCell.element;
      const nextTarget = isTableCell(focusedElement) ? this.getFocusablesFrom(focusedElement)[0] : null;
      if (nextTarget) {
        nextTarget.focus({ preventScroll: true });
      } else {
        this.keepUserIndex = false;
      }
    };
    this.onFocusout = () => {
      this.focusInside = false;
    };
    this.onKeydown = (event) => {
      if (!this.focusedCell) {
        return;
      }
      const keys = [
        KeyCode.up,
        KeyCode.down,
        KeyCode.left,
        KeyCode.right,
        KeyCode.pageUp,
        KeyCode.pageDown,
        KeyCode.home,
        KeyCode.end
      ];
      const ctrlKey = event.ctrlKey ? 1 : 0;
      const altKey = event.altKey ? 1 : 0;
      const shiftKey = event.shiftKey ? 1 : 0;
      const metaKey = event.metaKey ? 1 : 0;
      const modifiersPressed = ctrlKey + altKey + shiftKey + metaKey;
      const invalidModifierCombination = modifiersPressed && !event.ctrlKey || event.ctrlKey && event.keyCode !== KeyCode.home && event.keyCode !== KeyCode.end;
      if (invalidModifierCombination || this.isElementSuppressed(document.activeElement) || !this.isRegistered(document.activeElement) || keys.indexOf(event.keyCode) === -1) {
        return;
      }
      const from = this.focusedCell;
      event.preventDefault();
      if (isEventLike(event)) {
        handleKey(event, {
          onBlockStart: () => this.moveFocusBy(from, { y: -1, x: 0 }),
          onBlockEnd: () => this.moveFocusBy(from, { y: 1, x: 0 }),
          onInlineStart: () => this.moveFocusBy(from, { y: 0, x: -1 }),
          onInlineEnd: () => this.moveFocusBy(from, { y: 0, x: 1 }),
          onPageUp: () => this.moveFocusBy(from, { y: -this.pageSize, x: 0 }),
          onPageDown: () => this.moveFocusBy(from, { y: this.pageSize, x: 0 }),
          onHome: () => event.ctrlKey ? this.moveFocusBy(from, { y: -Infinity, x: -Infinity }) : this.moveFocusBy(from, { y: 0, x: -Infinity }),
          onEnd: () => event.ctrlKey ? this.moveFocusBy(from, { y: Infinity, x: Infinity }) : this.moveFocusBy(from, { y: 0, x: Infinity })
        });
      }
    };
    this._navigationAPI = navigationAPI;
  }
  init(table) {
    this._table = table;
    const controller = new AbortController();
    this.table.addEventListener("focusin", this.onFocusin, { signal: controller.signal });
    this.table.addEventListener("focusout", this.onFocusout, { signal: controller.signal });
    this.table.addEventListener("keydown", this.onKeydown, { signal: controller.signal });
    this.cleanup = () => {
      controller.abort();
    };
  }
  cleanup() {
  }
  update({ pageSize }) {
    this._pageSize = pageSize;
  }
  refresh() {
    setTimeout(() => {
      var _a, _b;
      if (this._table) {
        this.updateFocusedCell((_a = this.focusedCell) === null || _a === void 0 ? void 0 : _a.element);
        (_b = this._navigationAPI.current) === null || _b === void 0 ? void 0 : _b.updateFocusTarget();
      }
    }, 0);
  }
  get pageSize() {
    return this._pageSize;
  }
  get table() {
    if (!this._table) {
      throw new Error("Invariant violation: GridNavigationProcessor is used before initialization.");
    }
    return this._table;
  }
  moveFocusBy(cell, delta) {
    if (delta.y !== 0 && delta.x === 0) {
      this.keepUserIndex = true;
    }
    focusNextElement(this.getNextFocusable(cell, delta));
  }
  isRegistered(element) {
    var _a, _b;
    return !element || ((_b = (_a = this._navigationAPI.current) === null || _a === void 0 ? void 0 : _a.isRegistered(element)) !== null && _b !== void 0 ? _b : false);
  }
  updateFocusedCell(focusedElement) {
    var _a, _b, _c, _d, _e, _f;
    if (!focusedElement) {
      return;
    }
    const cellElement = getClosestCell(focusedElement);
    const rowElement = cellElement === null || cellElement === void 0 ? void 0 : cellElement.closest("tr");
    if (!cellElement || !rowElement) {
      return;
    }
    const colIndex = parseInt((_a = cellElement.getAttribute("aria-colindex")) !== null && _a !== void 0 ? _a : "");
    const rowIndex = parseInt((_b = rowElement.getAttribute("aria-rowindex")) !== null && _b !== void 0 ? _b : "");
    if (isNaN(colIndex) || isNaN(rowIndex)) {
      return;
    }
    const cellFocusables = this.getFocusablesFrom(cellElement);
    const elementIndex = cellFocusables.indexOf(focusedElement);
    const prevColIndex = (_d = (_c = this.focusedCell) === null || _c === void 0 ? void 0 : _c.colIndex) !== null && _d !== void 0 ? _d : -1;
    const prevElementIndex = (_f = (_e = this.focusedCell) === null || _e === void 0 ? void 0 : _e.elementIndex) !== null && _f !== void 0 ? _f : -1;
    this.focusedCell = {
      rowIndex,
      colIndex: this.keepUserIndex && prevColIndex !== -1 ? prevColIndex : colIndex,
      elementIndex: this.keepUserIndex && prevElementIndex !== -1 ? prevElementIndex : elementIndex,
      element: focusedElement
    };
  }
  getNextFocusable(from, delta) {
    var _a;
    const targetAriaRowIndex = from.rowIndex + delta.y;
    const targetRow = findTableRowByAriaRowIndex(this.table, targetAriaRowIndex, delta.y);
    if (!targetRow) {
      return null;
    }
    const cellElement = getClosestCell(from.element);
    const cellFocusables = cellElement ? this.getFocusablesFrom(cellElement) : [];
    const nextElementIndex = from.elementIndex + delta.x;
    const isValidDirection = !!delta.x;
    const isValidIndex = from.elementIndex !== -1 && 0 <= nextElementIndex && nextElementIndex < cellFocusables.length;
    const isTargetDifferent = from.element !== cellFocusables[nextElementIndex];
    if (isValidDirection && isValidIndex && isTargetDifferent) {
      return cellFocusables[nextElementIndex];
    }
    const targetAriaColIndex = from.colIndex + delta.x;
    const targetCell = findTableRowCellByAriaColIndex(targetRow, targetAriaColIndex, delta.x);
    if (!targetCell) {
      return null;
    }
    if (targetCell === cellElement && delta.x !== 0) {
      return null;
    }
    const targetCellFocusables = this.getFocusablesFrom(targetCell);
    let focusIndex = from.elementIndex;
    if (isFinite(delta.x) && delta.x > 0 || delta.x === -Infinity) {
      focusIndex = 0;
    }
    if (isFinite(delta.x) && delta.x < 0 || delta.x === Infinity) {
      focusIndex = targetCellFocusables.length - 1;
    }
    return (_a = targetCellFocusables[focusIndex]) !== null && _a !== void 0 ? _a : targetCell;
  }
  getFocusablesFrom(target) {
    const isElementRegistered = (element) => {
      var _a;
      return (_a = this._navigationAPI.current) === null || _a === void 0 ? void 0 : _a.isRegistered(element);
    };
    return getAllFocusables(target).filter((el) => isElementRegistered(el) && !isElementDisabled(el));
  }
};

// node_modules/@cloudscape-design/components/table/utils.js
var applyTrackBy = (trackBy, item) => {
  if (typeof trackBy === "function") {
    return trackBy(item);
  }
  return item[trackBy];
};
var getItemKey = (trackBy, item, index) => {
  if (!trackBy) {
    return index;
  }
  return applyTrackBy(trackBy, item);
};
var getTrackableValue = (trackBy, item) => {
  if (!trackBy) {
    return item;
  }
  return applyTrackBy(trackBy, item);
};
var getColumnKey = (column, index) => {
  return column.id || index;
};
var toContainerVariant = (variant) => {
  const isDefaultVariant = !variant || variant === "container";
  return isDefaultVariant ? "default" : variant === "borderless" ? "embedded" : variant;
};
function checkSortingState(columnDefinitions, sortingComparator) {
  const matchedColumn = columnDefinitions.filter((column) => column.sortingComparator === sortingComparator)[0];
  if (!matchedColumn) {
    warnOnce("Table", "Currently active sorting comparator was not found in any columns. Make sure to provide the same comparator function instance on each render.");
  }
}
function getVisibleColumnDefinitions({ columnDisplay, visibleColumns, columnDefinitions }) {
  if (columnDisplay) {
    return getVisibleColumnDefinitionsFromColumnDisplay({ columnDisplay, columnDefinitions });
  } else if (visibleColumns) {
    return getVisibleColumnDefinitionsFromVisibleColumns({ visibleColumns, columnDefinitions });
  } else {
    return columnDefinitions;
  }
}
function getVisibleColumnDefinitionsFromColumnDisplay({ columnDisplay, columnDefinitions }) {
  const columnDefinitionsById = columnDefinitions.reduce((accumulator, item) => item.id === void 0 ? accumulator : Object.assign(Object.assign({}, accumulator), { [item.id]: item }), {});
  return columnDisplay.filter((item) => item.visible).map((item) => columnDefinitionsById[item.id]).filter(Boolean);
}
function getVisibleColumnDefinitionsFromVisibleColumns({ visibleColumns, columnDefinitions }) {
  const ids = new Set(visibleColumns);
  return columnDefinitions.filter(({ id }) => id !== void 0 && ids.has(id));
}
function getStickyClassNames(styles, props) {
  return {
    [styles["sticky-cell"]]: !!props,
    [styles["sticky-cell-pad-inline-start"]]: !!(props === null || props === void 0 ? void 0 : props.padInlineStart),
    [styles["sticky-cell-last-inline-start"]]: !!(props === null || props === void 0 ? void 0 : props.lastInsetInlineStart),
    [styles["sticky-cell-last-inline-end"]]: !!(props === null || props === void 0 ? void 0 : props.lastInsetInlineEnd)
  };
}

// node_modules/@cloudscape-design/components/table/styles.css.js
import "/Users/shikaradee/raghu/GenAi/MachineLearning/reactapp/plat/frontend/node_modules/@cloudscape-design/components/table/styles.scoped.css";
var styles_css_default4 = {
  "root": "awsui_root_wih1l_1dnvt_153",
  "tools": "awsui_tools_wih1l_1dnvt_164",
  "tools-filtering": "awsui_tools-filtering_wih1l_1dnvt_172",
  "tools-align-right": "awsui_tools-align-right_wih1l_1dnvt_186",
  "tools-pagination": "awsui_tools-pagination_wih1l_1dnvt_190",
  "tools-preferences": "awsui_tools-preferences_wih1l_1dnvt_190",
  "tools-small": "awsui_tools-small_wih1l_1dnvt_196",
  "table": "awsui_table_wih1l_1dnvt_202",
  "table-layout-fixed": "awsui_table-layout-fixed_wih1l_1dnvt_208",
  "wrapper": "awsui_wrapper_wih1l_1dnvt_212",
  "variant-stacked": "awsui_variant-stacked_wih1l_1dnvt_219",
  "wrapper-content-measure": "awsui_wrapper-content-measure_wih1l_1dnvt_219",
  "variant-container": "awsui_variant-container_wih1l_1dnvt_219",
  "has-footer": "awsui_has-footer_wih1l_1dnvt_222",
  "has-header": "awsui_has-header_wih1l_1dnvt_225",
  "cell-merged": "awsui_cell-merged_wih1l_1dnvt_242",
  "cell-merged-content": "awsui_cell-merged-content_wih1l_1dnvt_254",
  "empty": "awsui_empty_wih1l_1dnvt_270",
  "loading": "awsui_loading_wih1l_1dnvt_274",
  "selection-control": "awsui_selection-control_wih1l_1dnvt_283",
  "selection-control-header": "awsui_selection-control-header_wih1l_1dnvt_290",
  "header-secondary": "awsui_header-secondary_wih1l_1dnvt_296",
  "variant-full-page": "awsui_variant-full-page_wih1l_1dnvt_308",
  "table-has-header": "awsui_table-has-header_wih1l_1dnvt_314",
  "header-controls": "awsui_header-controls_wih1l_1dnvt_325",
  "variant-embedded": "awsui_variant-embedded_wih1l_1dnvt_334",
  "variant-borderless": "awsui_variant-borderless_wih1l_1dnvt_334",
  "footer-wrapper": "awsui_footer-wrapper_wih1l_1dnvt_339",
  "footer": "awsui_footer_wih1l_1dnvt_339",
  "footer-with-pagination": "awsui_footer-with-pagination_wih1l_1dnvt_347",
  "footer-pagination": "awsui_footer-pagination_wih1l_1dnvt_355",
  "thead-active": "awsui_thead-active_wih1l_1dnvt_359",
  "row": "awsui_row_wih1l_1dnvt_360",
  "row-selected": "awsui_row-selected_wih1l_1dnvt_361"
};

// node_modules/@cloudscape-design/components/table/body-cell/styles.css.js
import "/Users/shikaradee/raghu/GenAi/MachineLearning/reactapp/plat/frontend/node_modules/@cloudscape-design/components/table/body-cell/styles.scoped.css";
var styles_css_default5 = {
  "expandable-toggle-wrapper": "awsui_expandable-toggle-wrapper_c6tup_m7a2f_145",
  "body-cell": "awsui_body-cell_c6tup_m7a2f_152",
  "body-cell-content": "awsui_body-cell-content_c6tup_m7a2f_160",
  "expandable-level-0": "awsui_expandable-level-0_c6tup_m7a2f_166",
  "expandable-level-1": "awsui_expandable-level-1_c6tup_m7a2f_173",
  "expandable-level-2": "awsui_expandable-level-2_c6tup_m7a2f_180",
  "expandable-level-3": "awsui_expandable-level-3_c6tup_m7a2f_187",
  "expandable-level-4": "awsui_expandable-level-4_c6tup_m7a2f_194",
  "expandable-level-5": "awsui_expandable-level-5_c6tup_m7a2f_201",
  "expandable-level-6": "awsui_expandable-level-6_c6tup_m7a2f_208",
  "expandable-level-7": "awsui_expandable-level-7_c6tup_m7a2f_215",
  "expandable-level-8": "awsui_expandable-level-8_c6tup_m7a2f_222",
  "expandable-level-9": "awsui_expandable-level-9_c6tup_m7a2f_229",
  "expandable-level-next": "awsui_expandable-level-next_c6tup_m7a2f_236",
  "body-cell-align-top": "awsui_body-cell-align-top_c6tup_m7a2f_254",
  "body-cell-wrap": "awsui_body-cell-wrap_c6tup_m7a2f_260",
  "is-visual-refresh": "awsui_is-visual-refresh_c6tup_m7a2f_357",
  "body-cell-edit-active": "awsui_body-cell-edit-active_c6tup_m7a2f_447",
  "body-cell-expandable": "awsui_body-cell-expandable_c6tup_m7a2f_447",
  "body-cell-editable": "awsui_body-cell-editable_c6tup_m7a2f_447",
  "has-striped-rows": "awsui_has-striped-rows_c6tup_m7a2f_530",
  "sticky-cell-pad-inline-start": "awsui_sticky-cell-pad-inline-start_c6tup_m7a2f_696",
  "has-selection": "awsui_has-selection_c6tup_m7a2f_862",
  "body-cell-first-row": "awsui_body-cell-first-row_c6tup_m7a2f_1031",
  "body-cell-last-row": "awsui_body-cell-last-row_c6tup_m7a2f_1034",
  "body-cell-selected": "awsui_body-cell-selected_c6tup_m7a2f_1034",
  "has-footer": "awsui_has-footer_c6tup_m7a2f_1034",
  "body-cell-shaded": "awsui_body-cell-shaded_c6tup_m7a2f_1044",
  "sticky-cell": "awsui_sticky-cell_c6tup_m7a2f_696",
  "table-variant-full-page": "awsui_table-variant-full-page_c6tup_m7a2f_1095",
  "sticky-cell-last-inline-end": "awsui_sticky-cell-last-inline-end_c6tup_m7a2f_1112",
  "sticky-cell-last-inline-start": "awsui_sticky-cell-last-inline-start_c6tup_m7a2f_1121",
  "body-cell-next-selected": "awsui_body-cell-next-selected_c6tup_m7a2f_1143",
  "body-cell-prev-selected": "awsui_body-cell-prev-selected_c6tup_m7a2f_1150",
  "body-cell-editor-wrapper": "awsui_body-cell-editor-wrapper_c6tup_m7a2f_1176",
  "body-cell-success": "awsui_body-cell-success_c6tup_m7a2f_1181",
  "body-cell-editor": "awsui_body-cell-editor_c6tup_m7a2f_1176",
  "body-cell-editor-disabled": "awsui_body-cell-editor-disabled_c6tup_m7a2f_1206",
  "body-cell-editor-row": "awsui_body-cell-editor-row_c6tup_m7a2f_1215",
  "body-cell-editor-controls": "awsui_body-cell-editor-controls_c6tup_m7a2f_1225",
  "body-cell-editor-row-editor": "awsui_body-cell-editor-row-editor_c6tup_m7a2f_1228",
  "body-cell-editor-focusable": "awsui_body-cell-editor-focusable_c6tup_m7a2f_1231",
  "body-cell-editor-icon": "awsui_body-cell-editor-icon_c6tup_m7a2f_1255",
  "resizable-columns": "awsui_resizable-columns_c6tup_m7a2f_1367",
  "expandable-cell-content": "awsui_expandable-cell-content_c6tup_m7a2f_1370",
  "body-cell-edit-disabled-popover": "awsui_body-cell-edit-disabled-popover_c6tup_m7a2f_1421",
  "body-cell-has-success": "awsui_body-cell-has-success_c6tup_m7a2f_1424"
};

// node_modules/@cloudscape-design/components/table/body-cell/td-element.js
var TableTdElement = import_react16.default.forwardRef((_a, ref) => {
  var { children, wrapLines, isRowHeader, isFirstRow, isLastRow, isSelected, isNextSelected, isPrevSelected, nativeAttributes, onClick, onFocus, onBlur, isEvenRow, stripedRows, isSelection, hasSelection, hasFooter, columnId, colIndex, stickyState, tableRole, level, isExpandable, isExpanded, onExpandableItemToggle, expandButtonLabel, collapseButtonLabel, verticalAlign, resizableColumns, resizableStyle, isEditable, isEditing, isEditingDisabled, hasSuccessIcon, tableVariant } = _a, rest = __rest(_a, ["children", "wrapLines", "isRowHeader", "isFirstRow", "isLastRow", "isSelected", "isNextSelected", "isPrevSelected", "nativeAttributes", "onClick", "onFocus", "onBlur", "isEvenRow", "stripedRows", "isSelection", "hasSelection", "hasFooter", "columnId", "colIndex", "stickyState", "tableRole", "level", "isExpandable", "isExpanded", "onExpandableItemToggle", "expandButtonLabel", "collapseButtonLabel", "verticalAlign", "resizableColumns", "resizableStyle", "isEditable", "isEditing", "isEditingDisabled", "hasSuccessIcon", "tableVariant"]);
  const Element = isRowHeader ? "th" : "td";
  const isVisualRefresh = useVisualRefresh();
  resizableStyle = resizableColumns ? {} : resizableStyle;
  nativeAttributes = Object.assign(Object.assign({}, nativeAttributes), getTableCellRoleProps({ tableRole, isRowHeader, colIndex }));
  const stickyStyles = useStickyCellStyles({
    stickyColumns: stickyState,
    columnId,
    getClassName: (props) => getStickyClassNames(styles_css_default5, props)
  });
  const cellRefObject = (0, import_react16.useRef)(null);
  const mergedRef = useMergeRefs(stickyStyles.ref, ref, cellRefObject);
  const { tabIndex: cellTabIndex } = useSingleTabStopNavigation(cellRefObject);
  const isEditingActive = isEditing && !isEditingDisabled;
  return import_react16.default.createElement(
    Element,
    Object.assign({ style: Object.assign(Object.assign({}, resizableStyle), stickyStyles.style), className: clsx_m_default(styles_css_default5["body-cell"], isFirstRow && styles_css_default5["body-cell-first-row"], isLastRow && styles_css_default5["body-cell-last-row"], isSelected && styles_css_default5["body-cell-selected"], isNextSelected && styles_css_default5["body-cell-next-selected"], isPrevSelected && styles_css_default5["body-cell-prev-selected"], !isEvenRow && stripedRows && styles_css_default5["body-cell-shaded"], stripedRows && styles_css_default5["has-striped-rows"], isVisualRefresh && styles_css_default5["is-visual-refresh"], isSelection && styles_css_default4["selection-control"], hasSelection && styles_css_default5["has-selection"], hasFooter && styles_css_default5["has-footer"], resizableColumns && styles_css_default5["resizable-columns"], verticalAlign === "top" && styles_css_default5["body-cell-align-top"], isEditable && styles_css_default5["body-cell-editable"], isEditing && !isEditingDisabled && styles_css_default5["body-cell-edit-active"], isEditing && isEditingDisabled && styles_css_default5["body-cell-edit-disabled-popover"], hasSuccessIcon && styles_css_default5["body-cell-has-success"], level !== void 0 && !isEditingActive && styles_css_default5["body-cell-expandable"], level !== void 0 && !isEditingActive && styles_css_default5[`expandable-level-${getLevelClassSuffix(level)}`], tableVariant && styles_css_default5[`table-variant-${tableVariant}`], stickyStyles.className), onClick, onFocus, onBlur, ref: mergedRef }, nativeAttributes, { tabIndex: cellTabIndex === -1 ? void 0 : cellTabIndex }, copyAnalyticsMetadataAttribute(rest)),
    level !== void 0 && isExpandable && !isEditingActive && import_react16.default.createElement(
      "div",
      { className: styles_css_default5["expandable-toggle-wrapper"] },
      import_react16.default.createElement(ExpandToggleButton, { isExpanded, onExpandableItemToggle, expandButtonLabel, collapseButtonLabel })
    ),
    import_react16.default.createElement("div", { className: clsx_m_default(styles_css_default5["body-cell-content"], wrapLines && styles_css_default5["body-cell-wrap"]) }, children)
  );
});
function getLevelClassSuffix(level) {
  return 0 <= level && level <= 9 ? level : "next";
}

// node_modules/@cloudscape-design/components/table/body-cell/disabled-inline-editor.js
function DisabledInlineEditor(_a) {
  var _b;
  var { item, column, ariaLabels, isEditing, onEditStart, onEditEnd, editDisabledReason } = _a, rest = __rest(_a, ["item", "column", "ariaLabels", "isEditing", "onEditStart", "onEditEnd", "editDisabledReason"]);
  const isExpandableColumn = rest.level !== void 0;
  const clickAwayRef = useClickAway(() => {
    if (isEditing) {
      onEditEnd(true);
    }
  });
  const iconRef = (0, import_react17.useRef)(null);
  const buttonRef = (0, import_react17.useRef)(null);
  const portalRef = (0, import_react17.useRef)(null);
  function handleEscape(event) {
    if (event.key === "Escape") {
      onEditEnd(true);
    }
  }
  const onClick = () => {
    var _a2;
    onEditStart();
    (_a2 = buttonRef.current) === null || _a2 === void 0 ? void 0 : _a2.focus();
  };
  const { targetProps, descriptionEl } = useHiddenDescription(editDisabledReason);
  const portalClasses = usePortalModeClasses(portalRef);
  const { tabIndex } = useSingleTabStopNavigation(buttonRef);
  return import_react17.default.createElement(
    TableTdElement,
    Object.assign({}, rest, { nativeAttributes: { "data-inline-editing-active": isEditing.toString() }, isEditing, isEditingDisabled: true, onClick: !isEditing && !isExpandableColumn ? onClick : void 0, ref: !isExpandableColumn ? clickAwayRef : void 0 }),
    column.cell(item),
    import_react17.default.createElement(
      "div",
      { className: styles_css_default5["body-cell-editor-wrapper"] },
      import_react17.default.createElement(
        "div",
        { ref: isExpandableColumn ? clickAwayRef : void 0 },
        import_react17.default.createElement(
          "button",
          Object.assign({ ref: buttonRef, tabIndex, className: clsx_m_default(styles_css_default5["body-cell-editor"], styles_css_default5["body-cell-editor-disabled"], isExpandableColumn && styles_css_default5["body-cell-editor-focusable"]), onClick: !isEditing && isExpandableColumn ? onClick : void 0, "aria-label": (_b = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.activateEditLabel) === null || _b === void 0 ? void 0 : _b.call(ariaLabels, column, item), "aria-haspopup": "dialog", "aria-disabled": "true", onKeyDown: handleEscape }, targetProps),
          import_react17.default.createElement(
            "span",
            { className: styles_css_default5["body-cell-editor-icon"] },
            import_react17.default.createElement(internal_default, { name: "lock-private", variant: "normal", __internalRootRef: iconRef })
          ),
          descriptionEl
        )
      )
    ),
    isEditing && import_react17.default.createElement(
      "span",
      { ref: portalRef },
      import_react17.default.createElement(
        Portal,
        null,
        import_react17.default.createElement(
          "span",
          { className: portalClasses },
          import_react17.default.createElement(
            PopoverContainer,
            { size: "medium", fixedWidth: false, position: "top", trackRef: iconRef, arrow: (position) => import_react17.default.createElement(arrow_default, { position }), renderWithPortal: true, zIndex: 7e3 },
            import_react17.default.createElement(
              PopoverBody,
              { dismissButton: false, dismissAriaLabel: void 0, header: null, onDismiss: () => {
              }, overflowVisible: "both" },
              import_react17.default.createElement(internal_default2, { tagName: "span" }, editDisabledReason)
            )
          )
        )
      )
    )
  );
}

// node_modules/@cloudscape-design/components/table/body-cell/inline-editor.js
var import_react21 = __toESM(require_react());

// node_modules/@cloudscape-design/components/form-field/internal.js
var import_react20 = __toESM(require_react());

// node_modules/@cloudscape-design/components/grid/internal.js
var import_react18 = __toESM(require_react());

// node_modules/@cloudscape-design/components/internal/hooks/container-queries/use-container-breakpoints.js
function useContainerBreakpoints(triggers) {
  const triggersDep = triggers === null || triggers === void 0 ? void 0 : triggers.join();
  return useContainerQuery((rect) => getMatchingBreakpoint(rect.contentBoxWidth, triggers), [triggersDep]);
}

// node_modules/@cloudscape-design/components/grid/styles.css.js
import "/Users/shikaradee/raghu/GenAi/MachineLearning/reactapp/plat/frontend/node_modules/@cloudscape-design/components/grid/styles.scoped.css";
var styles_css_default6 = {
  "grid": "awsui_grid_14yj0_y2kz6_145",
  "no-gutters": "awsui_no-gutters_14yj0_y2kz6_181",
  "grid-column": "awsui_grid-column_14yj0_y2kz6_186",
  "colspan-1": "awsui_colspan-1_14yj0_y2kz6_197",
  "push-1": "awsui_push-1_14yj0_y2kz6_201",
  "pull-1": "awsui_pull-1_14yj0_y2kz6_204",
  "colspan-2": "awsui_colspan-2_14yj0_y2kz6_207",
  "push-2": "awsui_push-2_14yj0_y2kz6_211",
  "pull-2": "awsui_pull-2_14yj0_y2kz6_214",
  "colspan-3": "awsui_colspan-3_14yj0_y2kz6_217",
  "push-3": "awsui_push-3_14yj0_y2kz6_221",
  "pull-3": "awsui_pull-3_14yj0_y2kz6_224",
  "colspan-4": "awsui_colspan-4_14yj0_y2kz6_227",
  "push-4": "awsui_push-4_14yj0_y2kz6_231",
  "pull-4": "awsui_pull-4_14yj0_y2kz6_234",
  "colspan-5": "awsui_colspan-5_14yj0_y2kz6_237",
  "push-5": "awsui_push-5_14yj0_y2kz6_241",
  "pull-5": "awsui_pull-5_14yj0_y2kz6_244",
  "colspan-6": "awsui_colspan-6_14yj0_y2kz6_247",
  "push-6": "awsui_push-6_14yj0_y2kz6_251",
  "pull-6": "awsui_pull-6_14yj0_y2kz6_254",
  "colspan-7": "awsui_colspan-7_14yj0_y2kz6_257",
  "push-7": "awsui_push-7_14yj0_y2kz6_261",
  "pull-7": "awsui_pull-7_14yj0_y2kz6_264",
  "colspan-8": "awsui_colspan-8_14yj0_y2kz6_267",
  "push-8": "awsui_push-8_14yj0_y2kz6_271",
  "pull-8": "awsui_pull-8_14yj0_y2kz6_274",
  "colspan-9": "awsui_colspan-9_14yj0_y2kz6_277",
  "push-9": "awsui_push-9_14yj0_y2kz6_281",
  "pull-9": "awsui_pull-9_14yj0_y2kz6_284",
  "colspan-10": "awsui_colspan-10_14yj0_y2kz6_287",
  "push-10": "awsui_push-10_14yj0_y2kz6_291",
  "pull-10": "awsui_pull-10_14yj0_y2kz6_294",
  "colspan-11": "awsui_colspan-11_14yj0_y2kz6_297",
  "push-11": "awsui_push-11_14yj0_y2kz6_301",
  "pull-11": "awsui_pull-11_14yj0_y2kz6_304",
  "colspan-12": "awsui_colspan-12_14yj0_y2kz6_307",
  "push-12": "awsui_push-12_14yj0_y2kz6_311",
  "pull-12": "awsui_pull-12_14yj0_y2kz6_314",
  "push-0": "awsui_push-0_14yj0_y2kz6_317",
  "pull-0": "awsui_pull-0_14yj0_y2kz6_320",
  "offset-1": "awsui_offset-1_14yj0_y2kz6_323",
  "offset-2": "awsui_offset-2_14yj0_y2kz6_326",
  "offset-3": "awsui_offset-3_14yj0_y2kz6_329",
  "offset-4": "awsui_offset-4_14yj0_y2kz6_332",
  "offset-5": "awsui_offset-5_14yj0_y2kz6_335",
  "offset-6": "awsui_offset-6_14yj0_y2kz6_338",
  "offset-7": "awsui_offset-7_14yj0_y2kz6_341",
  "offset-8": "awsui_offset-8_14yj0_y2kz6_344",
  "offset-9": "awsui_offset-9_14yj0_y2kz6_347",
  "offset-10": "awsui_offset-10_14yj0_y2kz6_350",
  "offset-11": "awsui_offset-11_14yj0_y2kz6_353",
  "restore-pointer-events": "awsui_restore-pointer-events_14yj0_y2kz6_357"
};

// node_modules/@cloudscape-design/components/grid/internal.js
var InternalGrid = import_react18.default.forwardRef((_a, ref) => {
  var { __breakpoint, gridDefinition = [], disableGutters = false, children, __tagOverride, __responsiveClassName, __internalRootRef = null } = _a, restProps = __rest(_a, ["__breakpoint", "gridDefinition", "disableGutters", "children", "__tagOverride", "__responsiveClassName", "__internalRootRef"]);
  let [defaultBreakpoint, defaultRef] = useContainerBreakpoints(void 0);
  if (__breakpoint !== void 0) {
    defaultBreakpoint = __breakpoint;
    defaultRef = ref;
  }
  const baseProps = getBaseProps(restProps);
  const flattenedChildren = flattenChildren(children);
  const Tag = __tagOverride !== null && __tagOverride !== void 0 ? __tagOverride : "div";
  if (isDevelopment) {
    const columnCount = gridDefinition.length;
    const childCount = flattenedChildren.length;
    if (columnCount !== childCount) {
      warnOnce("Grid", `The number of children (${childCount}) does not match the number of columns defined (${columnCount}).`);
    }
  }
  const mergedRef = useMergeRefs(defaultRef, __internalRootRef);
  return import_react18.default.createElement(Tag, Object.assign({}, baseProps, { className: clsx_m_default(styles_css_default6.grid, baseProps.className, { [styles_css_default6["no-gutters"]]: disableGutters }, __responsiveClassName ? __responsiveClassName(defaultBreakpoint) : null), ref: mergedRef }), flattenedChildren.map((child, i) => {
    var _a2, _b, _c, _d;
    const key = child.key;
    return import_react18.default.createElement(
      "div",
      { key: key ? String(key) : void 0, className: clsx_m_default(styles_css_default6["grid-column"], getColumnClassNames("colspan", (_a2 = gridDefinition[i]) === null || _a2 === void 0 ? void 0 : _a2.colspan, defaultBreakpoint), getColumnClassNames("offset", (_b = gridDefinition[i]) === null || _b === void 0 ? void 0 : _b.offset, defaultBreakpoint), getColumnClassNames("pull", (_c = gridDefinition[i]) === null || _c === void 0 ? void 0 : _c.pull, defaultBreakpoint), getColumnClassNames("push", (_d = gridDefinition[i]) === null || _d === void 0 ? void 0 : _d.push, defaultBreakpoint)) },
      import_react18.default.createElement("div", { className: styles_css_default6["restore-pointer-events"] }, child)
    );
  }));
});
function getColumnClassNames(prop, mapping, breakpoint) {
  if (typeof mapping === "number") {
    return styles_css_default6[`${prop}-${mapping}`];
  }
  if (breakpoint === null || mapping === void 0) {
    return null;
  }
  return styles_css_default6[`${prop}-${matchBreakpointMapping(mapping, breakpoint)}`];
}
var internal_default5 = InternalGrid;

// node_modules/@cloudscape-design/components/internal/context/form-field-context.js
var import_react19 = __toESM(require_react());
var FormFieldContext = (0, import_react19.createContext)({});
function applyDefault(fields, defaults, keys) {
  const result = {};
  keys.forEach((key) => {
    result[key] = fields[key] === void 0 ? defaults[key] : fields[key];
  });
  return result;
}
function useFormFieldContext(props) {
  const context = (0, import_react19.useContext)(FormFieldContext);
  return applyDefault(props, context, ["invalid", "warning", "controlId", "ariaLabelledby", "ariaDescribedby"]);
}

// node_modules/@cloudscape-design/components/internal/utils/strings/join-strings.js
function joinStrings(...strings) {
  return strings.filter(Boolean).join(" ") || void 0;
}

// node_modules/@cloudscape-design/components/internal/utils/strings/pad-left-zeros.js
function padLeftZeros(text, length) {
  while (text.length < length) {
    text = `0${text}`;
  }
  return text;
}

// node_modules/@cloudscape-design/components/form-field/util.js
function makeSlotId(prop, formFieldId, propName) {
  if (!prop) {
    return void 0;
  }
  return `${formFieldId}-${propName}`;
}
function getSlotIds(formFieldId, label, description, constraintText, errorText, warningText) {
  const ids = {
    label: makeSlotId(label, formFieldId, "label"),
    description: makeSlotId(description, formFieldId, "description"),
    constraint: makeSlotId(constraintText, formFieldId, "constraint"),
    error: makeSlotId(errorText, formFieldId, "error"),
    warning: makeSlotId(warningText, formFieldId, "warning")
  };
  return ids;
}
function getAriaDescribedBy({ error, warning, description, constraint }) {
  const describedByAttributes = [error, warning, description, constraint].filter((e) => !!e);
  const describedBy = describedByAttributes.length ? describedByAttributes.join(" ") : void 0;
  return describedBy;
}
function getGridDefinition(stretch, secondaryControlPresent, isRefresh) {
  let columns;
  if (stretch) {
    columns = [{ colspan: 12 }, { colspan: 12 }];
  } else if (isRefresh) {
    columns = [{ colspan: { default: 12, xs: 8 } }, { colspan: { default: 12, xs: 4 } }];
  } else {
    columns = [{ colspan: { default: 12, xs: 9 } }, { colspan: { default: 12, xs: 3 } }];
  }
  if (!secondaryControlPresent) {
    return [columns[0]];
  }
  return columns;
}

// node_modules/@cloudscape-design/components/form-field/analytics-metadata/styles.css.js
import "/Users/shikaradee/raghu/GenAi/MachineLearning/reactapp/plat/frontend/node_modules/@cloudscape-design/components/form-field/analytics-metadata/styles.scoped.css";
var styles_css_default7 = {
  "label": "awsui_label_aqu00_ocied_5"
};

// node_modules/@cloudscape-design/components/form-field/styles.css.js
import "/Users/shikaradee/raghu/GenAi/MachineLearning/reactapp/plat/frontend/node_modules/@cloudscape-design/components/form-field/styles.scoped.css";
var styles_css_default8 = {
  "error-icon-shake-wrapper": "awsui_error-icon-shake-wrapper_14mhv_fzxwy_153",
  "warning-icon-shake-wrapper": "awsui_warning-icon-shake-wrapper_14mhv_fzxwy_154",
  "awsui-motion-shake-horizontally": "awsui_awsui-motion-shake-horizontally_14mhv_fzxwy_1",
  "error-icon-scale-wrapper": "awsui_error-icon-scale-wrapper_14mhv_fzxwy_184",
  "warning-icon-scale-wrapper": "awsui_warning-icon-scale-wrapper_14mhv_fzxwy_185",
  "awsui-motion-scale-popup": "awsui_awsui-motion-scale-popup_14mhv_fzxwy_1",
  "warning": "awsui_warning_14mhv_fzxwy_154",
  "error": "awsui_error_14mhv_fzxwy_153",
  "awsui-motion-fade-in-0": "awsui_awsui-motion-fade-in-0_14mhv_fzxwy_1",
  "root": "awsui_root_14mhv_fzxwy_236",
  "label": "awsui_label_14mhv_fzxwy_269",
  "info": "awsui_info_14mhv_fzxwy_285",
  "description": "awsui_description_14mhv_fzxwy_291",
  "constraint": "awsui_constraint_14mhv_fzxwy_292",
  "hints": "awsui_hints_14mhv_fzxwy_299",
  "constraint-has-validation-text": "awsui_constraint-has-validation-text_14mhv_fzxwy_300",
  "secondary-control": "awsui_secondary-control_14mhv_fzxwy_304",
  "controls": "awsui_controls_14mhv_fzxwy_308",
  "label-hidden": "awsui_label-hidden_14mhv_fzxwy_308",
  "label-wrapper": "awsui_label-wrapper_14mhv_fzxwy_311",
  "control": "awsui_control_14mhv_fzxwy_308",
  "error__message": "awsui_error__message_14mhv_fzxwy_338",
  "warning__message": "awsui_warning__message_14mhv_fzxwy_339",
  "visually-hidden": "awsui_visually-hidden_14mhv_fzxwy_343"
};

// node_modules/@cloudscape-design/components/form-field/internal.js
function FormFieldError({ id, children, errorIconAriaLabel }) {
  const i18n = useInternalI18n("form-field");
  const contentRef = (0, import_react20.useRef)(null);
  const i18nErrorIconAriaLabel = i18n("i18nStrings.errorIconAriaLabel", errorIconAriaLabel);
  return import_react20.default.createElement(
    import_react20.default.Fragment,
    null,
    import_react20.default.createElement(
      "div",
      { id, className: styles_css_default8.error },
      import_react20.default.createElement(
        "div",
        { className: styles_css_default8["error-icon-shake-wrapper"] },
        import_react20.default.createElement(
          "div",
          { className: styles_css_default8["error-icon-scale-wrapper"] },
          import_react20.default.createElement(internal_default, { name: "status-negative", size: "small", ariaLabel: i18nErrorIconAriaLabel })
        )
      ),
      import_react20.default.createElement("span", { className: styles_css_default8.error__message, ref: contentRef }, children)
    ),
    import_react20.default.createElement(internal_default2, { assertive: true, tagName: "span", sources: [i18nErrorIconAriaLabel, contentRef] })
  );
}
function FormFieldWarning({ id, children, warningIconAriaLabel }) {
  const i18n = useInternalI18n("form-field");
  const contentRef = (0, import_react20.useRef)(null);
  const i18nWarningIconAriaLabel = i18n("i18nStrings.warningIconAriaLabel", warningIconAriaLabel);
  return import_react20.default.createElement(
    import_react20.default.Fragment,
    null,
    import_react20.default.createElement(
      "div",
      { id, className: styles_css_default8.warning },
      import_react20.default.createElement(
        "div",
        { className: styles_css_default8["warning-icon-shake-wrapper"] },
        import_react20.default.createElement(
          "div",
          { className: styles_css_default8["warning-icon-scale-wrapper"] },
          import_react20.default.createElement(internal_default, { name: "status-warning", size: "small", ariaLabel: i18nWarningIconAriaLabel })
        )
      ),
      import_react20.default.createElement("span", { className: styles_css_default8.warning__message, ref: contentRef }, children)
    ),
    import_react20.default.createElement(internal_default2, { assertive: true, tagName: "span", sources: [i18nWarningIconAriaLabel, contentRef] })
  );
}
function ConstraintText({ id, hasValidationText, children }) {
  return import_react20.default.createElement("div", { id, className: clsx_m_default(styles_css_default8.constraint, hasValidationText && styles_css_default8["constraint-has-validation-text"]) }, children);
}
function InternalFormField(_a) {
  var { controlId, stretch = false, label, info, i18nStrings, children, secondaryControl, description, constraintText, errorText, warningText, __hideLabel, __internalRootRef = null, __disableGutters = false, __analyticsMetadata = void 0, __style = {} } = _a, rest = __rest(_a, ["controlId", "stretch", "label", "info", "i18nStrings", "children", "secondaryControl", "description", "constraintText", "errorText", "warningText", "__hideLabel", "__internalRootRef", "__disableGutters", "__analyticsMetadata", "__style"]);
  const baseProps = getBaseProps(rest);
  const isRefresh = useVisualRefresh();
  const instanceUniqueId = useUniqueId("formField");
  const generatedControlId = controlId || instanceUniqueId;
  const formFieldId = controlId || generatedControlId;
  const { funnelIdentifier, funnelInteractionId, submissionAttempt, funnelState, errorCount } = useFunnel();
  const { stepIdentifier, stepNumber, stepNameSelector } = useFunnelStep();
  const { subStepIdentifier, subStepSelector, subStepNameSelector } = useFunnelSubStep();
  const showWarning = warningText && !errorText;
  if (warningText && errorText) {
    warnOnce("FileUpload", "Both `errorText` and `warningText` exist. `warningText` will not be shown.");
  }
  const slotIds = getSlotIds(formFieldId, label, description, constraintText, errorText, showWarning ? warningText : void 0);
  const ariaDescribedBy = getAriaDescribedBy(slotIds);
  const gridDefinition = getGridDefinition(stretch, !!secondaryControl, isRefresh);
  const { ariaLabelledby: parentAriaLabelledby, ariaDescribedby: parentAriaDescribedby, invalid: parentInvalid, warning: parentWarning } = useFormFieldContext({});
  const contextValuesWithoutControlId = {
    ariaLabelledby: joinStrings(parentAriaLabelledby, slotIds.label) || void 0,
    ariaDescribedby: joinStrings(parentAriaDescribedby, ariaDescribedBy) || void 0,
    invalid: !!errorText || !!parentInvalid,
    warning: !!warningText && !errorText || !!parentWarning && !parentInvalid
  };
  const analyticsAttributes = {
    [DATA_ATTR_FIELD_LABEL]: slotIds.label ? getFieldSlotSeletor(slotIds.label) : void 0,
    [DATA_ATTR_FIELD_ERROR]: slotIds.error ? getFieldSlotSeletor(slotIds.error) : void 0
  };
  (0, import_react20.useEffect)(() => {
    var _a2, _b, _c;
    if (funnelInteractionId && errorText && funnelState.current !== "complete") {
      const stepName = getTextFromSelector(stepNameSelector);
      const subStepName = getTextFromSelector(subStepNameSelector);
      errorCount.current++;
      const errorIsVisible = ((_c = (_b = (_a2 = __internalRootRef === null || __internalRootRef === void 0 ? void 0 : __internalRootRef.current) === null || _a2 === void 0 ? void 0 : _a2.getBoundingClientRect()) === null || _b === void 0 ? void 0 : _b.width) !== null && _c !== void 0 ? _c : 0) > 0;
      if (errorIsVisible) {
        FunnelMetrics.funnelSubStepError({
          funnelInteractionId,
          funnelIdentifier,
          subStepSelector,
          subStepName,
          subStepNameSelector,
          subStepIdentifier,
          stepNumber,
          stepName,
          stepNameSelector,
          stepIdentifier,
          fieldErrorSelector: `${getFieldSlotSeletor(slotIds.error)} .${styles_css_default8.error__message}`,
          fieldLabelSelector: getFieldSlotSeletor(slotIds.label),
          subStepAllSelector: getSubStepAllSelector(),
          fieldIdentifier: __analyticsMetadata === null || __analyticsMetadata === void 0 ? void 0 : __analyticsMetadata.instanceIdentifier,
          errorContext: __analyticsMetadata === null || __analyticsMetadata === void 0 ? void 0 : __analyticsMetadata.errorContext
        });
      }
      return () => {
        errorCount.current--;
      };
    }
  }, [funnelInteractionId, errorText, submissionAttempt, errorCount]);
  return import_react20.default.createElement(
    "div",
    Object.assign({}, baseProps, { className: clsx_m_default(baseProps.className, styles_css_default8.root), style: __style, ref: __internalRootRef }, analyticsAttributes, copyAnalyticsMetadataAttribute(rest)),
    import_react20.default.createElement(
      "div",
      { className: clsx_m_default(styles_css_default8["label-wrapper"], __hideLabel && styles_css_default8["visually-hidden"]) },
      label && import_react20.default.createElement("label", { className: clsx_m_default(styles_css_default8.label, styles_css_default7.label), id: slotIds.label, htmlFor: generatedControlId }, label),
      import_react20.default.createElement(InfoLinkLabelContext.Provider, { value: slotIds.label }, !__hideLabel && info && import_react20.default.createElement("span", { className: styles_css_default8.info }, info))
    ),
    description && import_react20.default.createElement("div", { className: styles_css_default8.description, id: slotIds.description }, description),
    import_react20.default.createElement(
      "div",
      { className: clsx_m_default(styles_css_default8.controls, __hideLabel && styles_css_default8["label-hidden"]) },
      import_react20.default.createElement(
        internal_default5,
        { gridDefinition, disableGutters: __disableGutters },
        import_react20.default.createElement(FormFieldContext.Provider, { value: Object.assign({ controlId: generatedControlId }, contextValuesWithoutControlId) }, children && import_react20.default.createElement("div", { className: styles_css_default8.control }, children)),
        secondaryControl && import_react20.default.createElement(
          FormFieldContext.Provider,
          { value: contextValuesWithoutControlId },
          import_react20.default.createElement("div", { className: styles_css_default8["secondary-control"] }, secondaryControl)
        )
      )
    ),
    (constraintText || errorText || warningText) && import_react20.default.createElement(
      "div",
      { className: styles_css_default8.hints },
      errorText && import_react20.default.createElement(FormFieldError, { id: slotIds.error, errorIconAriaLabel: i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.errorIconAriaLabel }, errorText),
      showWarning && import_react20.default.createElement(FormFieldWarning, { id: slotIds.warning, warningIconAriaLabel: i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.warningIconAriaLabel }, warningText),
      constraintText && import_react20.default.createElement(ConstraintText, { id: slotIds.constraint, hasValidationText: !!errorText || !!warningText }, constraintText)
    )
  );
}

// node_modules/@cloudscape-design/components/table/body-cell/inline-editor.js
var noop = () => void 0;
function InlineEditor({ ariaLabels, item, column, onEditEnd, submitEdit, __onRender }) {
  var _a, _b, _c, _d;
  const [currentEditLoading, setCurrentEditLoading] = (0, import_react21.useState)(false);
  const [currentEditValue, setCurrentEditValue] = (0, import_react21.useState)();
  const i18n = useInternalI18n("table");
  const focusLockRef = (0, import_react21.useRef)(null);
  function finishEdit({ cancelled = false, refocusCell = true } = {}) {
    if (!cancelled) {
      setCurrentEditValue(void 0);
    }
    onEditEnd({ cancelled, refocusCell });
  }
  function handleSubmit() {
    var _a2;
    return __awaiter(this, void 0, void 0, function* () {
      if (currentEditValue === void 0) {
        finishEdit();
        return;
      }
      setCurrentEditLoading(true);
      try {
        yield submitEdit(item, column, currentEditValue);
        setCurrentEditLoading(false);
        finishEdit();
      } catch (e) {
        setCurrentEditLoading(false);
        (_a2 = focusLockRef.current) === null || _a2 === void 0 ? void 0 : _a2.focusFirst();
      }
    });
  }
  function onFormSubmit(evt) {
    evt.preventDefault();
    evt.stopPropagation();
    handleSubmit();
  }
  function onCancel({ reFocusEditedCell = true } = {}) {
    if (currentEditLoading) {
      return;
    }
    finishEdit({ cancelled: true, refocusCell: reFocusEditedCell });
  }
  function handleEscape(event) {
    if (event.key === "Escape") {
      onCancel();
    }
  }
  const clickAwayRef = useClickAway(() => onCancel({ reFocusEditedCell: false }));
  (0, import_react21.useEffect)(() => {
    if (__onRender) {
      const timer = setTimeout(__onRender, 1);
      return () => clearTimeout(timer);
    }
  }, [__onRender]);
  const { ariaLabel = void 0, validation = noop, errorIconAriaLabel, constraintText, editingCell, disableNativeForm } = column.editConfig;
  const cellContext = {
    currentValue: currentEditValue,
    setValue: setCurrentEditValue,
    submitValue: handleSubmit
  };
  const FormElement = disableNativeForm ? "div" : "form";
  return import_react21.default.createElement(
    focus_lock_default,
    { restoreFocus: true, ref: focusLockRef },
    import_react21.default.createElement(
      "div",
      { role: "dialog", ref: clickAwayRef, "aria-label": (_a = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.activateEditLabel) === null || _a === void 0 ? void 0 : _a.call(ariaLabels, column, item), onKeyDown: handleEscape },
      import_react21.default.createElement(
        FormElement,
        { onSubmit: disableNativeForm ? void 0 : onFormSubmit },
        import_react21.default.createElement(
          InternalFormField,
          { stretch: true, label: ariaLabel, constraintText, __hideLabel: true, __disableGutters: true, i18nStrings: { errorIconAriaLabel }, errorText: validation(item, currentEditValue) },
          import_react21.default.createElement(
            "div",
            { className: styles_css_default5["body-cell-editor-row"] },
            import_react21.default.createElement("div", { className: styles_css_default5["body-cell-editor-row-editor"] }, editingCell(item, cellContext)),
            import_react21.default.createElement(
              "span",
              { className: styles_css_default5["body-cell-editor-controls"] },
              import_react21.default.createElement(
                internal_default4,
                { direction: "horizontal", size: "xxs" },
                !currentEditLoading ? import_react21.default.createElement(internal_default3, { ariaLabel: (_b = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.cancelEditLabel) === null || _b === void 0 ? void 0 : _b.call(ariaLabels, column), formAction: "none", iconName: "close", variant: "inline-icon", onClick: () => onCancel() }) : null,
                import_react21.default.createElement(internal_default3, { ariaLabel: (_c = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.submitEditLabel) === null || _c === void 0 ? void 0 : _c.call(ariaLabels, column), formAction: disableNativeForm ? "none" : "submit", onClick: disableNativeForm ? handleSubmit : void 0, iconName: "check", variant: "inline-icon", loading: currentEditLoading })
              ),
              import_react21.default.createElement(internal_default2, { tagName: "span", hidden: true }, currentEditLoading ? i18n("ariaLabels.submittingEditText", (_d = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.submittingEditText) === null || _d === void 0 ? void 0 : _d.call(ariaLabels, column)) : "")
            )
          )
        )
      )
    )
  );
}

// node_modules/@cloudscape-design/components/table/body-cell/index.js
var submitHandlerFallback = () => {
  throw new Error("The function `handleSubmit` is required for editable columns");
};
function TableCellEditable(_a) {
  var _b, _c, _d;
  var { item, column, isEditing, onEditStart, onEditEnd, submitEdit, ariaLabels, successfulEdit = false } = _a, rest = __rest(_a, ["item", "column", "isEditing", "onEditStart", "onEditEnd", "submitEdit", "ariaLabels", "successfulEdit"]);
  const i18n = useInternalI18n("table");
  const editActivateRef = (0, import_react22.useRef)(null);
  const tdNativeAttributes = {
    "data-inline-editing-active": isEditing.toString()
  };
  const isFocusMoveNeededRef = (0, import_react22.useRef)(false);
  const isExpandableColumn = rest.level !== void 0;
  (0, import_react22.useEffect)(() => {
    if (!isEditing && editActivateRef.current && isFocusMoveNeededRef.current) {
      isFocusMoveNeededRef.current = false;
      editActivateRef.current.focus();
    }
  }, [isEditing]);
  const [hasFocus, setHasFocus] = (0, import_react22.useState)(false);
  const prevSuccessfulEdit = usePrevious(successfulEdit);
  const prevHasFocus = usePrevious(hasFocus);
  const [showSuccessIcon, setShowSuccessIcon] = (0, import_react22.useState)(false);
  (0, import_react22.useEffect)(() => {
    if (successfulEdit && prevSuccessfulEdit && !hasFocus && prevHasFocus) {
      setShowSuccessIcon(false);
    }
    if (successfulEdit && !prevSuccessfulEdit) {
      setShowSuccessIcon(true);
    }
  }, [hasFocus, successfulEdit, prevHasFocus, prevSuccessfulEdit]);
  const { tabIndex: editActivateTabIndex } = useSingleTabStopNavigation(editActivateRef);
  return import_react22.default.createElement(TableTdElement, Object.assign({}, rest, { nativeAttributes: tdNativeAttributes, isEditing, hasSuccessIcon: showSuccessIcon && hasFocus, onClick: !isEditing && !isExpandableColumn ? onEditStart : void 0, onFocus: () => setHasFocus(true), onBlur: () => setHasFocus(false) }), isEditing && column.editConfig ? import_react22.default.createElement(InlineEditor, { ariaLabels, column, item, onEditEnd: (options) => {
    setShowSuccessIcon(false);
    isFocusMoveNeededRef.current = options.refocusCell;
    onEditEnd(options.cancelled);
  }, submitEdit: submitEdit !== null && submitEdit !== void 0 ? submitEdit : submitHandlerFallback }) : import_react22.default.createElement(
    import_react22.default.Fragment,
    null,
    column.cell(item),
    showSuccessIcon && hasFocus && import_react22.default.createElement(
      import_react22.default.Fragment,
      null,
      import_react22.default.createElement(
        "span",
        { className: styles_css_default5["body-cell-success"], onMouseDown: (e) => {
          e.preventDefault();
        } },
        import_react22.default.createElement(internal_default, { name: "status-positive", variant: "success", ariaLabel: (_b = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.successfulEditLabel) === null || _b === void 0 ? void 0 : _b.call(ariaLabels, column) })
      ),
      import_react22.default.createElement(internal_default2, { tagName: "span", hidden: true }, i18n("ariaLabels.successfulEditLabel", (_c = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.successfulEditLabel) === null || _c === void 0 ? void 0 : _c.call(ariaLabels, column)))
    ),
    import_react22.default.createElement(
      "div",
      { className: styles_css_default5["body-cell-editor-wrapper"] },
      import_react22.default.createElement(
        "button",
        { className: clsx_m_default(styles_css_default5["body-cell-editor"], isExpandableColumn && styles_css_default5["body-cell-editor-focusable"]), "aria-label": (_d = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.activateEditLabel) === null || _d === void 0 ? void 0 : _d.call(ariaLabels, column, item), ref: editActivateRef, onClick: !isEditing && isExpandableColumn ? onEditStart : void 0, tabIndex: editActivateTabIndex },
        import_react22.default.createElement(
          "span",
          { className: styles_css_default5["body-cell-editor-icon"] },
          import_react22.default.createElement(internal_default, { name: "edit" })
        )
      )
    )
  ));
}
function TableBodyCell(props) {
  var _a, _b;
  const editDisabledReason = (_b = (_a = props.column.editConfig) === null || _a === void 0 ? void 0 : _a.disabledReason) === null || _b === void 0 ? void 0 : _b.call(_a, props.item);
  if (editDisabledReason) {
    return import_react22.default.createElement(DisabledInlineEditor, Object.assign({ editDisabledReason }, props));
  }
  if (props.isEditable || props.isEditing) {
    return import_react22.default.createElement(TableCellEditable, Object.assign({}, props));
  }
  const { column, item } = props;
  return import_react22.default.createElement(TableTdElement, Object.assign({}, props, { isEditable: false }), column.cell(item));
}

// node_modules/@cloudscape-design/components/table/column-widths-utils.js
function checkColumnWidths(columnDefinitions) {
  for (const column of columnDefinitions) {
    checkProperty(column, "minWidth");
    checkProperty(column, "width");
  }
}
function setElementWidths(element, styles) {
  function setProperty(property) {
    const value = styles[property];
    let widthCssValue = "";
    if (typeof value === "number") {
      widthCssValue = value + "px";
    }
    if (typeof value === "string") {
      widthCssValue = value;
    }
    if (element.style[property] !== widthCssValue) {
      element.style[property] = widthCssValue;
    }
  }
  setProperty("width");
  setProperty("minWidth");
  setProperty("maxWidth");
}
function checkProperty(column, name) {
  const value = column[name];
  if (typeof value !== "number" && typeof value !== "undefined") {
    warnOnce("Table", `resizableColumns feature requires ${name} property to be a number, got ${value}. The component may work incorrectly.`);
  }
}

// node_modules/@cloudscape-design/components/table/selection/utils.js
var SELECTION_ITEM = "selection-item";
var SELECTION_ROOT = "selection-root";
var ItemSet = class {
  constructor(trackBy, items) {
    this.map = /* @__PURE__ */ new Map();
    this.put = (item) => this.map.set.call(this.map, getTrackableValue(this.trackBy, item), item);
    this.has = (item) => this.map.has.call(this.map, getTrackableValue(this.trackBy, item));
    this.forEach = this.map.forEach.bind(this.map);
    this.trackBy = trackBy;
    items.forEach(this.put);
  }
};
var focusMarkers = {
  item: { ["data-" + SELECTION_ITEM]: "item" },
  all: { ["data-" + SELECTION_ITEM]: "all" },
  root: { ["data-" + SELECTION_ROOT]: "true" }
};

// node_modules/@cloudscape-design/components/table/expandable-rows/expandable-rows-utils.js
function useExpandableTableProps({ items, expandableRows, trackBy, ariaLabels }) {
  var _a;
  const i18n = useInternalI18n("table");
  const isExpandable = !!expandableRows;
  const expandedSet = new ItemSet(trackBy, (_a = expandableRows === null || expandableRows === void 0 ? void 0 : expandableRows.expandedItems) !== null && _a !== void 0 ? _a : []);
  let allItems = items;
  const itemToDetail = /* @__PURE__ */ new Map();
  const getItemLevel = (item) => {
    var _a2, _b;
    return (_b = (_a2 = itemToDetail.get(item)) === null || _a2 === void 0 ? void 0 : _a2.level) !== null && _b !== void 0 ? _b : 0;
  };
  if (isExpandable) {
    const visibleItems = new Array();
    const traverse = (item, detail) => {
      const children = expandableRows.getItemChildren(item);
      itemToDetail.set(item, Object.assign(Object.assign({}, detail), { children }));
      visibleItems.push(item);
      if (expandedSet.has(item)) {
        children.forEach((child, index) => traverse(child, { level: detail.level + 1, setSize: children.length, posInSet: index + 1, parent: item }));
      }
    };
    items.forEach((item, index) => traverse(item, { level: 1, setSize: items.length, posInSet: index + 1, parent: null }));
    for (let index = 0; index < visibleItems.length; index++) {
      const item = visibleItems[index];
      if (expandedSet.has(item)) {
        let insertionIndex = index + 1;
        for (insertionIndex; insertionIndex < visibleItems.length; insertionIndex++) {
          const insertionItem = visibleItems[insertionIndex];
          if (getItemLevel(item) >= getItemLevel(insertionItem)) {
            break;
          }
        }
        insertionIndex--;
      }
    }
    allItems = visibleItems;
  }
  const getExpandableItemProps = (item) => {
    var _a2, _b, _c, _d;
    const { level = 1, setSize = 1, posInSet = 1, parent = null, children = [] } = (_a2 = itemToDetail.get(item)) !== null && _a2 !== void 0 ? _a2 : {};
    return {
      level,
      setSize,
      posInSet,
      isExpandable: (_b = expandableRows === null || expandableRows === void 0 ? void 0 : expandableRows.isItemExpandable(item)) !== null && _b !== void 0 ? _b : true,
      isExpanded: expandedSet.has(item),
      onExpandableItemToggle: () => fireNonCancelableEvent(expandableRows === null || expandableRows === void 0 ? void 0 : expandableRows.onExpandableItemToggle, { item, expanded: !expandedSet.has(item) }),
      expandButtonLabel: i18n("ariaLabels.expandButtonLabel", (_c = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.expandButtonLabel) === null || _c === void 0 ? void 0 : _c.call(ariaLabels, item)),
      collapseButtonLabel: i18n("ariaLabels.collapseButtonLabel", (_d = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.collapseButtonLabel) === null || _d === void 0 ? void 0 : _d.call(ariaLabels, item)),
      parent,
      children
    };
  };
  return { isExpandable, allItems, getExpandableItemProps };
}

// node_modules/@cloudscape-design/components/table/no-data-cell.js
var import_react24 = __toESM(require_react());

// node_modules/@cloudscape-design/components/status-indicator/internal.js
var import_react23 = __toESM(require_react());

// node_modules/@cloudscape-design/components/status-indicator/styles.css.js
import "/Users/shikaradee/raghu/GenAi/MachineLearning/reactapp/plat/frontend/node_modules/@cloudscape-design/components/status-indicator/styles.scoped.css";
var styles_css_default9 = {
  "icon-shake": "awsui_icon-shake_1cbgc_12wag_153",
  "awsui-motion-shake-horizontally": "awsui_awsui-motion-shake-horizontally_1cbgc_12wag_1",
  "container-fade-in": "awsui_container-fade-in_1cbgc_12wag_181",
  "awsui-motion-fade-in-0": "awsui_awsui-motion-fade-in-0_1cbgc_12wag_1",
  "root": "awsui_root_1cbgc_12wag_203",
  "status-error": "awsui_status-error_1cbgc_12wag_212",
  "status-warning": "awsui_status-warning_1cbgc_12wag_215",
  "status-success": "awsui_status-success_1cbgc_12wag_218",
  "status-info": "awsui_status-info_1cbgc_12wag_221",
  "status-stopped": "awsui_status-stopped_1cbgc_12wag_224",
  "status-pending": "awsui_status-pending_1cbgc_12wag_227",
  "status-in-progress": "awsui_status-in-progress_1cbgc_12wag_230",
  "status-loading": "awsui_status-loading_1cbgc_12wag_233",
  "color-override-red": "awsui_color-override-red_1cbgc_12wag_236",
  "color-override-grey": "awsui_color-override-grey_1cbgc_12wag_239",
  "color-override-blue": "awsui_color-override-blue_1cbgc_12wag_242",
  "color-override-green": "awsui_color-override-green_1cbgc_12wag_245",
  "color-override-yellow": "awsui_color-override-yellow_1cbgc_12wag_248",
  "container": "awsui_container_1cbgc_12wag_181",
  "display-inline": "awsui_display-inline_1cbgc_12wag_252",
  "icon": "awsui_icon_1cbgc_12wag_153",
  "display-inline-block": "awsui_display-inline-block_1cbgc_12wag_260",
  "overflow-ellipsis": "awsui_overflow-ellipsis_1cbgc_12wag_269"
};

// node_modules/@cloudscape-design/components/status-indicator/internal.js
var typeToIcon = (size) => ({
  error: import_react23.default.createElement(internal_default, { name: "status-negative", size }),
  warning: import_react23.default.createElement(internal_default, { name: "status-warning", size }),
  success: import_react23.default.createElement(internal_default, { name: "status-positive", size }),
  info: import_react23.default.createElement(internal_default, { name: "status-info", size }),
  stopped: import_react23.default.createElement(internal_default, { name: "status-stopped", size }),
  pending: import_react23.default.createElement(internal_default, { name: "status-pending", size }),
  "in-progress": import_react23.default.createElement(internal_default, { name: "status-in-progress", size }),
  loading: import_react23.default.createElement(InternalSpinner, null)
});
function StatusIndicator(_a) {
  var { type, children, iconAriaLabel, colorOverride, wrapText = true, __animate = false, __internalRootRef, __size = "normal", __display = "inline-block" } = _a, rest = __rest(_a, ["type", "children", "iconAriaLabel", "colorOverride", "wrapText", "__animate", "__internalRootRef", "__size", "__display"]);
  const baseProps = getBaseProps(rest);
  return import_react23.default.createElement(
    "span",
    Object.assign({}, baseProps, { className: clsx_m_default(styles_css_default9.root, styles_css_default9[`status-${type}`], {
      [styles_css_default9[`color-override-${colorOverride}`]]: colorOverride
    }, baseProps.className), ref: __internalRootRef }),
    import_react23.default.createElement(
      "span",
      { className: clsx_m_default(styles_css_default9.container, styles_css_default9[`display-${__display}`], wrapText === false && styles_css_default9["overflow-ellipsis"], __animate && styles_css_default9["container-fade-in"]) },
      import_react23.default.createElement(
        "span",
        { className: clsx_m_default(styles_css_default9.icon, __animate && styles_css_default9["icon-shake"]), "aria-label": iconAriaLabel, role: iconAriaLabel ? "img" : void 0 },
        typeToIcon(__size)[type],
        __display === "inline" && import_react23.default.createElement(import_react23.default.Fragment, null, " ")
      ),
      children
    )
  );
}

// node_modules/@cloudscape-design/components/table/no-data-cell.js
function NoDataCell({ totalColumnsCount, hasFooter, loading, loadingText, empty, tableRef, containerRef }) {
  const cellContentRef = (0, import_react24.useRef)(null);
  useResizeObserver(containerRef, ({ contentBoxWidth: containerInlineSize }) => {
    if (tableRef.current && cellContentRef.current) {
      const tablePaddingInlineStart = parseFloat(getComputedStyle(tableRef.current).paddingInlineStart) || 0;
      const tablePaddingInlineEnd = parseFloat(getComputedStyle(tableRef.current).paddingInlineEnd) || 0;
      const inlineSize = containerInlineSize + tablePaddingInlineStart + tablePaddingInlineEnd;
      cellContentRef.current.style.inlineSize = Math.floor(inlineSize) + "px";
    }
  });
  return import_react24.default.createElement(
    "td",
    { colSpan: totalColumnsCount, className: clsx_m_default(styles_css_default4["cell-merged"], hasFooter && styles_css_default4["has-footer"]) },
    import_react24.default.createElement("div", { ref: cellContentRef, className: styles_css_default4["cell-merged-content"], "data-awsui-table-suppress-navigation": true }, loading ? import_react24.default.createElement(
      StatusIndicator,
      { type: "loading", className: styles_css_default4.loading, wrapText: true },
      import_react24.default.createElement(internal_default2, { tagName: "span" }, loadingText)
    ) : import_react24.default.createElement("div", { className: styles_css_default4.empty }, empty))
  );
}

// node_modules/@cloudscape-design/components/table/progressive-loading/items-loader.js
var import_react25 = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/progressive-loading/styles.css.js
import "/Users/shikaradee/raghu/GenAi/MachineLearning/reactapp/plat/frontend/node_modules/@cloudscape-design/components/table/progressive-loading/styles.scoped.css";
var styles_css_default10 = {
  "items-loader": "awsui_items-loader_115pt_16l07_5"
};

// node_modules/@cloudscape-design/components/table/progressive-loading/items-loader.js
function ItemsLoader({ item, trackBy, children }) {
  let parentTrackId = item && trackBy ? applyTrackBy(trackBy, item) : void 0;
  parentTrackId = typeof parentTrackId === "string" ? parentTrackId : void 0;
  return import_react25.default.createElement("div", { "data-root": item ? "false" : "true", "data-parentrow": parentTrackId, className: styles_css_default10["items-loader"] }, children);
}
function getLoaderContent({ item, loadingStatus, renderLoaderPending, renderLoaderLoading, renderLoaderError, renderLoaderEmpty }) {
  let content = null;
  if (loadingStatus === "pending" && renderLoaderPending) {
    content = renderLoaderPending({ item });
  } else if (loadingStatus === "loading" && renderLoaderLoading) {
    content = import_react25.default.createElement(internal_default2, { tagName: "span" }, renderLoaderLoading({ item }));
  } else if (loadingStatus === "error" && renderLoaderError) {
    content = import_react25.default.createElement(internal_default2, { tagName: "span" }, renderLoaderError({ item }));
  } else if (loadingStatus === "finished" && renderLoaderEmpty && item) {
    content = import_react25.default.createElement(internal_default2, { tagName: "span" }, renderLoaderEmpty({ item }));
  } else {
    warnOnce("Table", "Must define `renderLoaderPending`, `renderLoaderLoading`, `renderLoaderError`, or `renderLoaderEmpty` when using corresponding loading status.");
  }
  return content;
}

// node_modules/@cloudscape-design/components/table/progressive-loading/loader-cell.js
var import_react26 = __toESM(require_react());
function TableLoaderCell(_a) {
  var { item, trackBy, children } = _a, props = __rest(_a, ["item", "trackBy", "children"]);
  return import_react26.default.createElement(TableTdElement, Object.assign({}, props, { isEditable: false, isEditing: false }), props.isRowHeader ? import_react26.default.createElement(ItemsLoader, { item, trackBy }, children) : null);
}

// node_modules/@cloudscape-design/components/table/progressive-loading/progressive-loading-utils.js
function useProgressiveLoadingProps({ items, getLoadingStatus, getExpandableItemProps }) {
  const allRows = new Array();
  const getItemParent = (item) => getExpandableItemProps(item).parent;
  const getItemChildren = (item) => getExpandableItemProps(item).children;
  const getItemLevel = (item) => item ? getExpandableItemProps(item).level : 0;
  const isItemExpanded = (item) => getExpandableItemProps(item).isExpanded;
  for (let i = 0; i < items.length; i++) {
    allRows.push({ type: "data", item: items[i] });
    if (isItemExpanded(items[i]) && getItemChildren(items[i]).length === 0) {
      const status = getLoadingStatus === null || getLoadingStatus === void 0 ? void 0 : getLoadingStatus(items[i]);
      if (status === "loading" || status === "finished" || status === "error") {
        allRows.push({ type: "loader", item: items[i], level: getItemLevel(items[i]), status, from: 0 });
      } else {
        warnOnce("Table", 'Expanded items without children must have "loading", "finished", or "error" loading status.');
      }
    }
    let currentParent = getItemParent(items[i]);
    let levelsDiff = getItemLevel(items[i]) - getItemLevel(items[i + 1]);
    while (currentParent && levelsDiff > 0) {
      const status = getLoadingStatus === null || getLoadingStatus === void 0 ? void 0 : getLoadingStatus(currentParent);
      if (status && status !== "finished") {
        const level = currentParent ? getItemLevel(currentParent) : 0;
        const children = currentParent ? getItemChildren(currentParent) : [];
        allRows.push({ type: "loader", item: currentParent, level, status, from: children.length });
      }
      currentParent = currentParent && getItemParent(currentParent);
      levelsDiff--;
    }
    const rootLoadingStatus = getLoadingStatus === null || getLoadingStatus === void 0 ? void 0 : getLoadingStatus(null);
    if (i === items.length - 1 && rootLoadingStatus && rootLoadingStatus !== "finished") {
      allRows.push({ type: "loader", item: null, level: 0, status: rootLoadingStatus, from: items.length });
    }
  }
  return { allRows };
}

// node_modules/@cloudscape-design/components/table/resizer/index.js
var import_react28 = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/use-column-widths.js
var import_react27 = __toESM(require_react());
var DEFAULT_COLUMN_WIDTH = 120;
function readWidths(getCell, visibleColumns) {
  const result = /* @__PURE__ */ new Map();
  for (let index = 0; index < visibleColumns.length; index++) {
    const column = visibleColumns[index];
    let width = column.width || 0;
    const minWidth = column.minWidth || width || DEFAULT_COLUMN_WIDTH;
    if (!width && // read width from the DOM if it is missing in the config
    index !== visibleColumns.length - 1) {
      const colEl = getCell(column.id);
      width = colEl ? getLogicalBoundingClientRect(colEl).inlineSize : DEFAULT_COLUMN_WIDTH;
    }
    result.set(column.id, Math.max(width, minWidth));
  }
  return result;
}
function updateWidths(visibleColumns, oldWidths, newWidth, columnId) {
  const column = visibleColumns.find((column2) => column2.id === columnId);
  let minWidth = DEFAULT_COLUMN_WIDTH;
  if (typeof (column === null || column === void 0 ? void 0 : column.width) === "number" && column.width < DEFAULT_COLUMN_WIDTH) {
    minWidth = column === null || column === void 0 ? void 0 : column.width;
  }
  if (typeof (column === null || column === void 0 ? void 0 : column.minWidth) === "number") {
    minWidth = column === null || column === void 0 ? void 0 : column.minWidth;
  }
  newWidth = Math.max(newWidth, minWidth);
  if (oldWidths.get(columnId) === newWidth) {
    return oldWidths;
  }
  const newWidths = new Map(oldWidths);
  newWidths.set(columnId, newWidth);
  return newWidths;
}
var WidthsContext = (0, import_react27.createContext)({
  getColumnStyles: () => ({}),
  columnWidths: /* @__PURE__ */ new Map(),
  updateColumn: () => {
  },
  setCell: () => {
  }
});
function ColumnWidthsProvider({ visibleColumns, resizableColumns, containerRef, children }) {
  const visibleColumnsRef = (0, import_react27.useRef)(null);
  const containerWidthRef = (0, import_react27.useRef)(0);
  const [columnWidths, setColumnWidths] = (0, import_react27.useState)(null);
  const cellsRef = (0, import_react27.useRef)(/* @__PURE__ */ new Map());
  const stickyCellsRef = (0, import_react27.useRef)(/* @__PURE__ */ new Map());
  const getCell = (columnId) => {
    var _a;
    return (_a = cellsRef.current.get(columnId)) !== null && _a !== void 0 ? _a : null;
  };
  const setCell = (sticky, columnId, node) => {
    const ref = sticky ? stickyCellsRef : cellsRef;
    if (node) {
      ref.current.set(columnId, node);
    } else {
      ref.current.delete(columnId);
    }
  };
  const getColumnStyles = (sticky, columnId) => {
    var _a, _b, _c;
    const column = visibleColumns.find((column2) => column2.id === columnId);
    if (!column) {
      return {};
    }
    if (sticky) {
      return {
        width: ((_a = cellsRef.current.get(column.id)) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect().width) || ((_b = columnWidths === null || columnWidths === void 0 ? void 0 : columnWidths.get(column.id)) !== null && _b !== void 0 ? _b : column.width)
      };
    }
    if (resizableColumns && columnWidths) {
      const isLastColumn = column.id === ((_c = visibleColumns[visibleColumns.length - 1]) === null || _c === void 0 ? void 0 : _c.id);
      const totalWidth = visibleColumns.reduce((sum, { id }) => sum + (columnWidths.get(id) || DEFAULT_COLUMN_WIDTH), 0);
      if (isLastColumn && containerWidthRef.current > totalWidth) {
        return { width: "auto", minWidth: column === null || column === void 0 ? void 0 : column.minWidth };
      } else {
        return { width: columnWidths.get(column.id), minWidth: column === null || column === void 0 ? void 0 : column.minWidth };
      }
    }
    return {
      width: column.width,
      minWidth: column.minWidth,
      maxWidth: !resizableColumns ? column.maxWidth : void 0
    };
  };
  const updateColumnWidths = useStableCallback(() => {
    for (const { id } of visibleColumns) {
      const element = cellsRef.current.get(id);
      if (element) {
        setElementWidths(element, getColumnStyles(false, id));
      }
    }
    for (const { id } of visibleColumns) {
      const element = stickyCellsRef.current.get(id);
      if (element) {
        setElementWidths(element, getColumnStyles(true, id));
      }
    }
  });
  useResizeObserver(containerRef, ({ contentBoxWidth: containerWidth }) => {
    containerWidthRef.current = containerWidth;
    requestAnimationFrame(() => updateColumnWidths());
  });
  (0, import_react27.useEffect)(() => {
    updateColumnWidths();
    if (!resizableColumns) {
      return;
    }
    let updated = false;
    const newColumnWidths = new Map(columnWidths);
    const lastVisible = visibleColumnsRef.current;
    if (lastVisible) {
      for (let index = 0; index < visibleColumns.length; index++) {
        const column = visibleColumns[index];
        if (!(columnWidths === null || columnWidths === void 0 ? void 0 : columnWidths.get(column.id)) && lastVisible.indexOf(column.id) === -1) {
          updated = true;
          newColumnWidths.set(column.id, column.width || DEFAULT_COLUMN_WIDTH);
        }
      }
      if (updated) {
        setColumnWidths(newColumnWidths);
      }
    }
    visibleColumnsRef.current = visibleColumns.map((column) => column.id);
  }, [columnWidths, resizableColumns, visibleColumns, updateColumnWidths]);
  (0, import_react27.useEffect)(() => {
    if (!resizableColumns) {
      return;
    }
    setColumnWidths(() => readWidths(getCell, visibleColumns));
  }, []);
  function updateColumn(columnId, newWidth) {
    setColumnWidths((columnWidths2) => updateWidths(visibleColumns, columnWidths2 !== null && columnWidths2 !== void 0 ? columnWidths2 : /* @__PURE__ */ new Map(), newWidth, columnId));
  }
  return import_react27.default.createElement(WidthsContext.Provider, { value: { getColumnStyles, columnWidths: columnWidths !== null && columnWidths !== void 0 ? columnWidths : /* @__PURE__ */ new Map(), updateColumn, setCell } }, children);
}
function useColumnWidths() {
  return (0, import_react27.useContext)(WidthsContext);
}

// node_modules/@cloudscape-design/components/table/resizer/styles.css.js
import "/Users/shikaradee/raghu/GenAi/MachineLearning/reactapp/plat/frontend/node_modules/@cloudscape-design/components/table/resizer/styles.scoped.css";
var styles_css_default11 = {
  "resize-active": "awsui_resize-active_x7peu_m370p_145",
  "resize-active-with-focus": "awsui_resize-active-with-focus_x7peu_m370p_145",
  "divider": "awsui_divider_x7peu_m370p_150",
  "divider-interactive": "awsui_divider-interactive_x7peu_m370p_151",
  "divider-disabled": "awsui_divider-disabled_x7peu_m370p_165",
  "divider-interactive-disabled": "awsui_divider-interactive-disabled_x7peu_m370p_166",
  "divider-active": "awsui_divider-active_x7peu_m370p_169",
  "divider-interactive-active": "awsui_divider-interactive-active_x7peu_m370p_170",
  "is-visual-refresh": "awsui_is-visual-refresh_x7peu_m370p_174",
  "resizer": "awsui_resizer_x7peu_m370p_178",
  "has-focus": "awsui_has-focus_x7peu_m370p_228",
  "tracker": "awsui_tracker_x7peu_m370p_257"
};

// node_modules/@cloudscape-design/components/table/resizer/resizer-lookup.js
function getResizerElements(resizerElement) {
  if (!resizerElement) {
    return null;
  }
  const header = findUpUntil(resizerElement, (element) => element.tagName.toLowerCase() === "th");
  if (!header) {
    return null;
  }
  const tableRoot = findUpUntil(header, (element) => element.className.indexOf(styles_css_default4.root) > -1);
  if (!tableRoot) {
    return null;
  }
  const table = tableRoot.querySelector(`table`);
  if (!table) {
    return null;
  }
  const tracker = tableRoot.querySelector(`.${styles_css_default11.tracker}`);
  if (!tracker) {
    return null;
  }
  const scrollParent = getOverflowParents(header)[0];
  if (!scrollParent) {
    return null;
  }
  return { header, table, tracker, scrollParent };
}
function getHeaderWidth(resizerElement) {
  const header = resizerElement && findUpUntil(resizerElement, (element) => element.tagName.toLowerCase() === "th");
  return header ? getLogicalBoundingClientRect(header).inlineSize : 0;
}

// node_modules/@cloudscape-design/components/table/resizer/index.js
var AUTO_GROW_START_TIME = 10;
var AUTO_GROW_INTERVAL = 10;
var AUTO_GROW_INCREMENT = 5;
function Divider({ className }) {
  return import_react28.default.createElement("span", { className: clsx_m_default(styles_css_default11.divider, styles_css_default11["divider-disabled"], className) });
}
function Resizer({ onWidthUpdate, onWidthUpdateCommit, ariaLabelledby, minWidth = DEFAULT_COLUMN_WIDTH, tabIndex, showFocusRing, focusId, roleDescription }) {
  onWidthUpdate = useStableCallback(onWidthUpdate);
  onWidthUpdateCommit = useStableCallback(onWidthUpdateCommit);
  const isVisualRefresh = useVisualRefresh();
  const separatorId = useUniqueId();
  const resizerToggleRef = (0, import_react28.useRef)(null);
  const resizerSeparatorRef = (0, import_react28.useRef)(null);
  const [isDragging, setIsDragging] = (0, import_react28.useState)(false);
  const [isKeyboardDragging, setIsKeyboardDragging] = (0, import_react28.useState)(false);
  const autoGrowTimeout = (0, import_react28.useRef)();
  const [resizerHasFocus, setResizerHasFocus] = (0, import_react28.useState)(false);
  const [headerCellWidth, setHeaderCellWidth] = (0, import_react28.useState)(0);
  (0, import_react28.useEffect)(() => {
    setHeaderCellWidth(getHeaderWidth(resizerToggleRef.current));
  }, []);
  (0, import_react28.useEffect)(() => {
    var _a, _b;
    const elements = getResizerElements(resizerToggleRef.current);
    const document2 = (_b = (_a = resizerToggleRef.current) === null || _a === void 0 ? void 0 : _a.ownerDocument) !== null && _b !== void 0 ? _b : window.document;
    if (!isDragging && !resizerHasFocus || !elements) {
      return;
    }
    const { insetInlineStart: inlineStartEdge, insetInlineEnd: inlineEndEdge } = getLogicalBoundingClientRect(elements.scrollParent);
    const updateTrackerPosition = (newOffset) => {
      const { insetInlineStart: scrollParentInsetInlineStart } = getLogicalBoundingClientRect(elements.table);
      elements.tracker.style.insetBlockStart = getLogicalBoundingClientRect(elements.header).blockSize + "px";
      elements.tracker.style.insetInlineStart = newOffset - scrollParentInsetInlineStart - 1 + "px";
    };
    const updateColumnWidth = (newWidth) => {
      const { insetInlineEnd, inlineSize } = getLogicalBoundingClientRect(elements.header);
      const updatedWidth = newWidth < minWidth ? minWidth : newWidth;
      updateTrackerPosition(insetInlineEnd + updatedWidth - inlineSize);
      if (newWidth >= minWidth) {
        setHeaderCellWidth(newWidth);
      }
      onWidthUpdate(newWidth);
    };
    const resizeColumn = (offset) => {
      if (offset > inlineStartEdge) {
        const cellLeft = getLogicalBoundingClientRect(elements.header).insetInlineStart;
        const newWidth = offset - cellLeft;
        updateColumnWidth(newWidth);
      }
    };
    const onAutoGrow = () => {
      const inlineSize = getLogicalBoundingClientRect(elements.header).inlineSize;
      autoGrowTimeout.current = setTimeout(onAutoGrow, AUTO_GROW_INTERVAL);
      updateColumnWidth(inlineSize + AUTO_GROW_INCREMENT);
      elements.scrollParent.scrollLeft += AUTO_GROW_INCREMENT * (getIsRtl(elements.scrollParent) ? -1 : 1);
    };
    const onMouseMove = (event) => {
      clearTimeout(autoGrowTimeout.current);
      const offset = getLogicalPageX(event);
      if (offset > inlineEndEdge) {
        autoGrowTimeout.current = setTimeout(onAutoGrow, AUTO_GROW_START_TIME);
      } else {
        resizeColumn(offset);
      }
    };
    const onMouseUp = (event) => {
      resizeColumn(getLogicalPageX(event));
      setIsDragging(false);
      onWidthUpdateCommit();
      clearTimeout(autoGrowTimeout.current);
    };
    const onKeyDown = (event) => {
      if (isKeyboardDragging) {
        const keys = [KeyCode.left, KeyCode.right, KeyCode.enter, KeyCode.right, KeyCode.space, KeyCode.escape];
        if (keys.indexOf(event.keyCode) !== -1) {
          event.preventDefault();
          if (isEventLike(event)) {
            handleKey(event, {
              onActivate: () => {
                var _a2;
                setIsKeyboardDragging(false);
                (_a2 = resizerToggleRef.current) === null || _a2 === void 0 ? void 0 : _a2.focus();
              },
              onEscape: () => {
                var _a2;
                setIsKeyboardDragging(false);
                (_a2 = resizerToggleRef.current) === null || _a2 === void 0 ? void 0 : _a2.focus();
              },
              onInlineStart: () => updateColumnWidth(getLogicalBoundingClientRect(elements.header).inlineSize - 10),
              onInlineEnd: () => updateColumnWidth(getLogicalBoundingClientRect(elements.header).inlineSize + 10)
            });
          }
        }
      } else if (event.keyCode === KeyCode.enter || event.keyCode === KeyCode.space) {
        event.preventDefault();
        if (isEventLike(event)) {
          handleKey(event, {
            onActivate: () => {
              var _a2;
              setIsKeyboardDragging(true);
              (_a2 = resizerSeparatorRef.current) === null || _a2 === void 0 ? void 0 : _a2.focus();
            }
          });
        }
      }
    };
    updateTrackerPosition(getLogicalBoundingClientRect(elements.header).insetInlineEnd);
    const controller = new AbortController();
    if (isDragging) {
      document2.body.classList.add(styles_css_default11["resize-active"]);
      document2.addEventListener("mousemove", onMouseMove, { signal: controller.signal });
      document2.addEventListener("mouseup", onMouseUp, { signal: controller.signal });
    }
    if (resizerHasFocus) {
      document2.body.classList.add(styles_css_default11["resize-active-with-focus"]);
      elements.header.addEventListener("keydown", onKeyDown, { signal: controller.signal });
    }
    if (isKeyboardDragging) {
      document2.body.classList.add(styles_css_default11["resize-active"]);
    }
    return () => {
      clearTimeout(autoGrowTimeout.current);
      document2.body.classList.remove(styles_css_default11["resize-active"]);
      document2.body.classList.remove(styles_css_default11["resize-active-with-focus"]);
      controller.abort();
    };
  }, [minWidth, isDragging, isKeyboardDragging, resizerHasFocus, onWidthUpdate, onWidthUpdateCommit]);
  const { tabIndex: resizerTabIndex } = useSingleTabStopNavigation(resizerToggleRef, { tabIndex });
  return import_react28.default.createElement(
    import_react28.default.Fragment,
    null,
    import_react28.default.createElement("button", { ref: resizerToggleRef, className: clsx_m_default(styles_css_default11.resizer, (resizerHasFocus || showFocusRing || isKeyboardDragging) && styles_css_default11["has-focus"], isVisualRefresh && styles_css_default11["is-visual-refresh"]), onMouseDown: (event) => {
      if (event.button !== 0) {
        return;
      }
      event.preventDefault();
      setIsDragging(true);
    }, onClick: () => {
      var _a;
      setIsDragging(false);
      setResizerHasFocus(true);
      setIsKeyboardDragging(true);
      (_a = resizerSeparatorRef.current) === null || _a === void 0 ? void 0 : _a.focus();
    }, onFocus: () => {
      setHeaderCellWidth(getHeaderWidth(resizerToggleRef.current));
      setResizerHasFocus(true);
    }, onBlur: (event) => {
      if (event.relatedTarget !== resizerSeparatorRef.current) {
        setResizerHasFocus(false);
      }
    }, "aria-roledescription": roleDescription, "aria-labelledby": ariaLabelledby, tabIndex: resizerTabIndex, "data-focus-id": focusId }),
    import_react28.default.createElement("span", { className: clsx_m_default(styles_css_default11["divider-interactive"], isDragging && styles_css_default11["divider-active"], isVisualRefresh && styles_css_default11["is-visual-refresh"]), "data-awsui-table-suppress-navigation": true, ref: resizerSeparatorRef, id: separatorId, role: "slider", tabIndex: -1, "aria-labelledby": ariaLabelledby, "aria-hidden": !isKeyboardDragging, "aria-valuemin": minWidth, "aria-valuemax": Number.MAX_SAFE_INTEGER, "aria-valuenow": headerCellWidth, "data-focus-id": focusId, onBlur: () => {
      setResizerHasFocus(false);
      if (isKeyboardDragging) {
        setIsKeyboardDragging(false);
      }
      onWidthUpdateCommit();
    } })
  );
}
function ResizeTracker() {
  return import_react28.default.createElement("span", { className: styles_css_default11.tracker });
}

// node_modules/@cloudscape-design/components/table/selection/selection-control.js
var import_react33 = __toESM(require_react());

// node_modules/@cloudscape-design/components/checkbox/internal.js
var import_react31 = __toESM(require_react());

// node_modules/@cloudscape-design/components/internal/components/abstract-switch/index.js
var import_react29 = __toESM(require_react());

// node_modules/@cloudscape-design/components/internal/components/abstract-switch/analytics-metadata/styles.css.js
import "/Users/shikaradee/raghu/GenAi/MachineLearning/reactapp/plat/frontend/node_modules/@cloudscape-design/components/internal/components/abstract-switch/analytics-metadata/styles.scoped.css";
var styles_css_default12 = {
  "label": "awsui_label_13tpe_9w8pd_5",
  "native-input": "awsui_native-input_13tpe_9w8pd_6"
};

// node_modules/@cloudscape-design/components/internal/components/abstract-switch/styles.css.js
import "/Users/shikaradee/raghu/GenAi/MachineLearning/reactapp/plat/frontend/node_modules/@cloudscape-design/components/internal/components/abstract-switch/styles.scoped.css";
var styles_css_default13 = {
  "content": "awsui_content_1wepg_fp1bh_145",
  "description": "awsui_description_1wepg_fp1bh_146",
  "label": "awsui_label_1wepg_fp1bh_147",
  "outline": "awsui_outline_1wepg_fp1bh_155",
  "show-outline": "awsui_show-outline_1wepg_fp1bh_158",
  "native-input": "awsui_native-input_1wepg_fp1bh_162",
  "wrapper": "awsui_wrapper_1wepg_fp1bh_166",
  "label-wrapper": "awsui_label-wrapper_1wepg_fp1bh_172",
  "empty-content": "awsui_empty-content_1wepg_fp1bh_183",
  "description-bottom-padding": "awsui_description-bottom-padding_1wepg_fp1bh_193",
  "label-disabled": "awsui_label-disabled_1wepg_fp1bh_201",
  "description-disabled": "awsui_description-disabled_1wepg_fp1bh_202",
  "control": "awsui_control_1wepg_fp1bh_206"
};

// node_modules/@cloudscape-design/components/internal/components/abstract-switch/index.js
function joinString(values) {
  return values.filter((value) => !!value).join(" ");
}
function AbstractSwitch(_a) {
  var { controlId, controlClassName, outlineClassName, showOutline, disabled, readOnly, nativeControl, styledControl, label, description, descriptionBottomPadding, ariaLabel, ariaLabelledby, ariaDescribedby, ariaControls, onClick, __internalRootRef } = _a, rest = __rest(_a, ["controlId", "controlClassName", "outlineClassName", "showOutline", "disabled", "readOnly", "nativeControl", "styledControl", "label", "description", "descriptionBottomPadding", "ariaLabel", "ariaLabelledby", "ariaDescribedby", "ariaControls", "onClick", "__internalRootRef"]);
  const uniqueId = useUniqueId();
  const id = controlId || uniqueId;
  const labelId = `${id}-label`;
  const descriptionId = `${id}-description`;
  const ariaLabelledByIds = [];
  if (label && !ariaLabel) {
    ariaLabelledByIds.push(labelId);
  }
  if (ariaLabelledby) {
    ariaLabelledByIds.push(ariaLabelledby);
  }
  const ariaDescriptions = [];
  if (ariaDescribedby) {
    ariaDescriptions.push(ariaDescribedby);
  }
  if (description) {
    ariaDescriptions.push(descriptionId);
  }
  return import_react29.default.createElement(
    "span",
    Object.assign({}, rest, { className: clsx_m_default(styles_css_default13.wrapper, rest.className), ref: __internalRootRef }, getAnalyticsLabelAttribute(label ? `.${styles_css_default12.label}` : `.${styles_css_default12["native-input"]}`)),
    import_react29.default.createElement(
      "span",
      Object.assign({ className: styles_css_default13["label-wrapper"], "aria-disabled": disabled ? "true" : void 0, onClick: disabled || readOnly ? void 0 : onClick }, getAnalyticsMetadataAttribute(disabled || readOnly ? {} : {
        action: "select",
        detail: {
          label: label ? `.${styles_css_default12.label}` : `.${styles_css_default12["native-input"]}`
        }
      })),
      import_react29.default.createElement(
        "span",
        { className: clsx_m_default(styles_css_default13.control, controlClassName) },
        styledControl,
        nativeControl({
          id,
          disabled,
          className: clsx_m_default(styles_css_default13["native-input"], styles_css_default12["native-input"]),
          "aria-describedby": ariaDescriptions.length ? joinString(ariaDescriptions) : void 0,
          "aria-labelledby": ariaLabelledByIds.length ? joinString(ariaLabelledByIds) : void 0,
          "aria-label": ariaLabel,
          "aria-controls": ariaControls
        }),
        import_react29.default.createElement("span", { className: clsx_m_default(styles_css_default13.outline, outlineClassName, showOutline && styles_css_default13["show-outline"]) })
      ),
      import_react29.default.createElement(
        "span",
        { className: clsx_m_default(styles_css_default13.content, !label && !description && styles_css_default13["empty-content"]) },
        label && import_react29.default.createElement("span", { id: labelId, className: clsx_m_default(styles_css_default13.label, styles_css_default12.label, { [styles_css_default13["label-disabled"]]: disabled }) }, label),
        description && import_react29.default.createElement("span", { id: descriptionId, className: clsx_m_default(styles_css_default13.description, {
          [styles_css_default13["description-disabled"]]: disabled,
          [styles_css_default13["description-bottom-padding"]]: descriptionBottomPadding
        }) }, description)
      )
    )
  );
}

// node_modules/@cloudscape-design/components/internal/components/checkbox-icon/index.js
var import_react30 = __toESM(require_react());

// node_modules/@cloudscape-design/components/internal/components/checkbox-icon/styles.css.js
import "/Users/shikaradee/raghu/GenAi/MachineLearning/reactapp/plat/frontend/node_modules/@cloudscape-design/components/internal/components/checkbox-icon/styles.scoped.css";
var styles_css_default14 = {
  "root": "awsui_root_1fn7j_t5xe1_145",
  "styled-box": "awsui_styled-box_1fn7j_t5xe1_152",
  "styled-box-checked": "awsui_styled-box-checked_1fn7j_t5xe1_168",
  "styled-box-indeterminate": "awsui_styled-box-indeterminate_1fn7j_t5xe1_168",
  "styled-box-disabled": "awsui_styled-box-disabled_1fn7j_t5xe1_172",
  "styled-box-readonly": "awsui_styled-box-readonly_1fn7j_t5xe1_172",
  "styled-line": "awsui_styled-line_1fn7j_t5xe1_176",
  "styled-line-disabled": "awsui_styled-line-disabled_1fn7j_t5xe1_181",
  "styled-line-readonly": "awsui_styled-line-readonly_1fn7j_t5xe1_184"
};

// node_modules/@cloudscape-design/components/internal/components/checkbox-icon/index.js
var dimensionsByTheme = {
  default: {
    viewBox: "0 0 14 14",
    indeterminate: "2.5,7 11.5,7",
    checked: "2.5,7 6,10 11,3",
    xy: 0.5,
    r: 1.5,
    size: 13
  },
  refresh: {
    viewBox: "0 0 16 16",
    indeterminate: "3.5,8 12.5,8",
    checked: "3.5,8 7,11 12,4",
    xy: 0.5,
    r: 3,
    size: 15
  }
};
var CheckboxIcon = (_a) => {
  var { checked, indeterminate, disabled = false, readOnly = false } = _a, restProps = __rest(_a, ["checked", "indeterminate", "disabled", "readOnly"]);
  const baseProps = getBaseProps(restProps);
  const theme = useVisualRefresh() ? "refresh" : "default";
  const dimensions = dimensionsByTheme[theme];
  return import_react30.default.createElement(
    "svg",
    Object.assign({ className: styles_css_default14.root, viewBox: dimensions.viewBox, "aria-hidden": "true", focusable: "false" }, baseProps),
    import_react30.default.createElement("rect", { className: clsx_m_default(styles_css_default14["styled-box"], {
      [styles_css_default14["styled-box-checked"]]: checked,
      [styles_css_default14["styled-box-indeterminate"]]: indeterminate,
      [styles_css_default14["styled-box-disabled"]]: disabled,
      [styles_css_default14["styled-box-readonly"]]: readOnly
    }), x: dimensions.xy, y: dimensions.xy, rx: dimensions.r, ry: dimensions.r, width: dimensions.size, height: dimensions.size }),
    checked || indeterminate ? import_react30.default.createElement("polyline", { className: clsx_m_default(styles_css_default14["styled-line"], {
      [styles_css_default14["styled-line-disabled"]]: disabled,
      [styles_css_default14["styled-line-readonly"]]: readOnly
    }), points: indeterminate ? dimensions.indeterminate : dimensions.checked }) : null
  );
};
var checkbox_icon_default = CheckboxIcon;

// node_modules/@cloudscape-design/components/checkbox/styles.css.js
import "/Users/shikaradee/raghu/GenAi/MachineLearning/reactapp/plat/frontend/node_modules/@cloudscape-design/components/checkbox/styles.scoped.css";
var styles_css_default15 = {
  "root": "awsui_root_k2y2q_hm19d_145",
  "checkbox-control": "awsui_checkbox-control_k2y2q_hm19d_178",
  "outline": "awsui_outline_k2y2q_hm19d_186"
};

// node_modules/@cloudscape-design/components/checkbox/internal.js
var InternalCheckbox = import_react31.default.forwardRef((_a, ref) => {
  var { controlId, name, checked, disabled, readOnly, ariaRequired, indeterminate, children, description, ariaLabel, onFocus, onBlur, onChange, tabIndex: explicitTabIndex, showOutline, ariaControls, __internalRootRef, __injectAnalyticsComponentMetadata = false } = _a, rest = __rest(_a, ["controlId", "name", "checked", "disabled", "readOnly", "ariaRequired", "indeterminate", "children", "description", "ariaLabel", "onFocus", "onBlur", "onChange", "tabIndex", "showOutline", "ariaControls", "__internalRootRef", "__injectAnalyticsComponentMetadata"]);
  const { ariaDescribedby, ariaLabelledby } = useFormFieldContext(rest);
  const baseProps = getBaseProps(rest);
  const checkboxRef = (0, import_react31.useRef)(null);
  useForwardFocus(ref, checkboxRef);
  (0, import_react31.useEffect)(() => {
    if (checkboxRef.current) {
      checkboxRef.current.indeterminate = Boolean(indeterminate);
    }
  });
  const { tabIndex } = useSingleTabStopNavigation(checkboxRef, { tabIndex: explicitTabIndex });
  const analyticsMetadata = {};
  const analyticsComponentMetadata = {
    name: "awsui.Checkbox",
    label: { root: "self" }
  };
  if (__injectAnalyticsComponentMetadata) {
    analyticsMetadata.component = analyticsComponentMetadata;
  }
  if (!disabled && !readOnly) {
    analyticsMetadata.action = !checked ? "select" : "deselect";
  }
  return import_react31.default.createElement(AbstractSwitch, Object.assign({}, baseProps, { className: clsx_m_default(styles_css_default15.root, baseProps.className), controlClassName: styles_css_default15["checkbox-control"], outlineClassName: styles_css_default15.outline, controlId, disabled, readOnly, label: children, description, descriptionBottomPadding: true, ariaLabel, ariaLabelledby, ariaDescribedby, ariaControls, showOutline, nativeControl: (nativeControlProps) => import_react31.default.createElement("input", Object.assign({}, nativeControlProps, {
    ref: checkboxRef,
    type: "checkbox",
    checked,
    name,
    "aria-required": ariaRequired ? "true" : void 0,
    "aria-disabled": readOnly && !disabled ? "true" : void 0,
    tabIndex,
    onFocus: () => fireNonCancelableEvent(onFocus),
    onBlur: () => fireNonCancelableEvent(onBlur),
    // empty handler to suppress React controllability warning
    onChange: () => {
    }
  })), onClick: () => {
    var _a2;
    (_a2 = checkboxRef.current) === null || _a2 === void 0 ? void 0 : _a2.focus();
    fireNonCancelableEvent(
      onChange,
      // for deterministic transitions "indeterminate" -> "checked" -> "unchecked"
      indeterminate ? { checked: true, indeterminate: false } : { checked: !checked, indeterminate: false }
    );
  }, styledControl: import_react31.default.createElement(checkbox_icon_default, { checked, indeterminate, disabled, readOnly }), __internalRootRef }, getAnalyticsMetadataAttribute(analyticsMetadata)));
});
var internal_default6 = InternalCheckbox;

// node_modules/@cloudscape-design/components/radio-group/radio-button.js
var import_react32 = __toESM(require_react());

// node_modules/@cloudscape-design/components/radio-group/styles.css.js
import "/Users/shikaradee/raghu/GenAi/MachineLearning/reactapp/plat/frontend/node_modules/@cloudscape-design/components/radio-group/styles.scoped.css";
var styles_css_default16 = {
  "root": "awsui_root_1mabk_es0cz_145",
  "radio": "awsui_radio_1mabk_es0cz_178",
  "radio--has-description": "awsui_radio--has-description_1mabk_es0cz_186",
  "radio-control": "awsui_radio-control_1mabk_es0cz_190",
  "outline": "awsui_outline_1mabk_es0cz_198",
  "styled-circle-border": "awsui_styled-circle-border_1mabk_es0cz_220",
  "styled-circle-disabled": "awsui_styled-circle-disabled_1mabk_es0cz_224",
  "styled-circle-readonly": "awsui_styled-circle-readonly_1mabk_es0cz_224",
  "styled-circle-fill": "awsui_styled-circle-fill_1mabk_es0cz_229",
  "styled-circle-checked": "awsui_styled-circle-checked_1mabk_es0cz_245"
};

// node_modules/@cloudscape-design/components/radio-group/radio-button.js
var radio_button_default = import_react32.default.forwardRef(function RadioButton(_a, ref) {
  var { name, label, value, checked, description, disabled, controlId, onChange, readOnly, className } = _a, rest = __rest(_a, ["name", "label", "value", "checked", "description", "disabled", "controlId", "onChange", "readOnly", "className"]);
  const radioButtonRef = (0, import_react32.useRef)(null);
  const mergedRefs = useMergeRefs(radioButtonRef, ref);
  const { tabIndex } = useSingleTabStopNavigation(radioButtonRef);
  return import_react32.default.createElement(AbstractSwitch, Object.assign({ className: clsx_m_default(styles_css_default16.radio, description && styles_css_default16["radio--has-description"], className), controlClassName: styles_css_default16["radio-control"], outlineClassName: styles_css_default16.outline, label, description, disabled, readOnly, controlId }, copyAnalyticsMetadataAttribute(rest), { nativeControl: (nativeControlProps) => import_react32.default.createElement("input", Object.assign({}, nativeControlProps, {
    tabIndex,
    type: "radio",
    ref: mergedRefs,
    name,
    value,
    checked,
    "aria-disabled": readOnly && !disabled ? "true" : void 0,
    // empty handler to suppress React controllability warning
    onChange: () => {
    }
  })), onClick: () => {
    var _a2;
    (_a2 = radioButtonRef.current) === null || _a2 === void 0 ? void 0 : _a2.focus();
    if (checked) {
      return;
    }
    fireNonCancelableEvent(onChange, { value });
  }, styledControl: import_react32.default.createElement(
    "svg",
    { viewBox: "0 0 100 100", focusable: "false", "aria-hidden": "true" },
    import_react32.default.createElement("circle", { className: clsx_m_default(styles_css_default16["styled-circle-border"], {
      [styles_css_default16["styled-circle-disabled"]]: disabled,
      [styles_css_default16["styled-circle-readonly"]]: readOnly
    }), strokeWidth: 6.25, cx: 50, cy: 50, r: 46 }),
    import_react32.default.createElement("circle", { className: clsx_m_default(styles_css_default16["styled-circle-fill"], {
      [styles_css_default16["styled-circle-disabled"]]: disabled,
      [styles_css_default16["styled-circle-checked"]]: checked,
      [styles_css_default16["styled-circle-readonly"]]: readOnly
    }), strokeWidth: 30, cx: 50, cy: 50, r: 35 })
  ) }));
});

// node_modules/@cloudscape-design/components/table/selection/styles.css.js
import "/Users/shikaradee/raghu/GenAi/MachineLearning/reactapp/plat/frontend/node_modules/@cloudscape-design/components/table/selection/styles.scoped.css";
var styles_css_default17 = {
  "root": "awsui_root_1s55x_14pps_145",
  "label": "awsui_label_1s55x_14pps_149",
  "label-top": "awsui_label-top_1s55x_14pps_163",
  "stud": "awsui_stud_1s55x_14pps_168"
};

// node_modules/@cloudscape-design/components/table/selection/selection-control.js
function SelectionControl(_a) {
  var { selectionType, indeterminate = false, onShiftToggle, onFocusUp, onFocusDown, name, ariaLabel, focusedComponent, rowIndex, itemKey, verticalAlign = "middle" } = _a, sharedProps = __rest(_a, ["selectionType", "indeterminate", "onShiftToggle", "onFocusUp", "onFocusDown", "name", "ariaLabel", "focusedComponent", "rowIndex", "itemKey", "verticalAlign"]);
  const controlId = useUniqueId();
  const isMultiSelection = selectionType === "multi";
  const { navigationActive } = (0, import_react33.useContext)(SingleTabStopNavigationContext);
  const setShiftState = (event) => {
    if (isMultiSelection) {
      onShiftToggle === null || onShiftToggle === void 0 ? void 0 : onShiftToggle(event.shiftKey);
    }
  };
  const onMouseDownHandler = (event) => {
    setShiftState(event);
    if (isMultiSelection) {
      event.preventDefault();
    }
  };
  const handleKeyDown = (event) => {
    setShiftState(event);
    if (isMultiSelection && !navigationActive) {
      if (event.keyCode === KeyCode.up) {
        event.preventDefault();
        onFocusUp === null || onFocusUp === void 0 ? void 0 : onFocusUp(event);
      }
      if (event.keyCode === KeyCode.down) {
        event.preventDefault();
        onFocusDown === null || onFocusDown === void 0 ? void 0 : onFocusDown(event);
      }
    }
  };
  const handleClick = (event) => {
    const target = event.currentTarget;
    const nativeInput = target.tagName === "INPUT" ? target : target.querySelector("input");
    nativeInput === null || nativeInput === void 0 ? void 0 : nativeInput.focus();
  };
  const selector = isMultiSelection ? import_react33.default.createElement(internal_default6, Object.assign({}, sharedProps, { showOutline: focusedComponent === "selection-control", controlId, "data-focus-id": "selection-control", indeterminate })) : import_react33.default.createElement(radio_button_default, Object.assign({}, sharedProps, { controlId, name, value: "", label: "" }));
  return import_react33.default.createElement(
    import_react33.default.Fragment,
    null,
    import_react33.default.createElement("label", Object.assign({ onKeyDown: handleKeyDown, onKeyUp: setShiftState, onMouseDown: onMouseDownHandler, onMouseUp: setShiftState, onClick: handleClick, htmlFor: controlId, className: clsx_m_default(styles_css_default17.label, styles_css_default17.root, verticalAlign === "top" && styles_css_default17["label-top"]), "aria-label": ariaLabel, title: ariaLabel }, rowIndex !== void 0 && !sharedProps.disabled ? getAnalyticsMetadataAttribute({
      detail: {
        position: `${rowIndex + 1}`,
        item: itemKey || ""
      }
    }) : {}), selector),
    import_react33.default.createElement("span", { className: styles_css_default17.stud, "aria-hidden": true }, " ")
  );
}

// node_modules/@cloudscape-design/components/table/selection/use-selection-focus-move.js
function useSelectionFocusMove(selectionType, totalItems) {
  if (selectionType !== "multi") {
    return {};
  }
  function moveFocus(sourceElement, fromIndex, direction) {
    let index = fromIndex;
    const rootContainer = findRootContainer(sourceElement);
    while (index >= -1 && index < totalItems) {
      index += direction;
      const control = findSelectionControlByIndex(rootContainer, index);
      if (control && !control.disabled) {
        control.focus();
        break;
      }
    }
  }
  const [moveFocusDown, moveFocusUp] = [1, -1].map((direction) => {
    return (event) => {
      const target = event.currentTarget;
      const itemNode = findUpUntil(target, (node) => node.dataset.selectionItem === "item");
      const fromIndex = Array.prototype.indexOf.call(itemNode.parentElement.children, itemNode);
      moveFocus(target, fromIndex, direction);
    };
  });
  return {
    moveFocusDown,
    moveFocusUp,
    moveFocus
  };
}
function findSelectionControlByIndex(rootContainer, index) {
  if (index === -1) {
    return rootContainer.querySelector(`[data-${SELECTION_ITEM}="all"] .${styles_css_default17.root} input`);
  }
  return rootContainer.querySelectorAll(`[data-${SELECTION_ITEM}="item"] .${styles_css_default17.root} input`)[index];
}
function findRootContainer(element) {
  return findUpUntil(element, (node) => node.dataset.selectionRoot === "true");
}

// node_modules/@cloudscape-design/components/table/selection/use-selection.js
var import_react34 = __toESM(require_react());
function useSelection(options) {
  const singleSelectionProps = useSingleSelection(options);
  const multiSelectionProps = useMultiSelection(options);
  return options.selectionType === "single" ? singleSelectionProps : multiSelectionProps;
}
function useSingleSelection({ ariaLabels, isItemDisabled = () => false, onSelectionChange, selectedItems = [], selectionType, trackBy, setLastUserAction }) {
  const selectionControlName = useUniqueId();
  if (selectionType !== "single") {
    return { isItemSelected: () => false };
  }
  const selectedSet = new ItemSet(trackBy, selectedItems.slice(0, 1));
  const isItemSelected = selectedSet.has.bind(selectedSet);
  const handleToggleItem = (item) => {
    if (!isItemDisabled(item) && !isItemSelected(item)) {
      fireNonCancelableEvent(onSelectionChange, { selectedItems: [item] });
      setLastUserAction === null || setLastUserAction === void 0 ? void 0 : setLastUserAction("selection");
    }
  };
  return {
    isItemSelected,
    getItemSelectionProps: (item) => {
      var _a;
      return {
        name: selectionControlName,
        selectionType: "single",
        disabled: isItemDisabled(item),
        checked: isItemSelected(item),
        onChange: () => handleToggleItem(item),
        ariaLabel: joinStrings(ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.selectionGroupLabel, (_a = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.itemSelectionLabel) === null || _a === void 0 ? void 0 : _a.call(ariaLabels, { selectedItems }, item))
      };
    }
  };
}
function useMultiSelection({ ariaLabels, isItemDisabled = () => false, items, loading, onSelectionChange, selectedItems = [], selectionType, trackBy, setLastUserAction }) {
  const selectionControlName = useUniqueId();
  const [shiftPressed, setShiftPressed] = (0, import_react34.useState)(false);
  const [lastClickedItem, setLastClickedItem] = (0, import_react34.useState)(null);
  if (selectionType !== "multi") {
    return { isItemSelected: () => false };
  }
  const selectedSet = new ItemSet(trackBy, selectedItems);
  const isItemSelected = selectedSet.has.bind(selectedSet);
  let allItemsDisabled = true;
  let allEnabledItemsSelected = true;
  for (const item of items) {
    allItemsDisabled = allItemsDisabled && isItemDisabled(item);
    allEnabledItemsSelected = allEnabledItemsSelected && (isItemSelected(item) || isItemDisabled(item));
  }
  const allItemsCheckboxSelected = selectedItems.length > 0 && allEnabledItemsSelected;
  const allItemsCheckboxIndeterminate = selectedItems.length > 0 && !allEnabledItemsSelected;
  const itemIndexesMap = /* @__PURE__ */ new Map();
  items.forEach((item, i) => itemIndexesMap.set(getTrackableValue(trackBy, item), i));
  const getShiftSelectedItems = (item) => {
    const lastClickedItemIndex = lastClickedItem ? itemIndexesMap.get(getTrackableValue(trackBy, lastClickedItem)) : void 0;
    if (lastClickedItemIndex !== void 0) {
      const currentItemIndex = itemIndexesMap.get(getTrackableValue(trackBy, item));
      const start = Math.min(currentItemIndex, lastClickedItemIndex);
      const end = Math.max(currentItemIndex, lastClickedItemIndex);
      return items.slice(start, end + 1);
    }
    return [item];
  };
  const selectItems = (requestedItems) => {
    const newSelectedItems = [...selectedItems];
    requestedItems.forEach((newItem) => {
      if (!isItemSelected(newItem) && !isItemDisabled(newItem)) {
        newSelectedItems.push(newItem);
      }
    });
    return newSelectedItems;
  };
  const deselectItems = (requestedItems) => {
    const requestedItemsSet = new ItemSet(trackBy, requestedItems);
    const newSelectedItems = [];
    selectedItems.forEach((selectedItem) => {
      const shouldUnselect = requestedItemsSet.has(selectedItem);
      if (!shouldUnselect || isItemDisabled(selectedItem)) {
        newSelectedItems.push(selectedItem);
      }
    });
    return newSelectedItems;
  };
  const handleToggleAll = () => {
    const newSelectedItems = allEnabledItemsSelected ? deselectItems(items) : selectItems(items);
    fireNonCancelableEvent(onSelectionChange, { selectedItems: newSelectedItems });
    setLastUserAction === null || setLastUserAction === void 0 ? void 0 : setLastUserAction("selection");
  };
  const handleToggleItem = (item) => {
    if (!isItemDisabled(item)) {
      const requestedItems = shiftPressed ? getShiftSelectedItems(item) : [item];
      const selectedItems2 = isItemSelected(item) ? deselectItems(requestedItems) : selectItems(requestedItems);
      fireNonCancelableEvent(onSelectionChange, { selectedItems: selectedItems2 });
      setLastClickedItem(item);
      setLastUserAction === null || setLastUserAction === void 0 ? void 0 : setLastUserAction("selection");
    }
  };
  return {
    isItemSelected,
    getSelectAllProps: () => {
      var _a;
      return {
        name: selectionControlName,
        selectionType: "multi",
        disabled: allItemsDisabled || !!loading,
        checked: allItemsCheckboxSelected,
        indeterminate: allItemsCheckboxIndeterminate,
        onChange: handleToggleAll,
        ariaLabel: joinStrings(ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.selectionGroupLabel, (_a = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.allItemsSelectionLabel) === null || _a === void 0 ? void 0 : _a.call(ariaLabels, { selectedItems })),
        selectionGroupLabel: ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.selectionGroupLabel
      };
    },
    getItemSelectionProps: (item) => {
      var _a;
      return {
        name: selectionControlName,
        selectionType: "multi",
        disabled: isItemDisabled(item),
        checked: isItemSelected(item),
        onChange: () => handleToggleItem(item),
        onShiftToggle: (value) => setShiftPressed(value),
        ariaLabel: joinStrings(ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.selectionGroupLabel, (_a = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.itemSelectionLabel) === null || _a === void 0 ? void 0 : _a.call(ariaLabels, { selectedItems }, item))
      };
    }
  };
}

// node_modules/@cloudscape-design/components/table/selection/selection-cell.js
var import_react37 = __toESM(require_react());

// node_modules/@cloudscape-design/components/internal/components/screenreader-only/index.js
var import_react35 = __toESM(require_react());

// node_modules/@cloudscape-design/components/internal/components/screenreader-only/styles.css.js
import "/Users/shikaradee/raghu/GenAi/MachineLearning/reactapp/plat/frontend/node_modules/@cloudscape-design/components/internal/components/screenreader-only/styles.scoped.css";
var styles_css_default18 = {
  "root": "awsui_root_xttbq_1rjuy_145"
};

// node_modules/@cloudscape-design/components/internal/components/screenreader-only/index.js
function ScreenreaderOnly(props) {
  return import_react35.default.createElement("span", Object.assign({}, props, { className: clsx_m_default(styles_css_default18.root, props.className) }));
}

// node_modules/@cloudscape-design/components/table/header-cell/th-element.js
var import_react36 = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/header-cell/styles.css.js
import "/Users/shikaradee/raghu/GenAi/MachineLearning/reactapp/plat/frontend/node_modules/@cloudscape-design/components/table/header-cell/styles.scoped.css";
var styles_css_default19 = {
  "header-cell": "awsui_header-cell_1spae_wii4_149",
  "header-cell-fake-focus": "awsui_header-cell-fake-focus_1spae_wii4_183",
  "header-cell-sticky": "awsui_header-cell-sticky_1spae_wii4_204",
  "header-cell-stuck": "awsui_header-cell-stuck_1spae_wii4_207",
  "header-cell-variant-full-page": "awsui_header-cell-variant-full-page_1spae_wii4_207",
  "header-cell-hidden": "awsui_header-cell-hidden_1spae_wii4_213",
  "header-cell-variant-embedded": "awsui_header-cell-variant-embedded_1spae_wii4_216",
  "is-visual-refresh": "awsui_is-visual-refresh_1spae_wii4_216",
  "sticky-cell": "awsui_sticky-cell_1spae_wii4_216",
  "header-cell-variant-borderless": "awsui_header-cell-variant-borderless_1spae_wii4_216",
  "header-cell-sortable": "awsui_header-cell-sortable_1spae_wii4_219",
  "table-variant-full-page": "awsui_table-variant-full-page_1spae_wii4_240",
  "sticky-cell-pad-left": "awsui_sticky-cell-pad-left_1spae_wii4_243",
  "has-selection": "awsui_has-selection_1spae_wii4_243",
  "sticky-cell-last-inline-start": "awsui_sticky-cell-last-inline-start_1spae_wii4_246",
  "resize-divider": "awsui_resize-divider_1spae_wii4_251",
  "sticky-cell-last-inline-end": "awsui_sticky-cell-last-inline-end_1spae_wii4_258",
  "sorting-icon": "awsui_sorting-icon_1spae_wii4_268",
  "edit-icon": "awsui_edit-icon_1spae_wii4_276",
  "header-cell-content": "awsui_header-cell-content_1spae_wii4_282",
  "header-cell-content-expandable": "awsui_header-cell-content-expandable_1spae_wii4_288",
  "header-cell-disabled": "awsui_header-cell-disabled_1spae_wii4_340",
  "header-cell-sorted": "awsui_header-cell-sorted_1spae_wii4_340",
  "header-cell-text": "awsui_header-cell-text_1spae_wii4_354",
  "header-cell-text-wrap": "awsui_header-cell-text-wrap_1spae_wii4_358",
  "header-cell-ascending": "awsui_header-cell-ascending_1spae_wii4_364",
  "header-cell-descending": "awsui_header-cell-descending_1spae_wii4_365",
  "has-striped-rows": "awsui_has-striped-rows_1spae_wii4_479",
  "sticky-cell-pad-inline-start": "awsui_sticky-cell-pad-inline-start_1spae_wii4_479",
  "header-cell-resizable": "awsui_header-cell-resizable_1spae_wii4_491"
};

// node_modules/@cloudscape-design/components/table/header-cell/th-element.js
function TableThElement(_a) {
  var { resizableStyle, sortingStatus, sortingDisabled, focusedComponent, stuck, sticky, resizable, hidden, stripedRows, isSelection, colIndex, columnId, stickyState, cellRef, tableRole, children, variant, ariaLabel, tableVariant } = _a, props = __rest(_a, ["resizableStyle", "sortingStatus", "sortingDisabled", "focusedComponent", "stuck", "sticky", "resizable", "hidden", "stripedRows", "isSelection", "colIndex", "columnId", "stickyState", "cellRef", "tableRole", "children", "variant", "ariaLabel", "tableVariant"]);
  const isVisualRefresh = useVisualRefresh();
  const stickyStyles = useStickyCellStyles({
    stickyColumns: stickyState,
    columnId,
    getClassName: (props2) => getStickyClassNames(styles_css_default19, props2)
  });
  const cellRefObject = (0, import_react36.useRef)(null);
  const mergedRef = useMergeRefs(stickyStyles.ref, cellRef, cellRefObject);
  const { tabIndex: cellTabIndex } = useSingleTabStopNavigation(cellRefObject);
  return import_react36.default.createElement("th", Object.assign({ "data-focus-id": `header-${String(columnId)}`, className: clsx_m_default(styles_css_default19["header-cell"], styles_css_default19[`header-cell-variant-${variant}`], sticky && styles_css_default19["header-cell-sticky"], resizable && styles_css_default19["header-cell-resizable"], stuck && styles_css_default19["header-cell-stuck"], stripedRows && styles_css_default19["has-striped-rows"], isVisualRefresh && styles_css_default19["is-visual-refresh"], isSelection && clsx_m_default(styles_css_default4["selection-control"], styles_css_default4["selection-control-header"]), tableVariant && styles_css_default19[`table-variant-${tableVariant}`], {
    [styles_css_default19["header-cell-fake-focus"]]: focusedComponent === `header-${String(columnId)}`,
    [styles_css_default19["header-cell-sortable"]]: sortingStatus,
    [styles_css_default19["header-cell-sorted"]]: sortingStatus === "ascending" || sortingStatus === "descending",
    [styles_css_default19["header-cell-disabled"]]: sortingDisabled,
    [styles_css_default19["header-cell-ascending"]]: sortingStatus === "ascending",
    [styles_css_default19["header-cell-descending"]]: sortingStatus === "descending",
    [styles_css_default19["header-cell-hidden"]]: hidden
  }, stickyStyles.className), style: Object.assign(Object.assign({}, resizableStyle), stickyStyles.style), ref: mergedRef }, getTableColHeaderRoleProps({ tableRole, sortingStatus, colIndex }), { tabIndex: cellTabIndex === -1 ? void 0 : cellTabIndex }, copyAnalyticsMetadataAttribute(props), ariaLabel ? { "aria-label": ariaLabel } : {}), children);
}

// node_modules/@cloudscape-design/components/table/selection/selection-cell.js
function TableHeaderSelectionCell(_a) {
  var { focusedComponent, singleSelectionHeaderAriaLabel, getSelectAllProps, onFocusMove } = _a, props = __rest(_a, ["focusedComponent", "singleSelectionHeaderAriaLabel", "getSelectAllProps", "onFocusMove"]);
  const selectAllProps = getSelectAllProps ? getSelectAllProps() : void 0;
  return import_react37.default.createElement(
    TableThElement,
    Object.assign({}, props, { isSelection: true, colIndex: 0, focusedComponent, ariaLabel: selectAllProps === null || selectAllProps === void 0 ? void 0 : selectAllProps.selectionGroupLabel }, getAnalyticsMetadataAttribute({
      action: (selectAllProps === null || selectAllProps === void 0 ? void 0 : selectAllProps.checked) ? "deselectAll" : "selectAll"
    })),
    selectAllProps ? import_react37.default.createElement(SelectionControl, Object.assign({ onFocusDown: (event) => {
      onFocusMove(event.target, -1, 1);
    }, focusedComponent }, selectAllProps, props.sticky ? { tabIndex: -1 } : {})) : import_react37.default.createElement(ScreenreaderOnly, null, singleSelectionHeaderAriaLabel),
    import_react37.default.createElement(Divider, { className: styles_css_default4["resize-divider"] })
  );
}
function TableBodySelectionCell(_a) {
  var { selectionControlProps } = _a, props = __rest(_a, ["selectionControlProps"]);
  return import_react37.default.createElement(TableTdElement, Object.assign({}, props, { isSelection: true, wrapLines: false, isEditable: false, isEditing: false, colIndex: 0 }), selectionControlProps ? import_react37.default.createElement(SelectionControl, Object.assign({}, selectionControlProps, { verticalAlign: props.verticalAlign })) : null);
}

// node_modules/@cloudscape-design/components/table/sticky-header.js
var import_react41 = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/thead.js
var import_react39 = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/header-cell/index.js
var import_react38 = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/analytics-metadata/styles.css.js
import "/Users/shikaradee/raghu/GenAi/MachineLearning/reactapp/plat/frontend/node_modules/@cloudscape-design/components/table/analytics-metadata/styles.scoped.css";
var styles_css_default20 = {
  "header-cell-text": "awsui_header-cell-text_dpuyq_1id1o_5"
};

// node_modules/@cloudscape-design/components/table/header-cell/index.js
function TableHeaderCell({ tabIndex, column, activeSortingColumn, sortingDescending, sortingDisabled, wrapLines, focusedComponent, stuck, sticky, hidden, stripedRows, onClick, colIndex, updateColumn, resizableColumns, resizableStyle, onResizeFinish, isEditable, columnId, stickyState, cellRef, tableRole, resizerRoleDescription, isExpandable, hasDynamicContent, variant, tableVariant }) {
  var _a;
  const i18n = useInternalI18n("table");
  const sortable = !!column.sortingComparator || !!column.sortingField;
  const sorted = !!activeSortingColumn && isSorted(column, activeSortingColumn);
  const sortingStatus = getSortingStatus(sortable, sorted, !!sortingDescending, !!sortingDisabled);
  const handleClick = () => onClick({
    sortingColumn: column,
    isDescending: sorted ? !sortingDescending : false
  });
  const handleKeyPress = ({ nativeEvent: e }) => {
    if (e.keyCode === KeyCode.enter || e.keyCode === KeyCode.space) {
      e.preventDefault();
      handleClick();
    }
  };
  const headerId = useUniqueId("table-header-");
  const clickableHeaderRef = (0, import_react38.useRef)(null);
  const { tabIndex: clickableHeaderTabIndex } = useSingleTabStopNavigation(clickableHeaderRef, { tabIndex });
  const cellRefObject = (0, import_react38.useRef)(null);
  const cellRefCombined = useMergeRefs(cellRef, cellRefObject);
  useResizeObserver(hasDynamicContent ? cellRefObject : () => null, (entry) => {
    updateColumn(columnId, entry.borderBoxWidth);
  });
  return import_react38.default.createElement(
    TableThElement,
    Object.assign({ resizableStyle, cellRef: cellRefCombined, sortingStatus, sortingDisabled, focusedComponent, stuck, sticky, resizable: resizableColumns, hidden, stripedRows, colIndex, columnId, stickyState, tableRole, variant, tableVariant }, sortingDisabled ? {} : getAnalyticsMetadataAttribute({
      action: "sort",
      detail: {
        position: `${colIndex + 1}`,
        columnId: column.id ? `${column.id}` : "",
        label: `.${styles_css_default20["header-cell-text"]}`,
        sortingDescending: `${!sortingDescending}`
      }
    })),
    import_react38.default.createElement(
      "div",
      Object.assign({ ref: clickableHeaderRef, "data-focus-id": `sorting-control-${String(columnId)}`, className: clsx_m_default(styles_css_default19["header-cell-content"], {
        [styles_css_default19["header-cell-fake-focus"]]: focusedComponent === `sorting-control-${String(columnId)}`,
        [styles_css_default19["header-cell-content-expandable"]]: isExpandable
      }), "aria-label": column.ariaLabel ? column.ariaLabel({
        sorted,
        descending: sorted && !!sortingDescending,
        disabled: !!sortingDisabled
      }) : void 0 }, sortingStatus && !sortingDisabled ? {
        onKeyPress: handleKeyPress,
        tabIndex: clickableHeaderTabIndex,
        role: "button",
        onClick: handleClick
      } : {}),
      import_react38.default.createElement(
        "div",
        { className: clsx_m_default(styles_css_default19["header-cell-text"], styles_css_default20["header-cell-text"], wrapLines && styles_css_default19["header-cell-text-wrap"]), id: headerId },
        column.header,
        isEditable ? import_react38.default.createElement(
          "span",
          { className: styles_css_default19["edit-icon"] },
          import_react38.default.createElement(internal_default, { name: "edit", ariaLabel: i18n("columnDefinitions.editConfig.editIconAriaLabel", (_a = column.editConfig) === null || _a === void 0 ? void 0 : _a.editIconAriaLabel) })
        ) : null
      ),
      sortingStatus && import_react38.default.createElement(
        "span",
        { className: styles_css_default19["sorting-icon"] },
        import_react38.default.createElement(internal_default, { name: getSortingIconName(sortingStatus) })
      )
    ),
    resizableColumns ? import_react38.default.createElement(Resizer, { tabIndex, focusId: `resize-control-${String(columnId)}`, showFocusRing: focusedComponent === `resize-control-${String(columnId)}`, onWidthUpdate: (newWidth) => updateColumn(columnId, newWidth), onWidthUpdateCommit: onResizeFinish, ariaLabelledby: headerId, minWidth: typeof column.minWidth === "string" ? parseInt(column.minWidth) : column.minWidth, roleDescription: i18n("ariaLabels.resizerRoleDescription", resizerRoleDescription) }) : import_react38.default.createElement(Divider, { className: styles_css_default19["resize-divider"] })
  );
}

// node_modules/@cloudscape-design/components/table/thead.js
var Thead = import_react39.default.forwardRef(({ selectionType, getSelectAllProps, columnDefinitions, sortingColumn, sortingDisabled, sortingDescending, resizableColumns, variant, tableVariant, wrapLines, onFocusMove, onSortingChange, onResizeFinish, singleSelectionHeaderAriaLabel, stripedRows, sticky = false, hidden = false, stuck = false, stickyState, selectionColumnId: selectionColumnId2, focusedComponent, onFocusedComponentChange, tableRole, resizerRoleDescription, isExpandable, setLastUserAction }, outerRef) => {
  const { getColumnStyles, columnWidths, updateColumn, setCell } = useColumnWidths();
  const commonCellProps = {
    stuck,
    sticky,
    hidden,
    stripedRows,
    tableRole,
    variant,
    tableVariant,
    stickyState
  };
  return import_react39.default.createElement(
    "thead",
    { className: clsx_m_default(!hidden && styles_css_default4["thead-active"]) },
    import_react39.default.createElement(
      "tr",
      Object.assign({}, focusMarkers.all, { ref: outerRef, "aria-rowindex": 1 }, getTableHeaderRowRoleProps({ tableRole }), { onFocus: (event) => {
        var _a;
        const focusControlElement = findUpUntil(event.target, (element) => !!element.getAttribute("data-focus-id"));
        const focusId = (_a = focusControlElement === null || focusControlElement === void 0 ? void 0 : focusControlElement.getAttribute("data-focus-id")) !== null && _a !== void 0 ? _a : null;
        onFocusedComponentChange === null || onFocusedComponentChange === void 0 ? void 0 : onFocusedComponentChange(focusId);
      }, onBlur: () => onFocusedComponentChange === null || onFocusedComponentChange === void 0 ? void 0 : onFocusedComponentChange(null) }),
      selectionType ? import_react39.default.createElement(TableHeaderSelectionCell, Object.assign({}, commonCellProps, { focusedComponent, columnId: selectionColumnId2, getSelectAllProps, onFocusMove, singleSelectionHeaderAriaLabel })) : null,
      columnDefinitions.map((column, colIndex) => {
        const columnId = getColumnKey(column, colIndex);
        return import_react39.default.createElement(TableHeaderCell, Object.assign({}, commonCellProps, {
          key: columnId,
          tabIndex: sticky ? -1 : 0,
          focusedComponent,
          column,
          activeSortingColumn: sortingColumn,
          sortingDescending,
          sortingDisabled,
          wrapLines,
          colIndex: selectionType ? colIndex + 1 : colIndex,
          columnId,
          updateColumn,
          onResizeFinish: () => onResizeFinish(columnWidths),
          resizableColumns,
          resizableStyle: getColumnStyles(sticky, columnId),
          onClick: (detail) => {
            setLastUserAction("sorting");
            fireNonCancelableEvent(onSortingChange, detail);
          },
          isEditable: !!column.editConfig,
          cellRef: (node) => setCell(sticky, columnId, node),
          tableRole,
          resizerRoleDescription,
          // Expandable option is only applicable to the first data column of the table.
          // When present, the header content receives extra padding to match the first offset in the data cells.
          isExpandable: colIndex === 0 && isExpandable,
          hasDynamicContent: hidden && !resizableColumns && column.hasDynamicContent
        }));
      })
    )
  );
});
var thead_default = Thead;

// node_modules/@cloudscape-design/components/table/use-sticky-header.js
var import_react40 = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/sticky-scrolling.js
function stickyScrolling(containerRef, stickyRef) {
  const scrollToTop = () => {
    if (!containerRef.current || !stickyRef.current) {
      return;
    }
    const scrollingOffset = calculateScrollingOffset(containerRef.current, stickyRef.current);
    if (scrollingOffset > 0) {
      scrollUpBy(scrollingOffset, containerRef.current);
    }
  };
  const scrollToItem = (item) => {
    if (!item || !containerRef.current || !stickyRef.current) {
      return;
    }
    const stickyBottom = getLogicalBoundingClientRect(stickyRef.current).insetBlockEnd;
    const scrollingOffset = stickyBottom - getLogicalBoundingClientRect(item).insetBlockStart;
    if (scrollingOffset > 0) {
      scrollUpBy(scrollingOffset, containerRef.current);
    }
  };
  return {
    scrollToTop,
    scrollToItem
  };
}
function calculateScrollingOffset(container, sticky) {
  const stickyRect = getLogicalBoundingClientRect(sticky);
  const containerRect = getLogicalBoundingClientRect(container);
  return stickyRect.insetBlockStart - containerRect.insetBlockStart;
}
function scrollUpBy(amount, container) {
  const parent = getOverflowParents(container);
  if (parent.length) {
    parent[0].scrollTop -= amount;
  } else {
    window.scrollTo({ top: window.pageYOffset - amount });
  }
}

// node_modules/@cloudscape-design/components/table/use-sticky-header.js
var useStickyHeader = (tableRef, theadRef, secondaryTheadRef, secondaryTableRef, tableWrapperRef) => {
  const isMobile = useMobile();
  const syncColumnHeaderWidths = (0, import_react40.useCallback)(() => {
    if (tableRef.current && theadRef.current && secondaryTheadRef.current && secondaryTableRef.current && tableWrapperRef.current) {
      secondaryTableRef.current.style.inlineSize = `${tableRef.current.getBoundingClientRect().width}px`;
      tableWrapperRef.current.style.marginBlockStart = `-${theadRef.current.getBoundingClientRect().height}px`;
    }
  }, [theadRef, secondaryTheadRef, secondaryTableRef, tableWrapperRef, tableRef]);
  (0, import_react40.useLayoutEffect)(() => {
    syncColumnHeaderWidths();
  });
  useResizeObserver(theadRef, syncColumnHeaderWidths);
  const scrollToTop = () => {
    if (!isMobile && theadRef.current && secondaryTheadRef.current && tableWrapperRef.current) {
      const scrollDist = calculateScrollingOffset(theadRef.current, secondaryTheadRef.current);
      if (scrollDist > 0) {
        scrollUpBy(scrollDist, tableWrapperRef.current);
      }
    }
  };
  const { scrollToItem } = stickyScrolling(tableWrapperRef, secondaryTheadRef);
  const scrollToRow = (itemNode) => {
    if (!isMobile) {
      scrollToItem(itemNode);
    }
  };
  return { scrollToRow, scrollToTop };
};

// node_modules/@cloudscape-design/components/table/sticky-header.js
var sticky_header_default = (0, import_react41.forwardRef)(StickyHeader);
function StickyHeader({ variant, theadProps, wrapperRef, theadRef, secondaryWrapperRef, onScroll, tableRef, tableHasHeader, contentDensity, tableRole }, ref) {
  const secondaryTheadRef = (0, import_react41.useRef)(null);
  const secondaryTableRef = (0, import_react41.useRef)(null);
  const { isStuck } = (0, import_react41.useContext)(StickyHeaderContext);
  const [focusedComponent, setFocusedComponent] = (0, import_react41.useState)(null);
  const { scrollToRow, scrollToTop } = useStickyHeader(tableRef, theadRef, secondaryTheadRef, secondaryTableRef, wrapperRef);
  (0, import_react41.useImperativeHandle)(ref, () => ({
    scrollToTop,
    scrollToRow,
    setFocus: setFocusedComponent
  }));
  return import_react41.default.createElement(
    "div",
    {
      className: clsx_m_default(styles_css_default4["header-secondary"], styles_css_default4[`variant-${variant}`], {
        [styles_css_default4["table-has-header"]]: tableHasHeader
      }),
      "aria-hidden": true,
      // Prevents receiving focus in Firefox. Focus on the overflowing table is sufficient
      // to scroll the table horizontally
      tabIndex: -1,
      ref: secondaryWrapperRef,
      onScroll
    },
    import_react41.default.createElement(
      "table",
      Object.assign({ className: clsx_m_default(styles_css_default4.table, styles_css_default4["table-layout-fixed"], contentDensity === "compact" && getVisualContextClassname("compact-table")), ref: secondaryTableRef }, getTableRoleProps({ tableRole })),
      import_react41.default.createElement(thead_default, Object.assign({ ref: secondaryTheadRef, sticky: true, stuck: isStuck, focusedComponent }, theadProps))
    )
  );
}

// node_modules/@cloudscape-design/components/table/sticky-scrollbar/sticky-scrollbar.js
var import_react44 = __toESM(require_react());

// node_modules/@cloudscape-design/components/internal/hooks/use-intersection-observer/index.js
var import_react42 = __toESM(require_react());
function useIntersectionObserver({ initialState = false } = {}) {
  const observerRef = (0, import_react42.useRef)(null);
  const [isIntersecting, setIsIntersecting] = (0, import_react42.useState)(initialState);
  const ref = (0, import_react42.useCallback)((targetElement) => {
    if (typeof IntersectionObserver === "undefined") {
      return;
    }
    if (observerRef.current) {
      observerRef.current.disconnect();
    }
    if (targetElement) {
      let TopLevelIntersectionObserver = IntersectionObserver;
      try {
        if (window.top) {
          TopLevelIntersectionObserver = window.top.IntersectionObserver;
        }
      } catch (_a) {
      }
      observerRef.current = new TopLevelIntersectionObserver(([entry]) => setIsIntersecting(entry.isIntersecting));
      observerRef.current.observe(targetElement);
    }
  }, []);
  return { ref, isIntersecting };
}

// node_modules/@cloudscape-design/components/internal/utils/calculate-once.js
function calculateOnce(callback) {
  let result = void 0;
  return () => {
    if (result === void 0) {
      result = callback();
    }
    return result;
  };
}

// node_modules/@cloudscape-design/components/internal/utils/browser-scrollbar-size.js
var browserScrollbarSize = calculateOnce(() => {
  if (typeof document === "undefined") {
    return { width: 0, height: 0 };
  }
  const scrollDiv = document.createElement("div");
  scrollDiv.style.overflow = "scroll";
  scrollDiv.style.height = "100px";
  scrollDiv.style.width = "100px";
  scrollDiv.style.position = "absolute";
  scrollDiv.style.top = "-9999px";
  scrollDiv.style.left = "-9999px";
  document.body.appendChild(scrollDiv);
  const width = scrollDiv.offsetWidth - scrollDiv.clientWidth;
  const height = scrollDiv.offsetHeight - scrollDiv.clientHeight;
  document.body.removeChild(scrollDiv);
  return { width, height };
});

// node_modules/@cloudscape-design/components/table/sticky-scrollbar/use-sticky-scrollbar.js
var import_react43 = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/sticky-scrollbar/styles.css.js
import "/Users/shikaradee/raghu/GenAi/MachineLearning/reactapp/plat/frontend/node_modules/@cloudscape-design/components/table/sticky-scrollbar/styles.scoped.css";
var styles_css_default21 = {
  "sticky-scrollbar": "awsui_sticky-scrollbar_faqt8_105xs_181",
  "sticky-scrollbar-content": "awsui_sticky-scrollbar-content_faqt8_105xs_193",
  "sticky-scrollbar-visible": "awsui_sticky-scrollbar-visible_faqt8_105xs_196",
  "sticky-scrollbar-native-invisible": "awsui_sticky-scrollbar-native-invisible_faqt8_105xs_199",
  "sticky-scrollbar-offset": "awsui_sticky-scrollbar-offset_faqt8_105xs_202",
  "is-visual-refresh": "awsui_is-visual-refresh_faqt8_105xs_205"
};

// node_modules/@cloudscape-design/components/table/sticky-scrollbar/use-sticky-scrollbar.js
var updatePosition = (tableEl, wrapperEl, scrollbarEl, scrollbarContentEl, inScrollableContainer) => {
  if (!tableEl || !scrollbarEl || !wrapperEl) {
    return;
  }
  const { inlineSize: tableInlineSize } = getLogicalBoundingClientRect(tableEl);
  const { inlineSize: wrapperInlineSize } = getLogicalBoundingClientRect(wrapperEl);
  const scrollbarHeight = browserScrollbarSize().height;
  const areaIsScrollable = tableInlineSize > wrapperInlineSize;
  if (!areaIsScrollable) {
    scrollbarEl.classList.remove(styles_css_default21["sticky-scrollbar-visible"]);
  } else {
    if (!scrollbarEl.classList.contains(styles_css_default21["sticky-scrollbar-visible"])) {
      requestAnimationFrame(() => {
        scrollbarEl.scrollLeft = wrapperEl.scrollLeft;
      });
    }
    scrollbarEl.classList.add(styles_css_default21["sticky-scrollbar-visible"]);
    if (!scrollbarHeight) {
      scrollbarEl.classList.add(styles_css_default21["sticky-scrollbar-native-invisible"]);
    }
  }
  if (scrollbarHeight && scrollbarEl && scrollbarContentEl) {
    scrollbarEl.style.blockSize = `${scrollbarHeight}px`;
    scrollbarContentEl.style.blockSize = `${scrollbarHeight}px`;
  }
  if (tableEl && wrapperEl && scrollbarContentEl && scrollbarEl) {
    const wrapperElRect = getLogicalBoundingClientRect(wrapperEl);
    const tableElRect = getLogicalBoundingClientRect(tableEl);
    scrollbarEl.style.inlineSize = `${wrapperElRect.inlineSize}px`;
    scrollbarContentEl.style.inlineSize = `${tableElRect.inlineSize}px`;
    scrollbarEl.style.insetBlockEnd = inScrollableContainer ? "0px" : `var(${global_vars_default.stickyVerticalBottomOffset}, 0px)`;
  }
};
function useStickyScrollbar(scrollbarRef, scrollbarContentRef, tableRef, wrapperRef, offsetScrollbar) {
  const [inScrollableContainer, setInScrollableContainer] = (0, import_react43.useState)(false);
  const wrapperEl = wrapperRef.current;
  (0, import_react43.useEffect)(() => {
    if (wrapperEl) {
      setInScrollableContainer(!!getContainingBlock(wrapperEl) || !!getOverflowParents(wrapperEl)[0]);
    }
  }, [wrapperEl]);
  (0, import_react43.useEffect)(() => {
    if (wrapperRef.current && tableRef.current) {
      const observer = new ResizeObserver(() => {
        if (scrollbarContentRef.current) {
          updatePosition(tableRef.current, wrapperRef.current, scrollbarRef.current, scrollbarContentRef.current, inScrollableContainer);
        }
      });
      observer.observe(wrapperRef.current);
      observer.observe(tableRef.current);
      return () => {
        observer.disconnect();
      };
    }
  }, [scrollbarContentRef, scrollbarRef, tableRef, wrapperRef, inScrollableContainer, offsetScrollbar]);
  (0, import_react43.useEffect)(() => {
    const resizeHandler = () => {
      updatePosition(tableRef.current, wrapperRef.current, scrollbarRef.current, scrollbarContentRef.current, inScrollableContainer);
    };
    resizeHandler();
    window.addEventListener("resize", resizeHandler);
    return () => {
      window.removeEventListener("resize", resizeHandler);
    };
  }, [tableRef, wrapperRef, scrollbarRef, scrollbarContentRef, inScrollableContainer]);
}

// node_modules/@cloudscape-design/components/table/sticky-scrollbar/sticky-scrollbar.js
var sticky_scrollbar_default = (0, import_react44.forwardRef)(StickyScrollbar);
function StickyScrollbar({ wrapperRef, tableRef, onScroll, hasStickyColumns }, ref) {
  const isVisualRefresh = useVisualRefresh();
  const scrollbarRef = import_react44.default.useRef(null);
  const scrollbarContentRef = import_react44.default.useRef(null);
  const mergedRef = useMergeRefs(ref, scrollbarRef);
  const offsetScrollbar = hasStickyColumns || browserScrollbarSize().height === 0;
  useStickyScrollbar(scrollbarRef, scrollbarContentRef, tableRef, wrapperRef, offsetScrollbar);
  const { ref: stickyDetectionRef, isIntersecting: isStickyDetectionVisible } = useIntersectionObserver();
  return import_react44.default.createElement(
    import_react44.default.Fragment,
    null,
    import_react44.default.createElement(
      "div",
      { ref: mergedRef, className: clsx_m_default(styles_css_default21["sticky-scrollbar"], offsetScrollbar && styles_css_default21["sticky-scrollbar-offset"], isVisualRefresh && styles_css_default21["is-visual-refresh"]), onScroll, "data-stuck": !isStickyDetectionVisible },
      import_react44.default.createElement("div", { ref: scrollbarContentRef, className: styles_css_default21["sticky-scrollbar-content"] })
    ),
    import_react44.default.createElement("div", { ref: stickyDetectionRef, style: { position: "absolute", right: 0, bottom: 0, left: 0, height: 1 } })
  );
}

// node_modules/@cloudscape-design/components/table/tools-header.js
var import_react45 = __toESM(require_react());
function ToolsHeader({ header, filter, pagination, preferences, setLastUserAction }) {
  const [breakpoint, ref] = useContainerBreakpoints(["xs"]);
  const isHeaderString = typeof header === "string";
  const assignHeaderId = (0, import_react45.useContext)(CollectionLabelContext).assignId;
  const headingId = useUniqueId("heading");
  if (assignHeaderId !== void 0 && isHeaderString) {
    assignHeaderId(headingId);
  }
  const isSmall = breakpoint === "default";
  const hasTools = filter || pagination || preferences;
  return import_react45.default.createElement(
    import_react45.default.Fragment,
    null,
    isHeaderString ? import_react45.default.createElement("span", { id: headingId }, header) : header,
    hasTools && import_react45.default.createElement(
      "div",
      { ref, className: clsx_m_default(styles_css_default4.tools, isSmall && styles_css_default4["tools-small"]) },
      filter && import_react45.default.createElement("div", { className: styles_css_default4["tools-filtering"], onClickCapture: () => setLastUserAction === null || setLastUserAction === void 0 ? void 0 : setLastUserAction("filter"), onKeyDownCapture: () => setLastUserAction === null || setLastUserAction === void 0 ? void 0 : setLastUserAction("filter") }, filter),
      import_react45.default.createElement(
        "div",
        { className: styles_css_default4["tools-align-right"] },
        pagination && import_react45.default.createElement("div", { className: styles_css_default4["tools-pagination"], onClickCapture: () => setLastUserAction === null || setLastUserAction === void 0 ? void 0 : setLastUserAction("pagination") }, pagination),
        preferences && import_react45.default.createElement("div", { className: styles_css_default4["tools-preferences"], onClickCapture: () => setLastUserAction === null || setLastUserAction === void 0 ? void 0 : setLastUserAction("preferences") }, preferences)
      )
    )
  );
}

// node_modules/@cloudscape-design/components/table/use-cell-editing.js
var import_react46 = __toESM(require_react());
function useCellEditing({ onCancel, onSubmit }) {
  const [currentEditCell, setCurrentEditCell] = (0, import_react46.useState)(null);
  const [lastSuccessfulEditCell, setLastSuccessfulEditCell] = (0, import_react46.useState)(null);
  const [currentEditLoading, setCurrentEditLoading] = (0, import_react46.useState)(false);
  const startEdit = (cellId) => {
    setLastSuccessfulEditCell(null);
    setCurrentEditCell(cellId);
  };
  const cancelEdit = (0, import_react46.useCallback)(() => setCurrentEditCell(null), []);
  const completeEdit = (cellId, editCancelled) => {
    const eventCancelled = fireCancelableEvent(onCancel, {});
    if (!eventCancelled) {
      setCurrentEditCell(null);
      if (!editCancelled) {
        setLastSuccessfulEditCell(cellId);
      }
    }
  };
  const checkEditing = ({ row, col }) => row === (currentEditCell === null || currentEditCell === void 0 ? void 0 : currentEditCell.row) && col === currentEditCell.col;
  const checkLastSuccessfulEdit = ({ row, col }) => row === (lastSuccessfulEditCell === null || lastSuccessfulEditCell === void 0 ? void 0 : lastSuccessfulEditCell.row) && col === lastSuccessfulEditCell.col;
  const submitEdit = onSubmit ? (...args) => __awaiter(this, void 0, void 0, function* () {
    setCurrentEditLoading(true);
    try {
      yield onSubmit(...args);
    } finally {
      setCurrentEditLoading(false);
    }
  }) : void 0;
  return {
    isLoading: currentEditLoading,
    startEdit,
    cancelEdit,
    checkEditing,
    checkLastSuccessfulEdit,
    completeEdit,
    submitEdit
  };
}

// node_modules/@cloudscape-design/components/table/use-prevent-sticky-click-scroll.js
var import_react47 = __toESM(require_react());
var _ScrollLock_timeoutId;
var _ScrollLock_scrollLeft;
var _ScrollLock_active;
var stickyCellSelector = `.${styles_css_default5["sticky-cell"]}`;
var scrollLockTimeout = 50;
function usePreventStickyClickScroll(wrapperRefObject) {
  (0, import_react47.useEffect)(() => {
    if (wrapperRefObject.current) {
      const wrapperEl = wrapperRefObject.current;
      const scrollLock = new ScrollLock();
      const onClick = (event) => {
        if (event.target && event.target instanceof HTMLElement && (event.target.matches(stickyCellSelector) || event.target.closest(stickyCellSelector))) {
          scrollLock.set(wrapperEl.scrollLeft);
        }
      };
      wrapperEl.addEventListener("click", onClick);
      const onScroll = () => {
        if (scrollLock.active) {
          wrapperEl.scrollLeft = scrollLock.scrollLeft;
          scrollLock.clear();
        }
      };
      wrapperEl.addEventListener("scroll", onScroll);
      return () => {
        wrapperEl.removeEventListener("click", onClick);
        wrapperEl.removeEventListener("scroll", onScroll);
      };
    }
  }, [wrapperRefObject]);
}
var ScrollLock = class {
  constructor() {
    _ScrollLock_timeoutId.set(this, setTimeout(() => {
    }, 0));
    _ScrollLock_scrollLeft.set(this, 0);
    _ScrollLock_active.set(this, false);
  }
  set(scrollLeft) {
    if (!__classPrivateFieldGet(this, _ScrollLock_active, "f")) {
      __classPrivateFieldSet(this, _ScrollLock_active, true, "f");
      __classPrivateFieldSet(this, _ScrollLock_scrollLeft, scrollLeft, "f");
      __classPrivateFieldSet(this, _ScrollLock_timeoutId, setTimeout(() => __classPrivateFieldSet(this, _ScrollLock_active, false, "f"), scrollLockTimeout), "f");
    }
  }
  clear() {
    __classPrivateFieldSet(this, _ScrollLock_active, false, "f");
    clearTimeout(__classPrivateFieldGet(this, _ScrollLock_timeoutId, "f"));
  }
  get active() {
    return __classPrivateFieldGet(this, _ScrollLock_active, "f");
  }
  get scrollLeft() {
    return __classPrivateFieldGet(this, _ScrollLock_scrollLeft, "f");
  }
};
_ScrollLock_timeoutId = /* @__PURE__ */ new WeakMap(), _ScrollLock_scrollLeft = /* @__PURE__ */ new WeakMap(), _ScrollLock_active = /* @__PURE__ */ new WeakMap();

// node_modules/@cloudscape-design/components/table/use-row-events.js
function useRowEvents({ onRowClick, onRowContextMenu }) {
  const onRowClickHandler = (rowIndex, item, event) => {
    const tableCell = findUpUntil(event.target, (element) => element.tagName.toLowerCase() === "td");
    if (!tableCell || !tableCell.classList.contains(styles_css_default4["selection-control"])) {
      const details = { rowIndex, item };
      fireNonCancelableEvent(onRowClick, details);
    }
  };
  const onRowContextMenuHandler = (rowIndex, item, event) => {
    const details = {
      rowIndex,
      item,
      clientX: event.clientX,
      clientY: event.clientY
    };
    fireCancelableEvent(onRowContextMenu, details, event);
  };
  return {
    onRowClickHandler: onRowClick && onRowClickHandler,
    onRowContextMenuHandler: onRowContextMenu && onRowContextMenuHandler
  };
}

// node_modules/@cloudscape-design/components/table/use-table-focus-navigation.js
var import_react48 = __toESM(require_react());
function iterateTableCells(table, func) {
  table.querySelectorAll("tr").forEach((row, rowIndex) => {
    row.querySelectorAll("td").forEach((cell, cellIndex) => {
      func(cell, rowIndex, cellIndex);
    });
  });
}
function useTableFocusNavigation({ enableKeyboardNavigation, selectionType, tableRoot, columnDefinitions, numRows }) {
  const focusableColumns = (0, import_react48.useMemo)(() => {
    const cols = columnDefinitions.map((column) => !!column.editConfig);
    if (selectionType) {
      cols.unshift(false);
    }
    return cols;
  }, [columnDefinitions, selectionType]);
  const maxColumnIndex = focusableColumns.length - 1;
  const minColumnIndex = selectionType ? 1 : 0;
  const focusCell = (0, import_react48.useCallback)((rowIndex, columnIndex) => {
    if (tableRoot === null || tableRoot === void 0 ? void 0 : tableRoot.current) {
      iterateTableCells(tableRoot.current, (cell, rIndex, cIndex) => {
        var _a;
        if (rIndex === rowIndex && cIndex === columnIndex) {
          const editButton = cell.querySelector("button:last-child");
          if (editButton) {
            (_a = editButton.focus) === null || _a === void 0 ? void 0 : _a.call(editButton);
            scrollElementIntoView(editButton);
          }
        }
      });
    }
  }, [tableRoot]);
  const shiftFocus = (0, import_react48.useCallback)((vertical, horizontal) => {
    var _a;
    const focusedCell = (_a = tableRoot.current) === null || _a === void 0 ? void 0 : _a.querySelector("td:focus-within");
    if (!focusedCell) {
      return;
    }
    const columnIndex = focusedCell.cellIndex;
    const rowIndex = focusedCell.parentElement.rowIndex;
    let newRowIndex = rowIndex;
    let newColumnIndex = columnIndex;
    if (vertical !== 0) {
      newRowIndex = Math.min(numRows, Math.max(rowIndex + vertical, 0));
    }
    if (horizontal !== 0) {
      while (newColumnIndex <= maxColumnIndex && newColumnIndex >= minColumnIndex) {
        newColumnIndex += horizontal;
        if (focusableColumns[newColumnIndex]) {
          break;
        }
      }
    }
    if ((rowIndex !== newRowIndex || columnIndex !== newColumnIndex) && tableRoot.current) {
      focusCell(newRowIndex, newColumnIndex);
    }
  }, [focusCell, focusableColumns, maxColumnIndex, minColumnIndex, numRows, tableRoot]);
  const handleArrowKeyEvents = (0, import_react48.useCallback)((event) => {
    var _a, _b;
    const abort = !!((_a = tableRoot.current) === null || _a === void 0 ? void 0 : _a.querySelector('[data-inline-editing-active = "true"]')) || !((_b = document.activeElement) === null || _b === void 0 ? void 0 : _b.closest("[data-inline-editing-active]"));
    if (abort) {
      return;
    }
    switch (event.key) {
      case "ArrowUp":
        event.preventDefault();
        shiftFocus(-1, 0);
        break;
      case "ArrowDown":
        event.preventDefault();
        shiftFocus(1, 0);
        break;
      case "ArrowLeft":
        event.preventDefault();
        shiftFocus(0, -1);
        break;
      case "ArrowRight":
        event.preventDefault();
        shiftFocus(0, 1);
        break;
      default:
        return;
    }
  }, [shiftFocus, tableRoot]);
  (0, import_react48.useEffect)(() => {
    if (!tableRoot.current || enableKeyboardNavigation) {
      return;
    }
    const tableElement = tableRoot.current;
    tableRoot.current.addEventListener("keydown", handleArrowKeyEvents);
    return () => tableElement && tableElement.removeEventListener("keydown", handleArrowKeyEvents);
  }, [enableKeyboardNavigation, focusableColumns, handleArrowKeyEvents, tableRoot]);
}
var use_table_focus_navigation_default = useTableFocusNavigation;

// node_modules/@cloudscape-design/components/table/internal.js
var GRID_NAVIGATION_PAGE_SIZE = 10;
var SELECTION_COLUMN_WIDTH = 54;
var selectionColumnId = Symbol("selection-column-id");
var InternalTableAsSubstep = import_react49.default.forwardRef((props, ref) => {
  const { funnelSubStepProps } = useFunnelSubStep();
  const tableProps = Object.assign(Object.assign({}, props), { __funnelSubStepProps: funnelSubStepProps });
  return import_react49.default.createElement(InternalTable, Object.assign({}, tableProps, { ref }));
});
var InternalTable = import_react49.default.forwardRef((_a, ref) => {
  var _b, _c, _d;
  var { header, footer, empty, filter, pagination, preferences, items, columnDefinitions, trackBy, loading, loadingText, selectionType, selectedItems, isItemDisabled, ariaLabels, onSelectionChange, onSortingChange, sortingColumn, sortingDescending, sortingDisabled, visibleColumns, stickyHeader, stickyHeaderVerticalOffset, onRowClick, onRowContextMenu, wrapLines, stripedRows, contentDensity, submitEdit, onEditCancel, resizableColumns, onColumnWidthsChange, variant, __internalRootRef, totalItemsCount, firstIndex, renderAriaLive, stickyColumns, columnDisplay, enableKeyboardNavigation, expandableRows, getLoadingStatus, renderLoaderPending, renderLoaderLoading, renderLoaderError, renderLoaderEmpty, cellVerticalAlign, __funnelSubStepProps } = _a, rest = __rest(_a, ["header", "footer", "empty", "filter", "pagination", "preferences", "items", "columnDefinitions", "trackBy", "loading", "loadingText", "selectionType", "selectedItems", "isItemDisabled", "ariaLabels", "onSelectionChange", "onSortingChange", "sortingColumn", "sortingDescending", "sortingDisabled", "visibleColumns", "stickyHeader", "stickyHeaderVerticalOffset", "onRowClick", "onRowContextMenu", "wrapLines", "stripedRows", "contentDensity", "submitEdit", "onEditCancel", "resizableColumns", "onColumnWidthsChange", "variant", "__internalRootRef", "totalItemsCount", "firstIndex", "renderAriaLive", "stickyColumns", "columnDisplay", "enableKeyboardNavigation", "expandableRows", "getLoadingStatus", "renderLoaderPending", "renderLoaderLoading", "renderLoaderError", "renderLoaderEmpty", "cellVerticalAlign", "__funnelSubStepProps"]);
  if (expandableRows && enableKeyboardNavigation === void 0) {
    enableKeyboardNavigation = true;
  }
  const baseProps = getBaseProps(rest);
  const prevStickyHeader = usePrevious(stickyHeader);
  if (prevStickyHeader !== void 0 && !!stickyHeader !== !!prevStickyHeader) {
    warnOnce("Table", `\`stickyHeader\` has changed from "${prevStickyHeader}" to "${stickyHeader}". It is not recommended to change the value of this property during the component lifecycle. Please set it to either "true" or "false" unconditionally.`);
  }
  const isMobile = useMobile();
  const { isExpandable, allItems, getExpandableItemProps } = useExpandableTableProps({
    items,
    expandableRows,
    trackBy,
    ariaLabels
  });
  const { allRows } = useProgressiveLoadingProps({
    items: allItems,
    getLoadingStatus,
    getExpandableItemProps
  });
  const [containerWidth, wrapperMeasureRef] = useContainerQuery((rect) => rect.contentBoxWidth);
  const wrapperMeasureRefObject = (0, import_react49.useRef)(null);
  const wrapperMeasureMergedRef = useMergeRefs(wrapperMeasureRef, wrapperMeasureRefObject);
  const [tableWidth, tableMeasureRef] = useContainerQuery((rect) => rect.contentBoxWidth);
  const tableRefObject = (0, import_react49.useRef)(null);
  const secondaryWrapperRef = import_react49.default.useRef(null);
  const theadRef = (0, import_react49.useRef)(null);
  const stickyHeaderRef = import_react49.default.useRef(null);
  const scrollbarRef = import_react49.default.useRef(null);
  const _e = useCellEditing({ onCancel: onEditCancel, onSubmit: submitEdit }), { cancelEdit } = _e, cellEditing = __rest(_e, ["cancelEdit"]);
  const paginationRef = (0, import_react49.useRef)({});
  const filterRef = (0, import_react49.useRef)({});
  const preferencesRef = (0, import_react49.useRef)({});
  const headerRef = (0, import_react49.useRef)({});
  const getHeaderText = () => {
    var _a2, _b2, _c2, _d2;
    return (_c2 = (_b2 = (_a2 = toolsHeaderPerformanceMarkRef.current) === null || _a2 === void 0 ? void 0 : _a2.querySelector(`.${styles_css_default2["heading-text"]}`)) === null || _b2 === void 0 ? void 0 : _b2.innerText) !== null && _c2 !== void 0 ? _c2 : (_d2 = toolsHeaderPerformanceMarkRef.current) === null || _d2 === void 0 ? void 0 : _d2.innerText;
  };
  const getPatternIdentifier = () => {
    var _a2;
    const hasActions = !!((_a2 = toolsHeaderPerformanceMarkRef.current) === null || _a2 === void 0 ? void 0 : _a2.querySelector(`.${styles_css_default2.actions} .${styles_css_default.button}`));
    if (hasActions) {
      return "table-with-actions";
    }
    return "";
  };
  const performanceMarkAttributes = usePerformanceMarks("table", () => !loading, tableRefObject, () => ({
    loading: loading !== null && loading !== void 0 ? loading : false,
    header: getHeaderText()
  }), [loading]);
  const analyticsMetadata = getAnalyticsMetadataProps(rest);
  const interactionMetadata = () => {
    const filterData = filterRef.current;
    const paginationData = paginationRef.current;
    return JSON.stringify({
      filterData,
      paginationData,
      sortingColumn: sortingColumn === null || sortingColumn === void 0 ? void 0 : sortingColumn.sortingField,
      sortingOrder: sortingColumn ? sortingDescending ? "Descending" : "Ascending" : void 0
    });
  };
  const getComponentConfiguration = () => {
    var _a2, _b2, _c2, _d2, _e2, _f, _g, _h, _j, _k, _l;
    const headerData = headerRef.current;
    const filterData = filterRef.current;
    const paginationData = paginationRef.current;
    const preferencesData = preferencesRef.current;
    return {
      variant,
      flowType: (_a2 = rest.analyticsMetadata) === null || _a2 === void 0 ? void 0 : _a2.flowType,
      resourceType: (_b2 = rest.analyticsMetadata) === null || _b2 === void 0 ? void 0 : _b2.resourceType,
      instanceIdentifier: analyticsMetadata === null || analyticsMetadata === void 0 ? void 0 : analyticsMetadata.instanceIdentifier,
      taskName: (_c2 = analyticsMetadata === null || analyticsMetadata === void 0 ? void 0 : analyticsMetadata.instanceIdentifier) !== null && _c2 !== void 0 ? _c2 : getHeaderText(),
      uxTaskName: getHeaderText(),
      patternIdentifier: getPatternIdentifier(),
      sortedBy: {
        columnId: sortingColumn === null || sortingColumn === void 0 ? void 0 : sortingColumn.sortingField,
        sortingOrder: sortingColumn ? sortingDescending ? "desc" : "asc" : void 0
      },
      filtered: (_d2 = filterData === null || filterData === void 0 ? void 0 : filterData.filtered) !== null && _d2 !== void 0 ? _d2 : null,
      filteredBy: (_e2 = filterData === null || filterData === void 0 ? void 0 : filterData.filteredBy) !== null && _e2 !== void 0 ? _e2 : [],
      filteredCount: (_f = filterData === null || filterData === void 0 ? void 0 : filterData.filterCount) !== null && _f !== void 0 ? _f : null,
      totalNumberOfResources: (_g = headerData === null || headerData === void 0 ? void 0 : headerData.totalCount) !== null && _g !== void 0 ? _g : null,
      tablePreferences: {
        visibleColumns: (_h = preferencesData === null || preferencesData === void 0 ? void 0 : preferencesData.visibleColumns) !== null && _h !== void 0 ? _h : [],
        resourcesPerPage: (_j = preferencesData === null || preferencesData === void 0 ? void 0 : preferencesData.pageSize) !== null && _j !== void 0 ? _j : null
      },
      pagination: {
        currentPageIndex: (_k = paginationData === null || paginationData === void 0 ? void 0 : paginationData.currentPageIndex) !== null && _k !== void 0 ? _k : 0,
        totalNumberOfPages: (paginationData === null || paginationData === void 0 ? void 0 : paginationData.openEnd) ? null : (_l = paginationData === null || paginationData === void 0 ? void 0 : paginationData.totalPageCount) !== null && _l !== void 0 ? _l : null,
        openEnd: Boolean(paginationData === null || paginationData === void 0 ? void 0 : paginationData.openEnd)
      },
      resourcesSelected: (selectedItems === null || selectedItems === void 0 ? void 0 : selectedItems.length) > 0
    };
  };
  const { setLastUserAction, tableInteractionAttributes } = useTableInteractionMetrics({
    elementRef: tableRefObject,
    loading,
    items,
    instanceIdentifier: analyticsMetadata === null || analyticsMetadata === void 0 ? void 0 : analyticsMetadata.instanceIdentifier,
    itemCount: items.length,
    getComponentIdentifier: getHeaderText,
    getComponentConfiguration,
    interactionMetadata
  });
  (0, import_react49.useImperativeHandle)(ref, () => {
    var _a2;
    return {
      scrollToTop: ((_a2 = stickyHeaderRef.current) === null || _a2 === void 0 ? void 0 : _a2.scrollToTop) || (() => void 0),
      cancelEdit
    };
  }, [cancelEdit]);
  const wrapperRefObject = (0, import_react49.useRef)(null);
  const handleScroll = useScrollSync([wrapperRefObject, scrollbarRef, secondaryWrapperRef]);
  const { moveFocusDown, moveFocusUp, moveFocus } = useSelectionFocusMove(selectionType, allItems.length);
  const { onRowClickHandler, onRowContextMenuHandler } = useRowEvents({ onRowClick, onRowContextMenu });
  const visibleColumnDefinitions = getVisibleColumnDefinitions({
    columnDefinitions,
    columnDisplay,
    visibleColumns
  });
  const { isItemSelected, getSelectAllProps, getItemSelectionProps } = useSelection({
    items: allItems,
    trackBy,
    selectedItems,
    selectionType,
    isItemDisabled,
    onSelectionChange,
    ariaLabels: Object.assign(Object.assign({}, ariaLabels), {
      // `selectionGroupLabel` should not be part of the selection control, it is already part of the selection column header.
      selectionGroupLabel: void 0
    }),
    loading,
    setLastUserAction
  });
  const isRowSelected = (row) => row.type === "data" && isItemSelected(row.item);
  if (isDevelopment) {
    if (resizableColumns) {
      checkColumnWidths(columnDefinitions);
    }
    if (sortingColumn === null || sortingColumn === void 0 ? void 0 : sortingColumn.sortingComparator) {
      checkSortingState(columnDefinitions, sortingColumn.sortingComparator);
    }
  }
  const isVisualRefresh = useVisualRefresh();
  const computedVariant = isVisualRefresh ? variant : ["embedded", "full-page"].indexOf(variant) > -1 ? "container" : variant;
  const hasHeader = !!(header || filter || pagination || preferences);
  const hasSelection = !!selectionType;
  const hasFooterPagination = isMobile && variant === "full-page" && !!pagination;
  const hasFooter = !!footer || hasFooterPagination;
  const headerIdRef = (0, import_react49.useRef)(void 0);
  const isLabelledByHeader = !(ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.tableLabel) && !!header;
  const ariaLabelledby = isLabelledByHeader && headerIdRef.current ? headerIdRef.current : void 0;
  const setHeaderRef = (0, import_react49.useCallback)((id) => {
    headerIdRef.current = id;
  }, []);
  const visibleColumnWidthsWithSelection = [];
  const visibleColumnIdsWithSelection = [];
  if (hasSelection) {
    visibleColumnWidthsWithSelection.push({ id: selectionColumnId, width: SELECTION_COLUMN_WIDTH });
    visibleColumnIdsWithSelection.push(selectionColumnId);
  }
  for (let columnIndex = 0; columnIndex < visibleColumnDefinitions.length; columnIndex++) {
    const columnId = getColumnKey(visibleColumnDefinitions[columnIndex], columnIndex);
    visibleColumnWidthsWithSelection.push(Object.assign(Object.assign({}, visibleColumnDefinitions[columnIndex]), { id: columnId }));
    visibleColumnIdsWithSelection.push(columnId);
  }
  const stickyState = useStickyColumns({
    visibleColumns: visibleColumnIdsWithSelection,
    stickyColumnsFirst: ((_b = stickyColumns === null || stickyColumns === void 0 ? void 0 : stickyColumns.first) !== null && _b !== void 0 ? _b : 0) + ((stickyColumns === null || stickyColumns === void 0 ? void 0 : stickyColumns.first) && hasSelection ? 1 : 0),
    stickyColumnsLast: (stickyColumns === null || stickyColumns === void 0 ? void 0 : stickyColumns.last) || 0
  });
  const hasStickyColumns = !!(((_c = stickyColumns === null || stickyColumns === void 0 ? void 0 : stickyColumns.first) !== null && _c !== void 0 ? _c : 0) + ((_d = stickyColumns === null || stickyColumns === void 0 ? void 0 : stickyColumns.last) !== null && _d !== void 0 ? _d : 0) > 0);
  const hasEditableCells = !!columnDefinitions.find((col) => col.editConfig);
  let tableRole = "table";
  if (isExpandable) {
    tableRole = "treegrid";
  } else if (enableKeyboardNavigation) {
    tableRole = "grid";
  } else if (hasEditableCells) {
    tableRole = "grid-default";
  }
  const theadProps = {
    selectionType,
    getSelectAllProps,
    columnDefinitions: visibleColumnDefinitions,
    variant: computedVariant,
    tableVariant: computedVariant,
    wrapLines,
    resizableColumns,
    sortingColumn,
    sortingDisabled,
    sortingDescending,
    onSortingChange,
    onFocusMove: moveFocus,
    onResizeFinish(newWidth) {
      const widthsDetail = columnDefinitions.map((column, index) => newWidth.get(getColumnKey(column, index)) || column.width || DEFAULT_COLUMN_WIDTH);
      const widthsChanged = widthsDetail.some((width, index) => columnDefinitions[index].width !== width);
      if (widthsChanged) {
        fireNonCancelableEvent(onColumnWidthsChange, { widths: widthsDetail });
      }
    },
    singleSelectionHeaderAriaLabel: ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.selectionGroupLabel,
    resizerRoleDescription: ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.resizerRoleDescription,
    stripedRows,
    stickyState,
    selectionColumnId,
    tableRole,
    isExpandable,
    setLastUserAction
  };
  usePreventStickyClickScroll(wrapperRefObject);
  const wrapperRef = useMergeRefs(wrapperRefObject, stickyState.refs.wrapper);
  const tableRef = useMergeRefs(tableMeasureRef, tableRefObject, stickyState.refs.table);
  const wrapperProps = getTableWrapperRoleProps({
    tableRole,
    isScrollable: !!(tableWidth && containerWidth && tableWidth > containerWidth),
    ariaLabel: ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.tableLabel,
    ariaLabelledby
  });
  const getMouseDownTarget = useMouseDownTarget();
  use_table_focus_navigation_default({
    enableKeyboardNavigation,
    selectionType,
    tableRoot: tableRefObject,
    columnDefinitions: visibleColumnDefinitions,
    numRows: allRows === null || allRows === void 0 ? void 0 : allRows.length
  });
  const toolsHeaderPerformanceMarkRef = (0, import_react49.useRef)(null);
  const [toolsHeaderHeight, toolsHeaderWrapperMeasureRef] = useContainerQuery((rect) => rect.borderBoxHeight);
  const toolsHeaderWrapper = useMergeRefs(toolsHeaderPerformanceMarkRef, toolsHeaderWrapperMeasureRef);
  const colIndexOffset = selectionType ? 1 : 0;
  const totalColumnsCount = visibleColumnDefinitions.length + colIndexOffset;
  return import_react49.default.createElement(
    LinkDefaultVariantContext.Provider,
    { value: { defaultVariant: "primary" } },
    import_react49.default.createElement(
      TableComponentsContextProvider,
      { value: { paginationRef, filterRef, preferencesRef, headerRef } },
      import_react49.default.createElement(
        ColumnWidthsProvider,
        { visibleColumns: visibleColumnWidthsWithSelection, resizableColumns, containerRef: wrapperMeasureRefObject },
        import_react49.default.createElement(
          InternalContainer,
          Object.assign({}, baseProps, tableInteractionAttributes, { __internalRootRef, className: clsx_m_default(baseProps.className, styles_css_default4.root), __funnelSubStepProps, __fullPage: variant === "full-page", header: import_react49.default.createElement(
            import_react49.default.Fragment,
            null,
            hasHeader && import_react49.default.createElement(
              "div",
              null,
              import_react49.default.createElement(
                "div",
                { ref: toolsHeaderWrapper, className: clsx_m_default(styles_css_default4["header-controls"], styles_css_default4[`variant-${computedVariant}`]) },
                import_react49.default.createElement(
                  CollectionLabelContext.Provider,
                  { value: { assignId: setHeaderRef } },
                  import_react49.default.createElement(ToolsHeader, { header, filter, pagination, preferences, setLastUserAction })
                )
              )
            ),
            stickyHeader && import_react49.default.createElement(sticky_header_default, { ref: stickyHeaderRef, variant: computedVariant, theadProps, wrapperRef: wrapperRefObject, theadRef, secondaryWrapperRef, tableRef: tableRefObject, onScroll: handleScroll, tableHasHeader: hasHeader, contentDensity, tableRole })
          ), disableHeaderPaddings: true, disableContentPaddings: true, disableFooterPaddings: true, variant: toContainerVariant(computedVariant), __disableFooterDivider: true, __disableStickyMobile: false, footer: hasFooter ? import_react49.default.createElement(
            "div",
            { className: clsx_m_default(styles_css_default4["footer-wrapper"], styles_css_default4[`variant-${computedVariant}`]) },
            import_react49.default.createElement(
              "div",
              { className: clsx_m_default(styles_css_default4.footer, hasFooterPagination && styles_css_default4["footer-with-pagination"]) },
              footer && import_react49.default.createElement("span", null, footer),
              hasFooterPagination && import_react49.default.createElement("div", { className: styles_css_default4["footer-pagination"] }, pagination)
            )
          ) : null, __stickyHeader: stickyHeader, __mobileStickyOffset: toolsHeaderHeight !== null && toolsHeaderHeight !== void 0 ? toolsHeaderHeight : 0, __stickyOffset: stickyHeaderVerticalOffset }, focusMarkers.root),
          import_react49.default.createElement(
            "div",
            Object.assign({ ref: wrapperRef, className: clsx_m_default(styles_css_default4.wrapper, styles_css_default4[`variant-${computedVariant}`], {
              [styles_css_default4["has-footer"]]: hasFooter,
              [styles_css_default4["has-header"]]: hasHeader
            }), style: stickyState.style.wrapper, onScroll: handleScroll }, wrapperProps),
            import_react49.default.createElement("div", { className: styles_css_default4["wrapper-content-measure"], ref: wrapperMeasureMergedRef }),
            !!renderAriaLive && !!firstIndex && import_react49.default.createElement(
              internal_default2,
              { hidden: true, tagName: "span" },
              import_react49.default.createElement("span", null, renderAriaLive({
                firstIndex,
                lastIndex: firstIndex + items.length - 1,
                visibleItemsCount: allItems.length,
                totalItemsCount
              }))
            ),
            import_react49.default.createElement(
              GridNavigationProvider,
              { keyboardNavigation: !!enableKeyboardNavigation, pageSize: GRID_NAVIGATION_PAGE_SIZE, getTable: () => tableRefObject.current },
              import_react49.default.createElement(
                "table",
                Object.assign({}, performanceMarkAttributes, { ref: tableRef, className: clsx_m_default(styles_css_default4.table, resizableColumns && styles_css_default4["table-layout-fixed"], contentDensity === "compact" && getVisualContextClassname("compact-table")) }, getTableRoleProps({
                  tableRole,
                  totalItemsCount,
                  totalColumnsCount,
                  ariaLabel: ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.tableLabel,
                  ariaLabelledby
                })),
                import_react49.default.createElement(thead_default, Object.assign({ ref: theadRef, hidden: stickyHeader, onFocusedComponentChange: (focusId) => {
                  var _a2;
                  return (_a2 = stickyHeaderRef.current) === null || _a2 === void 0 ? void 0 : _a2.setFocus(focusId);
                } }, theadProps)),
                import_react49.default.createElement("tbody", null, loading || allItems.length === 0 ? import_react49.default.createElement(
                  "tr",
                  null,
                  import_react49.default.createElement(NoDataCell, { totalColumnsCount, hasFooter, loading, loadingText, empty, tableRef: tableRefObject, containerRef: wrapperMeasureRefObject })
                ) : allRows.map((row, rowIndex) => {
                  const isFirstRow = rowIndex === 0;
                  const isLastRow = rowIndex === allRows.length - 1;
                  const expandableProps = row.type === "data" ? getExpandableItemProps(row.item) : void 0;
                  const rowRoleProps = getTableRowRoleProps(Object.assign({
                    tableRole,
                    firstIndex,
                    rowIndex,
                    level: row.type === "loader" ? row.level : void 0
                  }, expandableProps));
                  const getTableItemKey = (item) => getItemKey(trackBy, item, rowIndex);
                  const sharedCellProps = {
                    isFirstRow,
                    isLastRow,
                    isSelected: hasSelection && isRowSelected(row),
                    isPrevSelected: hasSelection && !isFirstRow && isRowSelected(allRows[rowIndex - 1]),
                    isNextSelected: hasSelection && !isLastRow && isRowSelected(allRows[rowIndex + 1]),
                    isEvenRow: rowIndex % 2 === 0,
                    stripedRows,
                    hasSelection,
                    hasFooter,
                    stickyState,
                    tableRole
                  };
                  if (row.type === "data") {
                    const rowId = `${getTableItemKey(row.item)}`;
                    return import_react49.default.createElement(
                      "tr",
                      Object.assign({ key: rowId, className: clsx_m_default(styles_css_default4.row, sharedCellProps.isSelected && styles_css_default4["row-selected"]), onFocus: ({ currentTarget }) => {
                        var _a2;
                        if (!currentTarget.contains(getMouseDownTarget())) {
                          (_a2 = stickyHeaderRef.current) === null || _a2 === void 0 ? void 0 : _a2.scrollToRow(currentTarget);
                        }
                      } }, focusMarkers.item, { onClick: onRowClickHandler && onRowClickHandler.bind(null, rowIndex, row.item), onContextMenu: onRowContextMenuHandler && onRowContextMenuHandler.bind(null, rowIndex, row.item) }, rowRoleProps),
                      getItemSelectionProps && import_react49.default.createElement(TableBodySelectionCell, Object.assign({}, sharedCellProps, { columnId: selectionColumnId, selectionControlProps: Object.assign(Object.assign({}, getItemSelectionProps(row.item)), { onFocusDown: moveFocusDown, onFocusUp: moveFocusUp, rowIndex, itemKey: rowId }), verticalAlign: cellVerticalAlign, tableVariant: computedVariant })),
                      visibleColumnDefinitions.map((column, colIndex) => {
                        var _a2, _b2;
                        const colId = `${getColumnKey(column, colIndex)}`;
                        const cellId = { row: rowId, col: colId };
                        const isEditing = cellEditing.checkEditing(cellId);
                        const successfulEdit = cellEditing.checkLastSuccessfulEdit(cellId);
                        const isEditable = !!column.editConfig && !cellEditing.isLoading;
                        const cellExpandableProps = isExpandable && colIndex === 0 ? expandableProps : void 0;
                        const analyticsMetadata2 = {
                          component: {
                            innerContext: {
                              position: `${rowIndex + 1},${colIndex + 1}`,
                              columnId: column.id ? `${column.id}` : "",
                              columnLabel: {
                                selector: `table thead tr th:nth-child(${colIndex + (selectionType ? 2 : 1)})`,
                                root: "component"
                              },
                              item: rowId
                            }
                          }
                        };
                        return import_react49.default.createElement(TableBodyCell, Object.assign({ key: colId }, sharedCellProps, { resizableStyle: {
                          width: column.width,
                          minWidth: column.minWidth,
                          maxWidth: column.maxWidth
                        }, ariaLabels, column, item: row.item, wrapLines, isEditable, isEditing, isRowHeader: column.isRowHeader, successfulEdit, resizableColumns, onEditStart: () => cellEditing.startEdit(cellId), onEditEnd: (editCancelled) => cellEditing.completeEdit(cellId, editCancelled), submitEdit: cellEditing.submitEdit, columnId: (_a2 = column.id) !== null && _a2 !== void 0 ? _a2 : colIndex, colIndex: colIndex + colIndexOffset, verticalAlign: (_b2 = column.verticalAlign) !== null && _b2 !== void 0 ? _b2 : cellVerticalAlign, tableVariant: computedVariant }, cellExpandableProps, getAnalyticsMetadataAttribute(analyticsMetadata2)));
                      })
                    );
                  }
                  const loaderContent = getLoaderContent({
                    item: row.item,
                    loadingStatus: row.status,
                    renderLoaderPending,
                    renderLoaderLoading,
                    renderLoaderError,
                    renderLoaderEmpty
                  });
                  return loaderContent && import_react49.default.createElement(
                    "tr",
                    Object.assign({ key: (row.item ? getTableItemKey(row.item) : "root-" + rowIndex) + "-" + row.from, className: styles_css_default4.row }, rowRoleProps),
                    getItemSelectionProps && import_react49.default.createElement(TableBodySelectionCell, Object.assign({}, sharedCellProps, { columnId: selectionColumnId, verticalAlign: cellVerticalAlign, tableVariant: computedVariant })),
                    visibleColumnDefinitions.map((column, colIndex) => {
                      var _a2;
                      return import_react49.default.createElement(TableLoaderCell, Object.assign({ key: getColumnKey(column, colIndex) }, sharedCellProps, { wrapLines: false, columnId: (_a2 = column.id) !== null && _a2 !== void 0 ? _a2 : colIndex, colIndex: colIndex + colIndexOffset, isRowHeader: colIndex === 0, level: row.level, item: row.item, trackBy }), loaderContent);
                    })
                  );
                }))
              )
            ),
            resizableColumns && import_react49.default.createElement(ResizeTracker, null)
          ),
          import_react49.default.createElement(sticky_scrollbar_default, { ref: scrollbarRef, wrapperRef: wrapperRefObject, tableRef: tableRefObject, onScroll: handleScroll, hasStickyColumns })
        )
      )
    )
  );
});
var internal_default7 = InternalTable;

// node_modules/@cloudscape-design/components/table/index.js
var Table = import_react50.default.forwardRef((_a, ref) => {
  var _b, _c, _d;
  var { items = [], selectedItems = [], variant = "container", contentDensity = "comfortable", cellVerticalAlign = "middle", firstIndex = 1 } = _a, props = __rest(_a, ["items", "selectedItems", "variant", "contentDensity", "cellVerticalAlign", "firstIndex"]);
  const analyticsMetadata = getAnalyticsMetadataProps(props);
  const hasHiddenColumns = props.visibleColumns && props.visibleColumns.length < props.columnDefinitions.length || ((_b = props.columnDisplay) === null || _b === void 0 ? void 0 : _b.some((col) => !col.visible));
  const hasStickyColumns = !!((_c = props.stickyColumns) === null || _c === void 0 ? void 0 : _c.first) || !!((_d = props.stickyColumns) === null || _d === void 0 ? void 0 : _d.last);
  const baseComponentProps = useBaseComponent("Table", {
    props: {
      contentDensity,
      resizableColumns: props.resizableColumns,
      selectionType: props.selectionType,
      stickyHeader: props.stickyHeader,
      stripedRows: props.stripedRows,
      variant,
      wrapLines: props.wrapLines,
      enableKeyboardNavigation: props.enableKeyboardNavigation,
      totalItemsCount: props.totalItemsCount,
      flowType: analyticsMetadata.flowType,
      cellVerticalAlign
    },
    metadata: {
      expandableRows: !!props.expandableRows,
      progressiveLoading: !!props.getLoadingStatus,
      inlineEdit: props.columnDefinitions.some((def) => !!def.editConfig),
      disabledInlineEdit: props.columnDefinitions.some((def) => {
        var _a2;
        return !!((_a2 = def.editConfig) === null || _a2 === void 0 ? void 0 : _a2.disabledReason);
      }),
      hasSortableColumns: props.columnDefinitions.some((def) => def.sortingField || def.sortingComparator),
      hasHiddenColumns,
      hasStickyColumns,
      hasFilterSlot: !!props.filter,
      hasPaginationSlot: !!props.pagination,
      itemsCount: items.length,
      hasInstanceIdentifier: Boolean(analyticsMetadata === null || analyticsMetadata === void 0 ? void 0 : analyticsMetadata.instanceIdentifier),
      hasResourceType: Boolean(analyticsMetadata === null || analyticsMetadata === void 0 ? void 0 : analyticsMetadata.resourceType),
      usesVisibleColumns: !!props.visibleColumns,
      usesColumnDisplay: !!props.columnDisplay,
      usesColumnDefinitionsVerticalAlign: props.columnDefinitions.some((def) => def.verticalAlign !== cellVerticalAlign)
    }
  }, analyticsMetadata);
  const analyticsComponentMetadata = {
    name: "awsui.Table",
    label: { root: "self" },
    properties: {
      selectionType: props.selectionType || "none",
      itemsCount: `${items.length}`,
      selectedItemsCount: `${selectedItems.length}`,
      variant
    }
  };
  const sortingColumnId = getSortingColumnId(props.columnDefinitions, props.sortingColumn);
  if (sortingColumnId) {
    analyticsComponentMetadata.properties.sortingColumnId = sortingColumnId;
    analyticsComponentMetadata.properties.sortingDescending = `${props.sortingDescending || false}`;
  }
  const tableProps = Object.assign(Object.assign(Object.assign(Object.assign({
    items,
    selectedItems,
    variant,
    contentDensity,
    firstIndex,
    cellVerticalAlign
  }, props), baseComponentProps), { ref }), getAnalyticsMetadataAttribute({ component: analyticsComponentMetadata }));
  const collectionPreferencesMetadata = {
    tableContentDensity: contentDensity,
    tableHasStripedRows: !!props.stripedRows,
    tableHasHiddenColumns: hasHiddenColumns,
    tableHasStickyColumns: hasStickyColumns
  };
  if (variant === "borderless" || variant === "embedded") {
    return import_react50.default.createElement(
      CollectionPreferencesMetadata.Provider,
      { value: collectionPreferencesMetadata },
      import_react50.default.createElement(internal_default7, Object.assign({}, tableProps))
    );
  }
  return import_react50.default.createElement(
    CollectionPreferencesMetadata.Provider,
    { value: collectionPreferencesMetadata },
    import_react50.default.createElement(
      AnalyticsFunnelSubStep,
      null,
      import_react50.default.createElement(InternalTableAsSubstep, Object.assign({}, tableProps))
    )
  );
});
applyDisplayName(Table, "Table");
var table_default = Table;

export {
  getVisualContextClassname,
  VisualContext,
  defaultValue,
  LinkDefaultVariantContext,
  useContainerQuery,
  joinStrings,
  usePortalModeClasses,
  handleKey,
  browserScrollbarSize,
  ScreenreaderOnly,
  useIntersectionObserver,
  usePrevious,
  StatusIndicator,
  AsyncStore,
  useReaction,
  useSelector,
  useContainerBreakpoints,
  internal_default5 as internal_default,
  FormFieldContext,
  useFormFieldContext,
  padLeftZeros,
  styles_css_default7 as styles_css_default,
  FormFieldError,
  FormFieldWarning,
  ConstraintText,
  InternalFormField,
  checkbox_icon_default,
  useMouseDownTarget,
  AbstractSwitch,
  internal_default6 as internal_default2,
  styles_css_default16 as styles_css_default2,
  radio_button_default,
  SelectionControl,
  getItemKey,
  focusMarkers,
  useSelectionFocusMove,
  useSelection,
  stickyScrolling,
  ToolsHeader,
  CollectionPreferencesMetadata,
  ExpandToggleButton,
  internal_default7 as internal_default3,
  table_default
};
//# sourceMappingURL=chunk-XPQW5OPW.js.map

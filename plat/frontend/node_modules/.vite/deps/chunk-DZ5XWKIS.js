import {
  require_react
} from "./chunk-DRWLMN53.js";
import {
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/@cloudscape-design/collection-hooks/mjs/use-collection.js
var import_react2 = __toESM(require_react(), 1);

// node_modules/@cloudscape-design/collection-hooks/mjs/operations/filter.js
function defaultFilteringFunction(item, filteringText, filteringFields) {
  if (filteringText.length === 0) {
    return true;
  }
  filteringFields = filteringFields || Object.keys(item);
  const lowFilteringText = filteringText.toLowerCase();
  return filteringFields.some((key) => {
    const value = item[key];
    if (value && typeof value === "object") {
      return false;
    }
    return String(value).toLowerCase().indexOf(lowFilteringText) > -1;
  });
}
function createFilterPredicate(filtering, filteringText = "") {
  var _a;
  if (!filtering) {
    return null;
  }
  const filteringFunction = (_a = filtering.filteringFunction) !== null && _a !== void 0 ? _a : defaultFilteringFunction;
  return (item) => filteringFunction(item, filteringText, filtering.fields);
}

// node_modules/@cloudscape-design/collection-hooks/mjs/date-utils/parse-iso-date.js
function parseIsoDate(isoDate) {
  if (typeof isoDate === "string") {
    if (isoDate.includes("T")) {
      return new Date(isoDate);
    } else {
      return /* @__PURE__ */ new Date(isoDate + "T00:00:00");
    }
  }
  return /* @__PURE__ */ new Date(NaN);
}

// node_modules/@cloudscape-design/collection-hooks/mjs/date-utils/compare-dates.js
function compareDates(date, dateToCompare) {
  if (date instanceof Date && typeof dateToCompare === "string") {
    return startOfDay(date).getTime() - startOfDay(parseIsoDate(dateToCompare)).getTime();
  }
  return NaN;
}
function compareTimestamps(date, dateToCompare) {
  if (date instanceof Date && typeof dateToCompare === "string") {
    return date.getTime() - parseIsoDate(dateToCompare).getTime();
  }
  return NaN;
}
function startOfDay(date) {
  const copy = new Date(date.getTime());
  copy.setHours(0, 0, 0, 0);
  return copy;
}

// node_modules/@cloudscape-design/collection-hooks/mjs/logging.js
var isDevelopment = true;
var messageCache = /* @__PURE__ */ new Set();
function warnOnce(message) {
  if (isDevelopment) {
    const warning = `[AwsUi] collection-hooks ${message}`;
    if (!messageCache.has(warning)) {
      messageCache.add(warning);
      console.warn(warning);
    }
  }
}

// node_modules/@cloudscape-design/collection-hooks/mjs/operations/property-filter.js
var filterUsingOperator = (itemValue, { tokenValue, operator: { operator, match, tokenType } }) => {
  if (match === "date" || match === "datetime") {
    return matchDateValue({ tokenValue, itemValue, operator, match });
  } else if (typeof match === "function") {
    return match(itemValue, tokenValue);
  } else if (match) {
    throw new Error("Unsupported `operator.match` type given.");
  }
  return matchPrimitiveValue({ tokenValue, itemValue, operator, tokenType });
};
function matchDateValue({ tokenValue, itemValue, operator, match }) {
  const comparator = match === "date" ? compareDates : compareTimestamps;
  const comparisonResult = comparator(itemValue, tokenValue);
  switch (operator) {
    case "<":
      return comparisonResult < 0;
    case "<=":
      return comparisonResult <= 0;
    case ">":
      return comparisonResult > 0;
    case ">=":
      return comparisonResult >= 0;
    case "=":
      return comparisonResult === 0;
    case "!=":
      return comparisonResult !== 0;
    default:
      warnOnce(`Unsupported operator "${operator}" given for match="${match}".`);
      return false;
  }
}
function matchPrimitiveValue({ tokenValue, itemValue, operator, tokenType }) {
  if (tokenType === "enum") {
    if (!tokenValue || !Array.isArray(tokenValue)) {
      warnOnce('The token value must be an array when tokenType=="enum".');
      return false;
    }
    switch (operator) {
      case "=":
        return tokenValue && tokenValue.includes(itemValue);
      case "!=":
        return !tokenValue || !tokenValue.includes(itemValue);
      default:
        warnOnce(`Unsupported operator "${operator}" given for tokenType=="enum".`);
        return false;
    }
  }
  switch (operator) {
    case "<":
      return itemValue < tokenValue;
    case "<=":
      return itemValue <= tokenValue;
    case ">":
      return itemValue > tokenValue;
    case ">=":
      return itemValue >= tokenValue;
    case "=":
      return itemValue == tokenValue;
    case "!=":
      return itemValue != tokenValue;
    case ":":
      return (itemValue + "").toLowerCase().indexOf((tokenValue + "").toLowerCase()) > -1;
    case "!:":
      return (itemValue + "").toLowerCase().indexOf((tokenValue + "").toLowerCase()) === -1;
    case "^":
      return (itemValue + "").toLowerCase().startsWith((tokenValue + "").toLowerCase());
    case "!^":
      return !(itemValue + "").toLowerCase().startsWith((tokenValue + "").toLowerCase());
    default:
      throw new Error("Unsupported operator given.");
  }
}
function freeTextFilter(tokenValue, item, operator, filteringPropertiesMap) {
  const isNegation = operator.startsWith("!");
  return Object.keys(filteringPropertiesMap)[isNegation ? "every" : "some"]((propertyKey) => {
    const { operators } = filteringPropertiesMap[propertyKey];
    const propertyOperator = operators[operator];
    if (!propertyOperator) {
      return isNegation;
    }
    return filterUsingOperator(item[propertyKey], { tokenValue, operator: propertyOperator });
  });
}
function filterByToken(token, item, filteringPropertiesMap) {
  if (token.propertyKey) {
    if (!(token.propertyKey in filteringPropertiesMap) || !(token.operator in filteringPropertiesMap[token.propertyKey].operators)) {
      return false;
    }
    const property = filteringPropertiesMap[token.propertyKey];
    const operator = property.operators[token.operator];
    const itemValue = (operator === null || operator === void 0 ? void 0 : operator.match) ? item[token.propertyKey] : fixupFalsyValues(item[token.propertyKey]);
    return filterUsingOperator(itemValue, {
      tokenValue: token.value,
      operator: operator !== null && operator !== void 0 ? operator : { operator: token.operator }
    });
  }
  return freeTextFilter(token.value, item, token.operator, filteringPropertiesMap);
}
function defaultFilteringFunction2(filteringPropertiesMap) {
  return (item, query) => {
    var _a;
    function evaluate(tokenOrGroup) {
      if ("operation" in tokenOrGroup) {
        let result = tokenOrGroup.operation === "and" ? true : !tokenOrGroup.tokens.length;
        for (const group of tokenOrGroup.tokens) {
          result = tokenOrGroup.operation === "and" ? result && evaluate(group) : result || evaluate(group);
        }
        return result;
      } else {
        return filterByToken(tokenOrGroup, item, filteringPropertiesMap);
      }
    }
    return evaluate({
      operation: query.operation,
      tokens: (_a = query.tokenGroups) !== null && _a !== void 0 ? _a : query.tokens
    });
  };
}
function createPropertyFilterPredicate(propertyFiltering, query = { tokens: [], operation: "and" }) {
  if (!propertyFiltering) {
    return null;
  }
  const filteringPropertiesMap = propertyFiltering.filteringProperties.reduce((acc, { key, operators, defaultOperator }) => {
    const operatorMap = { [defaultOperator !== null && defaultOperator !== void 0 ? defaultOperator : "="]: { operator: defaultOperator !== null && defaultOperator !== void 0 ? defaultOperator : "=" } };
    operators === null || operators === void 0 ? void 0 : operators.forEach((op) => {
      if (typeof op === "string") {
        operatorMap[op] = { operator: op };
      } else {
        operatorMap[op.operator] = { operator: op.operator, match: op.match, tokenType: op.tokenType };
      }
    });
    acc[key] = { operators: operatorMap };
    return acc;
  }, {});
  const filteringFunction = propertyFiltering.filteringFunction || defaultFilteringFunction2(filteringPropertiesMap);
  return (item) => filteringFunction(item, query);
}
var fixupFalsyValues = (value) => {
  if (typeof value === "boolean") {
    return value + "";
  }
  if (value || value === 0) {
    return value;
  }
  return "";
};

// node_modules/@cloudscape-design/collection-hooks/mjs/operations/sort.js
function getSorter(sortingField) {
  if (!sortingField) {
    return null;
  }
  return (row1, row2) => {
    var _a, _b;
    const value1 = (_a = row1[sortingField]) !== null && _a !== void 0 ? _a : "";
    const value2 = (_b = row2[sortingField]) !== null && _b !== void 0 ? _b : "";
    if (typeof value1 === "string" && typeof value2 === "string") {
      return value1.localeCompare(value2);
    }
    return value1 < value2 ? -1 : value1 == value2 ? 0 : 1;
  };
}
function createComparator(sorting, state) {
  var _a;
  if (!sorting || !state) {
    return null;
  }
  const direction = state.isDescending ? -1 : 1;
  const comparator = (_a = state.sortingColumn.sortingComparator) !== null && _a !== void 0 ? _a : getSorter(state.sortingColumn.sortingField);
  return comparator ? (a, b) => comparator(a, b) * direction : null;
}

// node_modules/@cloudscape-design/collection-hooks/mjs/operations/pagination.js
var DEFAULT_PAGE_SIZE = 10;
function createPageProps(pagination, currentPageIndex, items) {
  var _a;
  if (!pagination) {
    return null;
  }
  const pageSize = (_a = pagination.pageSize) !== null && _a !== void 0 ? _a : DEFAULT_PAGE_SIZE;
  const pagesCount = Math.ceil(items.length / pageSize);
  let pageIndex = currentPageIndex !== null && currentPageIndex !== void 0 ? currentPageIndex : 1;
  if (pageIndex < 1 || pageIndex > pagesCount && !pagination.allowPageOutOfRange || Number.isNaN(pageIndex)) {
    pageIndex = 1;
  }
  return { pageSize, pagesCount, pageIndex };
}

// node_modules/@cloudscape-design/collection-hooks/mjs/operations/items-tree.js
var ItemsTree = class {
  constructor(items, treeProps) {
    var _a;
    this.size = 0;
    this.hasNesting = false;
    this.roots = new Array();
    this.idToChildren = /* @__PURE__ */ new Map();
    this.filter = (predicate) => {
      if (!this.hasNesting) {
        this.items = this.items.filter(predicate);
        this.size = this.items.length;
      } else {
        this.filterTree(predicate);
      }
      return this;
    };
    this.sort = (comparator) => {
      if (!this.hasNesting) {
        this.items = this.items.slice().sort(comparator);
      } else {
        this.sortTree(comparator);
      }
      return this;
    };
    this.getChildren = (item) => {
      var _a2;
      return (_a2 = this.treeProps && this.idToChildren.get(this.treeProps.getId(item))) !== null && _a2 !== void 0 ? _a2 : [];
    };
    this.getItems = () => {
      if (this.hasNesting) {
        return this.roots;
      }
      return this.items;
    };
    this.getSize = () => {
      return this.size;
    };
    this.filterTree = (predicate) => {
      const filterNode = (item) => {
        const children = this.getChildren(item);
        const filteredChildren = children.filter(filterNode);
        this.size -= children.length - filteredChildren.length;
        this.setChildren(item, filteredChildren);
        return predicate(item) || filteredChildren.length > 0;
      };
      const roots = this.roots;
      this.roots = this.roots.filter(filterNode);
      this.size -= roots.length - this.roots.length;
    };
    this.sortTree = (comparator) => {
      const sortLevel = (items2) => {
        items2.sort(comparator);
        for (const item of items2) {
          sortLevel(this.getChildren(item));
        }
      };
      sortLevel(this.roots);
    };
    this.size = items.length;
    this.items = items;
    this.treeProps = treeProps;
    if (!treeProps) {
      return;
    }
    for (const item of items) {
      const parentId = treeProps.getParentId(item);
      if (parentId === null) {
        this.roots.push(item);
      } else {
        const children = (_a = this.idToChildren.get(parentId)) !== null && _a !== void 0 ? _a : [];
        children.push(item);
        this.idToChildren.set(parentId, children);
        this.hasNesting = true;
      }
    }
    const traverse = (item, level = 1) => {
      var _a2;
      for (const child of (_a2 = this.idToChildren.get(treeProps.getId(item))) !== null && _a2 !== void 0 ? _a2 : []) {
        traverse(child, level + 1);
      }
    };
    this.roots.forEach((root) => traverse(root));
  }
  setChildren(item, children) {
    if (this.treeProps) {
      this.idToChildren.set(this.treeProps.getId(item), children);
    }
  }
};

// node_modules/@cloudscape-design/collection-hooks/mjs/operations/compose-filters.js
function composeFilters(...predicates) {
  return predicates.some(Boolean) ? (item) => {
    for (const predicate of predicates) {
      if (predicate && !predicate(item)) {
        return false;
      }
    }
    return true;
  } : null;
}

// node_modules/@cloudscape-design/collection-hooks/mjs/operations/index.js
function processItems(items, { filteringText, sortingState, currentPageIndex, propertyFilteringQuery }, { filtering, sorting, pagination, propertyFiltering, expandableRows }) {
  const itemsTree = new ItemsTree(items, expandableRows);
  const filterPredicate = composeFilters(createPropertyFilterPredicate(propertyFiltering, propertyFilteringQuery), createFilterPredicate(filtering, filteringText));
  if (filterPredicate) {
    itemsTree.filter(filterPredicate);
  }
  const comparator = createComparator(sorting, sortingState);
  if (comparator) {
    itemsTree.sort(comparator);
  }
  const allPageItems = itemsTree.getItems();
  const filteredItemsCount = filterPredicate ? itemsTree.getSize() : void 0;
  const pageProps = createPageProps(pagination, currentPageIndex, allPageItems);
  if (pageProps) {
    return {
      items: allPageItems.slice((pageProps.pageIndex - 1) * pageProps.pageSize, pageProps.pageIndex * pageProps.pageSize),
      allPageItems,
      filteredItemsCount,
      pagesCount: pageProps === null || pageProps === void 0 ? void 0 : pageProps.pagesCount,
      actualPageIndex: pageProps === null || pageProps === void 0 ? void 0 : pageProps.pageIndex,
      itemsTree
    };
  }
  return {
    items: allPageItems,
    allPageItems,
    filteredItemsCount,
    pagesCount: void 0,
    actualPageIndex: void 0,
    itemsTree
  };
}
var getTrackableValue = (trackBy, item) => {
  if (!trackBy) {
    return item;
  }
  if (typeof trackBy === "function") {
    return trackBy(item);
  }
  return item[trackBy];
};
var processSelectedItems = (items, selectedItems, trackBy) => {
  const selectedSet = /* @__PURE__ */ new Set();
  selectedItems.forEach((item) => selectedSet.add(getTrackableValue(trackBy, item)));
  return items.filter((item) => selectedSet.has(getTrackableValue(trackBy, item)));
};
var itemsAreEqual = (items1, items2, trackBy) => {
  if (items1.length !== items2.length) {
    return false;
  }
  const set1 = /* @__PURE__ */ new Set();
  items1.forEach((item) => set1.add(getTrackableValue(trackBy, item)));
  return items2.every((item) => set1.has(getTrackableValue(trackBy, item)));
};

// node_modules/@cloudscape-design/collection-hooks/mjs/utils.js
function collectionReducer(state, action) {
  const newState = Object.assign({}, state);
  switch (action.type) {
    case "selection":
      newState.selectedItems = action.selectedItems;
      break;
    case "expansion":
      newState.expandedItems = action.expandedItems;
      break;
    case "filtering":
      newState.currentPageIndex = 1;
      newState.filteringText = action.filteringText;
      break;
    case "sorting":
      newState.currentPageIndex = 1;
      newState.sortingState = action.sortingState;
      break;
    case "pagination":
      newState.currentPageIndex = action.pageIndex;
      break;
    case "property-filtering":
      newState.currentPageIndex = 1;
      newState.propertyFilteringQuery = action.query;
      break;
  }
  return newState;
}
function createActions({ dispatch, collectionRef }) {
  return {
    setFiltering(filteringText) {
      var _a;
      dispatch({ type: "filtering", filteringText });
      (_a = collectionRef.current) === null || _a === void 0 ? void 0 : _a.scrollToTop();
    },
    setSorting(state) {
      var _a;
      dispatch({ type: "sorting", sortingState: state });
      (_a = collectionRef.current) === null || _a === void 0 ? void 0 : _a.scrollToTop();
    },
    setCurrentPage(pageIndex) {
      var _a;
      dispatch({ type: "pagination", pageIndex });
      (_a = collectionRef.current) === null || _a === void 0 ? void 0 : _a.scrollToTop();
    },
    setSelectedItems(selectedItems) {
      dispatch({ type: "selection", selectedItems });
    },
    setPropertyFiltering(query) {
      var _a;
      dispatch({ type: "property-filtering", query });
      (_a = collectionRef.current) === null || _a === void 0 ? void 0 : _a.scrollToTop();
    },
    setExpandedItems(expandedItems) {
      dispatch({ type: "expansion", expandedItems });
    }
  };
}
function createSyncProps(options, { filteringText, sortingState, selectedItems, expandedItems, currentPageIndex, propertyFilteringQuery }, actions, collectionRef, { pagesCount, actualPageIndex, allItems, allPageItems, itemsTree }) {
  var _a, _b, _c, _d, _e;
  let empty = options.filtering ? allItems.length ? options.filtering.noMatch : options.filtering.empty : null;
  empty = options.propertyFiltering ? allItems.length ? options.propertyFiltering.noMatch : options.propertyFiltering.empty : empty;
  const filteringOptions = options.propertyFiltering ? options.propertyFiltering.filteringProperties.reduce((acc, property) => {
    Object.keys(allItems.reduce((acc2, item) => {
      acc2["" + fixupFalsyValues(item[property.key])] = true;
      return acc2;
    }, {})).forEach((value) => {
      if (value !== "") {
        acc.push({
          propertyKey: property.key,
          value
        });
      }
    });
    return acc;
  }, []) : [];
  return {
    collectionProps: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ empty }, options.sorting ? {
      onSortingChange: ({ detail }) => {
        actions.setSorting(detail);
      },
      sortingColumn: sortingState === null || sortingState === void 0 ? void 0 : sortingState.sortingColumn,
      sortingDescending: sortingState === null || sortingState === void 0 ? void 0 : sortingState.isDescending
    } : {}), options.expandableRows ? {
      expandableRows: {
        getItemChildren(item) {
          return itemsTree.getChildren(item);
        },
        isItemExpandable(item) {
          return itemsTree.getChildren(item).length > 0;
        },
        expandedItems,
        onExpandableItemToggle: ({ detail: { item, expanded } }) => {
          const getId = options.expandableRows.getId;
          if (expanded) {
            for (const stateItem of expandedItems) {
              if (getId(stateItem) === getId(item)) {
                return;
              }
            }
            actions.setExpandedItems([...expandedItems, item]);
          } else {
            actions.setExpandedItems(expandedItems.filter((stateItem) => getId(stateItem) !== getId(item)));
          }
        }
      },
      // The trackBy property is used to match expanded items by ID and not by object reference.
      // The property can be overridden by the explicitly provided selection.trackBy.
      // If that is the case, we assume both selection.trackBy and expandableRows.getId have the same result.
      // If not, the expandable state won't be matched correctly by the table.
      trackBy: options.expandableRows.getId
    } : {}), options.selection ? {
      onSelectionChange: ({ detail: { selectedItems: selectedItems2 } }) => {
        actions.setSelectedItems(selectedItems2);
      },
      selectedItems,
      trackBy: (_a = options.selection.trackBy) !== null && _a !== void 0 ? _a : (_b = options.expandableRows) === null || _b === void 0 ? void 0 : _b.getId
    } : {}), { ref: collectionRef, firstIndex: 1, totalItemsCount: allPageItems.length }), ((_c = options.pagination) === null || _c === void 0 ? void 0 : _c.pageSize) ? {
      firstIndex: ((actualPageIndex !== null && actualPageIndex !== void 0 ? actualPageIndex : currentPageIndex) - 1) * options.pagination.pageSize + 1
    } : {}),
    filterProps: {
      filteringText,
      onChange: ({ detail: { filteringText: filteringText2 } }) => {
        actions.setFiltering(filteringText2);
      }
    },
    propertyFilterProps: {
      query: propertyFilteringQuery,
      onChange: ({ detail: query }) => {
        actions.setPropertyFiltering(query);
      },
      filteringProperties: ((_d = options.propertyFiltering) === null || _d === void 0 ? void 0 : _d.filteringProperties) || [],
      filteringOptions,
      freeTextFiltering: (_e = options.propertyFiltering) === null || _e === void 0 ? void 0 : _e.freeTextFiltering
    },
    paginationProps: {
      currentPageIndex: actualPageIndex !== null && actualPageIndex !== void 0 ? actualPageIndex : currentPageIndex,
      // pagesCount is always calculated when options.pagination is present
      pagesCount,
      onChange: ({ detail: { currentPageIndex: currentPageIndex2 } }) => {
        actions.setCurrentPage(currentPageIndex2);
      }
    }
  };
}

// node_modules/@cloudscape-design/collection-hooks/mjs/use-collection-state.js
var import_react = __toESM(require_react(), 1);
function useCollectionState(options, collectionRef) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
  const [state, dispatch] = (0, import_react.useReducer)(collectionReducer, {
    selectedItems: (_b = (_a = options.selection) === null || _a === void 0 ? void 0 : _a.defaultSelectedItems) !== null && _b !== void 0 ? _b : [],
    expandedItems: (_d = (_c = options.expandableRows) === null || _c === void 0 ? void 0 : _c.defaultExpandedItems) !== null && _d !== void 0 ? _d : [],
    sortingState: (_e = options.sorting) === null || _e === void 0 ? void 0 : _e.defaultState,
    currentPageIndex: (_g = (_f = options.pagination) === null || _f === void 0 ? void 0 : _f.defaultPage) !== null && _g !== void 0 ? _g : 1,
    filteringText: (_j = (_h = options.filtering) === null || _h === void 0 ? void 0 : _h.defaultFilteringText) !== null && _j !== void 0 ? _j : "",
    propertyFilteringQuery: (_l = (_k = options.propertyFiltering) === null || _k === void 0 ? void 0 : _k.defaultQuery) !== null && _l !== void 0 ? _l : { tokens: [], operation: "and" }
  });
  const actions = (0, import_react.useMemo)(() => createActions({ dispatch, collectionRef }), [dispatch, collectionRef]);
  return [state, actions];
}

// node_modules/@cloudscape-design/collection-hooks/mjs/use-collection.js
function useCollection(allItems, options) {
  const collectionRef = (0, import_react2.useRef)(null);
  const [state, actions] = useCollectionState(options, collectionRef);
  const { items, allPageItems, pagesCount, filteredItemsCount, actualPageIndex, itemsTree } = processItems(allItems, state, options);
  const expandedItemsSet = /* @__PURE__ */ new Set();
  if (options.expandableRows) {
    for (const item of state.expandedItems) {
      expandedItemsSet.add(options.expandableRows.getId(item));
    }
  }
  let visibleItems = items;
  if (options.expandableRows) {
    const flatItems = new Array();
    const getId = options.expandableRows.getId;
    const traverse = (items2) => {
      for (const item of items2) {
        flatItems.push(item);
        if (expandedItemsSet.has(getId(item))) {
          traverse(itemsTree.getChildren(item));
        }
      }
    };
    traverse(items);
    visibleItems = flatItems;
  }
  if (options.selection && !options.selection.keepSelection) {
    const newSelectedItems = processSelectedItems(visibleItems, state.selectedItems, options.selection.trackBy);
    if (!itemsAreEqual(newSelectedItems, state.selectedItems, options.selection.trackBy)) {
      actions.setSelectedItems(newSelectedItems);
    }
  }
  if (options.expandableRows) {
    const newExpandedItems = visibleItems.filter((item) => expandedItemsSet.has(options.expandableRows.getId(item)));
    if (!itemsAreEqual(newExpandedItems, state.expandedItems, options.expandableRows.getId)) {
      actions.setExpandedItems(newExpandedItems);
    }
  }
  return Object.assign({
    items,
    allPageItems,
    filteredItemsCount,
    actions
  }, createSyncProps(options, state, actions, collectionRef, {
    actualPageIndex,
    pagesCount,
    allItems,
    allPageItems,
    itemsTree
  }));
}

export {
  useCollection
};
//# sourceMappingURL=chunk-DZ5XWKIS.js.map

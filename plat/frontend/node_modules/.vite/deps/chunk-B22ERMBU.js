import {
  FunnelContext,
  FunnelMetrics,
  FunnelStepContext,
  FunnelSubStepContext,
  PerformanceMetrics,
  nodeBelongs,
  useFunnel,
  useFunnelStep
} from "./chunk-74OPMLS2.js";
import {
  DATA_ATTR_FUNNEL_STEP,
  DATA_ATTR_RESOURCE_TYPE,
  getFunnelNameSelector,
  getSubStepAllSelector,
  getSubStepNameSelector,
  getSubStepSelector,
  getTextFromSelector
} from "./chunk-CRLP7JES.js";
import {
  PACKAGE_VERSION,
  THEME,
  __awaiter,
  __rest,
  useUniqueId,
  useVisualRefresh
} from "./chunk-SMWX7PPB.js";
import {
  require_react
} from "./chunk-QJTFJ6OV.js";
import {
  __toESM
} from "./chunk-V4OQ3NZ2.js";

// node_modules/@cloudscape-design/components/internal/analytics/components/analytics-funnel.js
var import_react2 = __toESM(require_react());

// node_modules/@cloudscape-design/components/internal/hooks/use-debounce-callback/index.js
var import_react = __toESM(require_react());

// node_modules/@cloudscape-design/components/internal/debounce.js
var DEBOUNCE_DEFAULT_DELAY = 200;
function debounce(func, delay = DEBOUNCE_DEFAULT_DELAY) {
  let timeout;
  return function(...args) {
    if (timeout) {
      clearTimeout(timeout);
    }
    timeout = setTimeout(() => {
      timeout = null;
      func(...args);
    }, delay);
  };
}

// node_modules/@cloudscape-design/components/internal/hooks/use-debounce-callback/index.js
function useDebounceCallback(callback, delay) {
  const callbackRef = (0, import_react.useRef)();
  callbackRef.current = callback;
  return (0, import_react.useCallback)(debounce((...args) => {
    if (callbackRef.current) {
      callbackRef.current(...args);
    }
  }, delay), []);
}

// node_modules/@cloudscape-design/components/internal/analytics/components/analytics-funnel.js
var FUNNEL_VERSION = "1.4";
var AnalyticsFunnel = (props) => {
  const { isInFunnel } = useFunnel();
  if (isInFunnel && props.funnelType === "single-page") {
    return import_react2.default.createElement(import_react2.default.Fragment, null, props.children);
  }
  return import_react2.default.createElement(InnerAnalyticsFunnel, Object.assign({}, props));
};
var CREATION_EDIT_FLOW_DONE_EVENT_NAME = "awsui-creation-edit-flow-done";
var dispatchCreateEditFlowDoneEvent = () => {
  var _a;
  try {
    (_a = window.top) === null || _a === void 0 ? void 0 : _a.document.dispatchEvent(new Event(CREATION_EDIT_FLOW_DONE_EVENT_NAME));
  } catch (_b) {
  }
};
var onFunnelCancelled = ({ funnelInteractionId, funnelIdentifier }) => {
  FunnelMetrics.funnelCancelled({ funnelInteractionId, funnelIdentifier });
};
var onFunnelComplete = (taskCompletionDataProps) => {
  FunnelMetrics.funnelComplete({
    funnelInteractionId: taskCompletionDataProps.taskInteractionId,
    funnelIdentifier: taskCompletionDataProps.taskIdentifier
  });
  PerformanceMetrics.taskCompletionData(taskCompletionDataProps);
  dispatchCreateEditFlowDoneEvent();
};
function evaluateSelectors(selectors, defaultSelector) {
  for (const selector of selectors) {
    const element = document.querySelector(selector);
    if (element) {
      return selector;
    }
  }
  return defaultSelector;
}
var InnerAnalyticsFunnel = (_a) => {
  var { mounted = true, children, stepConfiguration } = _a, props = __rest(_a, ["mounted", "children", "stepConfiguration"]);
  const [funnelInteractionId, setFunnelInteractionId] = (0, import_react2.useState)("");
  const [submissionAttempt, setSubmissionAttempt] = (0, import_react2.useState)(0);
  const isVisualRefresh = useVisualRefresh();
  const funnelState = (0, import_react2.useRef)("default");
  const funnelNameSelector = (0, import_react2.useRef)(getFunnelNameSelector());
  const errorCount = (0, import_react2.useRef)(0);
  const loadingButtonCount = (0, import_react2.useRef)(0);
  const wizardCount = (0, import_react2.useRef)(0);
  const latestFocusCleanupFunction = (0, import_react2.useRef)(void 0);
  const formSubmitStartTime = (0, import_react2.useRef)(0);
  (0, import_react2.useEffect)(() => {
    if (!mounted) {
      return;
    }
    let funnelInteractionId2;
    const handle = setTimeout(() => {
      var _a2, _b;
      funnelNameSelector.current = evaluateSelectors(((_a2 = props.funnelNameSelectors) === null || _a2 === void 0 ? void 0 : _a2.call(props)) || [], getFunnelNameSelector());
      if (props.funnelType === "single-page" && wizardCount.current > 0) {
        return;
      }
      funnelState.current = "default";
      const funnelName = (_b = getTextFromSelector(funnelNameSelector.current)) !== null && _b !== void 0 ? _b : "";
      const singleStepFlowStepConfiguration = [
        {
          number: 1,
          isOptional: false,
          name: funnelName,
          stepIdentifier: props.funnelIdentifier
        }
      ];
      let componentTheme = THEME;
      if (THEME === "polaris") {
        componentTheme = isVisualRefresh ? "vr" : "classic";
      }
      funnelInteractionId2 = FunnelMetrics.funnelStart({
        funnelName,
        funnelIdentifier: props.funnelIdentifier,
        flowType: props.funnelFlowType,
        funnelNameSelector: funnelNameSelector.current,
        optionalStepNumbers: props.optionalStepNumbers,
        funnelType: props.funnelType,
        totalFunnelSteps: props.totalFunnelSteps,
        componentVersion: PACKAGE_VERSION,
        componentTheme,
        funnelVersion: FUNNEL_VERSION,
        stepConfiguration: stepConfiguration !== null && stepConfiguration !== void 0 ? stepConfiguration : singleStepFlowStepConfiguration,
        resourceType: props.funnelResourceType || getTextFromSelector(`[${DATA_ATTR_RESOURCE_TYPE}]`)
      });
      setFunnelInteractionId(funnelInteractionId2);
    }, 1);
    return () => {
      clearTimeout(handle);
      if (props.funnelType === "single-page" && wizardCount.current > 0) {
        return;
      }
      if (funnelState.current === "validating") {
        const taskCompletionDataProps = {
          taskIdentifier: props.funnelIdentifier,
          taskType: props.funnelType,
          timeToRespondAfterFormSubmit: performance.now() - formSubmitStartTime.current,
          taskInteractionId: funnelInteractionId2,
          taskFlowType: props.funnelFlowType
        };
        onFunnelComplete(taskCompletionDataProps);
        funnelState.current = "complete";
      }
      if (funnelState.current === "complete") {
        FunnelMetrics.funnelSuccessful({ funnelInteractionId: funnelInteractionId2, funnelIdentifier: props.funnelIdentifier });
      } else {
        funnelState.current = "cancelled";
        onFunnelCancelled({ funnelInteractionId: funnelInteractionId2, funnelIdentifier: props.funnelIdentifier });
      }
    };
  }, [mounted]);
  const funnelSubmit = () => {
    funnelState.current = "validating";
    formSubmitStartTime.current = performance.now();
    const VALIDATION_WAIT_DELAY = 50;
    const LOADING_WAIT_DELAY = 100;
    const checkForCompleteness = () => {
      if (funnelState.current === "complete") {
        return;
      }
      if (loadingButtonCount.current > 0) {
        setTimeout(checkForCompleteness, LOADING_WAIT_DELAY);
        return;
      }
      if (errorCount.current === 0) {
        const taskCompletionDataProps = {
          taskIdentifier: props.funnelIdentifier,
          taskType: props.funnelType,
          timeToRespondAfterFormSubmit: performance.now() - formSubmitStartTime.current,
          taskInteractionId: funnelInteractionId,
          taskFlowType: props.funnelFlowType
        };
        onFunnelComplete(taskCompletionDataProps);
        funnelState.current = "complete";
      } else {
        funnelState.current = "default";
      }
    };
    setTimeout(checkForCompleteness, VALIDATION_WAIT_DELAY);
  };
  const funnelNextOrSubmitAttempt = () => setSubmissionAttempt((i) => i + 1);
  const funnelCancel = () => {
  };
  const funnelContextValue = {
    funnelInteractionId,
    funnelIdentifier: props.funnelIdentifier,
    funnelFlowType: props.funnelFlowType,
    funnelErrorContext: props.funnelErrorContext,
    setFunnelInteractionId,
    funnelType: props.funnelType,
    optionalStepNumbers: props.optionalStepNumbers,
    totalFunnelSteps: props.totalFunnelSteps,
    funnelNameSelector: funnelNameSelector.current,
    funnelSubmit,
    funnelCancel,
    submissionAttempt,
    funnelNextOrSubmitAttempt,
    funnelState,
    errorCount,
    loadingButtonCount,
    latestFocusCleanupFunction,
    isInFunnel: true,
    wizardCount
  };
  return import_react2.default.createElement(FunnelContext.Provider, { value: funnelContextValue }, children);
};
var AnalyticsFunnelStep = (props) => {
  return import_react2.default.createElement(InnerAnalyticsFunnelStep, Object.assign({}, props, { key: props.stepNumber }));
};
function getSubStepConfiguration() {
  const subSteps = Array.from(document.querySelectorAll(getSubStepAllSelector()));
  const subStepConfiguration = subSteps.map((substep, index) => {
    var _a, _b, _c, _d, _e;
    const subStepIdentifier = (_b = (_a = substep === null || substep === void 0 ? void 0 : substep.__awsuiMetadata__) === null || _a === void 0 ? void 0 : _a.analytics) === null || _b === void 0 ? void 0 : _b.instanceIdentifier;
    const name = (_e = (_d = (_c = substep.querySelector(getSubStepNameSelector())) === null || _c === void 0 ? void 0 : _c.innerText) === null || _d === void 0 ? void 0 : _d.trim()) !== null && _e !== void 0 ? _e : "";
    return {
      name,
      number: index + 1,
      subStepIdentifier
    };
  });
  return subStepConfiguration;
}
function useStepChangeListener(stepNumber, handler) {
  const subStepConfiguration = (0, import_react2.useRef)(/* @__PURE__ */ new Map());
  const SUBSTEP_CHANGE_DEBOUNCE = 50;
  const listenForSubStepChanges = (0, import_react2.useRef)(false);
  (0, import_react2.useEffect)(() => {
    const handle = setTimeout(() => listenForSubStepChanges.current = true, SUBSTEP_CHANGE_DEBOUNCE);
    return () => {
      clearTimeout(handle);
      listenForSubStepChanges.current = false;
    };
  }, []);
  (0, import_react2.useEffect)(() => {
    const handle = setTimeout(() => subStepConfiguration.current.set(stepNumber, getSubStepConfiguration()), SUBSTEP_CHANGE_DEBOUNCE);
    return () => {
      clearTimeout(handle);
    };
  }, [stepNumber]);
  const stepChangeCallback = useDebounceCallback(() => {
    if (!listenForSubStepChanges.current) {
      return;
    }
    subStepConfiguration.current.set(stepNumber, getSubStepConfiguration());
    handler(subStepConfiguration.current.get(stepNumber));
  }, SUBSTEP_CHANGE_DEBOUNCE);
  return { onStepChange: stepChangeCallback, subStepConfiguration };
}
var InnerAnalyticsFunnelStep = (_a) => {
  var { mounted = true, children, stepNumber, stepIdentifier, stepErrorContext } = _a, rest = __rest(_a, ["mounted", "children", "stepNumber", "stepIdentifier", "stepErrorContext"]);
  const { funnelInteractionId, funnelIdentifier, funnelNameSelector, funnelState, funnelType } = useFunnel();
  const parentStep = useFunnelStep();
  const parentStepExists = parentStep.isInStep;
  const parentStepFunnelInteractionId = parentStep.funnelInteractionId;
  const funnelStepProps = { [DATA_ATTR_FUNNEL_STEP]: stepNumber };
  const subStepCount = (0, import_react2.useRef)(0);
  const stepNameSelector = rest.stepNameSelector || funnelNameSelector;
  const { onStepChange, subStepConfiguration } = useStepChangeListener(stepNumber, (subStepConfiguration2) => {
    if (!funnelInteractionId) {
      return;
    }
    FunnelMetrics.funnelStepChange({
      stepIdentifier,
      funnelIdentifier,
      funnelInteractionId,
      stepNumber,
      stepNameSelector,
      subStepAllSelector: getSubStepAllSelector(),
      totalSubSteps: subStepCount.current,
      subStepConfiguration: subStepConfiguration2
    });
  });
  (0, import_react2.useEffect)(() => {
    if (!funnelInteractionId) {
      return;
    }
    if (mounted) {
      return;
    }
    const stepName = getTextFromSelector(stepNameSelector);
    const handler = setTimeout(() => {
      if (funnelState.current !== "cancelled") {
        FunnelMetrics.funnelStepComplete({
          funnelIdentifier,
          funnelInteractionId,
          stepIdentifier,
          stepNumber,
          stepName,
          stepNameSelector,
          subStepAllSelector: getSubStepAllSelector(),
          totalSubSteps: subStepCount.current
        });
      }
    }, 0);
    return () => {
      clearTimeout(handler);
    };
  }, [
    stepIdentifier,
    funnelIdentifier,
    funnelInteractionId,
    stepNumber,
    stepNameSelector,
    funnelState,
    parentStepExists,
    funnelType,
    parentStepFunnelInteractionId,
    mounted
  ]);
  (0, import_react2.useEffect)(() => {
    if (!funnelInteractionId) {
      return;
    }
    if (parentStepExists && parentStepFunnelInteractionId) {
      return;
    }
    const stepName = getTextFromSelector(stepNameSelector);
    if (funnelState.current === "default") {
      FunnelMetrics.funnelStepStart({
        stepIdentifier,
        funnelIdentifier,
        funnelInteractionId,
        stepNumber,
        stepName,
        stepNameSelector,
        subStepAllSelector: getSubStepAllSelector(),
        totalSubSteps: subStepCount.current,
        subStepConfiguration: getSubStepConfiguration()
      });
    }
    return () => {
      if (funnelState.current !== "cancelled") {
        FunnelMetrics.funnelStepComplete({
          funnelIdentifier,
          funnelInteractionId,
          stepIdentifier,
          stepNumber,
          stepName,
          stepNameSelector,
          subStepAllSelector: getSubStepAllSelector(),
          // eslint-disable-next-line react-hooks/exhaustive-deps
          totalSubSteps: subStepCount.current
        });
      }
    };
  }, [
    stepIdentifier,
    funnelIdentifier,
    funnelInteractionId,
    stepNumber,
    stepNameSelector,
    funnelState,
    parentStepExists,
    funnelType,
    parentStepFunnelInteractionId
  ]);
  const contextValue = {
    stepIdentifier,
    stepNumber,
    stepNameSelector,
    funnelStepProps,
    subStepCount,
    isInStep: true,
    funnelInteractionId,
    onStepChange,
    subStepConfiguration,
    stepErrorContext
  };
  const effectiveContextValue = parentStepExists && parentStepFunnelInteractionId ? parentStep : contextValue;
  return import_react2.default.createElement(FunnelStepContext.Provider, { value: effectiveContextValue }, typeof children === "function" ? children(effectiveContextValue) : children);
};
var AnalyticsFunnelSubStep = ({ children, subStepIdentifier, subStepErrorContext }) => {
  const subStepId = useUniqueId("substep");
  const subStepSelector = getSubStepSelector(subStepId);
  const subStepNameSelector = getSubStepNameSelector(subStepId);
  const subStepRef = (0, import_react2.useRef)(null);
  const { subStepCount, onStepChange } = useFunnelStep();
  const mousePressed = (0, import_react2.useRef)(false);
  const isFocusedSubStep = (0, import_react2.useRef)(false);
  const focusCleanupFunction = (0, import_react2.useRef)(void 0);
  const { funnelState, funnelInteractionId } = useFunnel();
  const { stepNumber, stepNameSelector } = useFunnelStep();
  const newContext = {
    subStepIdentifier,
    subStepErrorContext,
    subStepSelector,
    subStepNameSelector,
    subStepId,
    subStepRef,
    mousePressed,
    isFocusedSubStep,
    focusCleanupFunction,
    isNestedSubStep: false
  };
  const inheritedContext = Object.assign(Object.assign({}, (0, import_react2.useContext)(FunnelSubStepContext)), { isNestedSubStep: true });
  const isNested = Boolean(inheritedContext.subStepId);
  (0, import_react2.useEffect)(() => {
    if (!isNested) {
      subStepCount.current++;
      onStepChange();
      return () => {
        subStepCount.current--;
        onStepChange();
      };
    }
  }, [isNested, subStepCount, onStepChange]);
  const context = isNested ? inheritedContext : newContext;
  (0, import_react2.useEffect)(() => {
    if (isNested || !subStepRef.current) {
      return;
    }
    const onMouseDown = () => mousePressed.current = true;
    const onMouseUp = () => __awaiter(void 0, void 0, void 0, function* () {
      var _a;
      mousePressed.current = false;
      if (!isFocusedSubStep.current) {
        return;
      }
      yield new Promise((r) => setTimeout(r, 1));
      if (!subStepRef.current || !document.activeElement || !nodeBelongs(subStepRef.current, document.activeElement)) {
        isFocusedSubStep.current = false;
        (_a = focusCleanupFunction.current) === null || _a === void 0 ? void 0 : _a.call(focusCleanupFunction);
      }
    });
    const controller = new AbortController();
    window.addEventListener("mousedown", onMouseDown, { signal: controller.signal });
    window.addEventListener("mouseup", onMouseUp, { signal: controller.signal });
    return () => {
      controller.abort();
    };
  }, [
    funnelInteractionId,
    funnelState,
    stepNameSelector,
    stepNumber,
    subStepNameSelector,
    subStepSelector,
    focusCleanupFunction,
    isNested,
    subStepRef
  ]);
  return import_react2.default.createElement(FunnelSubStepContext.Provider, { value: context }, typeof children === "function" ? children(context) : children);
};

export {
  debounce,
  useDebounceCallback,
  AnalyticsFunnel,
  AnalyticsFunnelStep,
  AnalyticsFunnelSubStep
};
//# sourceMappingURL=chunk-B22ERMBU.js.map
